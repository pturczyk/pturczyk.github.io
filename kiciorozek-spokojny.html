<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ü¶Ñüò∫ Kicioro≈ºek - Spokojna Przygoda üåà</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', cursive;
            background: #000;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #87CEEB;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 20px;
            border: 4px solid #FF69B4;
            font-size: 1.2em;
            color: #FF1493;
            box-shadow: 0 5px 20px rgba(255, 105, 180, 0.5);
            z-index: 10;
        }

        .friends-parade {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 20px;
            border: 4px solid #FF69B4;
            font-size: 1.1em;
            color: #FF1493;
            box-shadow: 0 5px 20px rgba(255, 105, 180, 0.5);
            z-index: 10;
            max-width: 250px;
        }

        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            padding: 40px;
            border-radius: 30px;
            border: 8px solid #FF69B4;
            text-align: center;
            display: none;
            z-index: 100;
            box-shadow: 0 10px 40px rgba(255, 105, 180, 0.5);
        }

        .message.active {
            display: block;
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        button {
            background: linear-gradient(135deg, #FF69B4, #FF1493);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.3em;
            font-family: 'Comic Sans MS', cursive;
            border-radius: 50px;
            cursor: pointer;
            margin: 10px;
            box-shadow: 0 5px 15px rgba(255, 20, 147, 0.4);
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(255, 20, 147, 0.6);
        }

        .hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 30px;
            border-radius: 15px;
            border: 3px solid #FF69B4;
            color: #FF1493;
            font-size: 1.1em;
            z-index: 10;
            display: none;
        }

        .wardrobe {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 20px;
            border: 4px solid #FF69B4;
            z-index: 10;
            max-width: 250px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .wardrobe h3 {
            color: #FF1493;
            margin: 0 0 10px 0;
            font-size: 1.1em;
        }

        .wardrobe-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }

        .wardrobe-item {
            background: linear-gradient(135deg, #FFE5F1, #FFF);
            border: 2px solid #FF69B4;
            border-radius: 10px;
            padding: 8px;
            cursor: pointer;
            font-size: 1.8em;
            transition: all 0.2s;
            position: relative;
        }

        .wardrobe-item:hover {
            transform: scale(1.1);
            border-color: #FF1493;
            box-shadow: 0 3px 10px rgba(255, 105, 180, 0.4);
        }

        .wardrobe-item.equipped {
            background: linear-gradient(135deg, #FF69B4, #FFB6D9);
            border-color: #FF1493;
            box-shadow: 0 0 15px rgba(255, 105, 180, 0.6);
        }

        .wardrobe-item.equipped::after {
            content: '‚úì';
            position: absolute;
            top: -5px;
            right: -5px;
            background: #00FF00;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wardrobe-section {
            margin-bottom: 8px;
        }

        .wardrobe-section-title {
            color: #8B008B;
            font-size: 0.9em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        /* ===== TOUCH CONTROLS ===== */
        .touch-controls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 200;
            pointer-events: none;
            padding: 10px;
        }

        .touch-dpad {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 140px;
            height: 140px;
            pointer-events: auto;
        }

        .touch-btn {
            position: absolute;
            background: rgba(255, 105, 180, 0.45);
            border: 3px solid rgba(255, 105, 180, 0.7);
            border-radius: 50%;
            color: white;
            font-size: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            transition: background 0.1s;
        }

        .touch-btn:active, .touch-btn.pressed {
            background: rgba(255, 20, 147, 0.7);
            border-color: rgba(255, 20, 147, 0.9);
        }

        .touch-btn-left {
            width: 52px;
            height: 52px;
            left: 0;
            top: 44px;
        }

        .touch-btn-right {
            width: 52px;
            height: 52px;
            right: 0;
            top: 44px;
        }

        .touch-btn-up {
            width: 52px;
            height: 52px;
            left: 44px;
            top: 0;
        }

        .touch-action-area {
            position: absolute;
            bottom: 20px;
            right: 20px;
            pointer-events: auto;
        }

        .touch-btn-action {
            width: 72px;
            height: 72px;
            position: relative;
            background: rgba(255, 215, 0, 0.5);
            border: 3px solid rgba(255, 215, 0, 0.8);
            border-radius: 50%;
            color: white;
            font-size: 16px;
            font-weight: bold;
            font-family: 'Comic Sans MS', cursive;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .touch-btn-action:active, .touch-btn-action.pressed {
            background: rgba(255, 215, 0, 0.8);
        }

        .touch-btn-jump {
            width: 64px;
            height: 64px;
            position: relative;
            margin-bottom: 12px;
            background: rgba(100, 200, 255, 0.5);
            border: 3px solid rgba(100, 200, 255, 0.8);
            border-radius: 50%;
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .touch-btn-jump:active, .touch-btn-jump.pressed {
            background: rgba(100, 200, 255, 0.8);
        }

        /* ===== MOBILE RESPONSIVE ===== */
        @media (max-width: 768px) {
            .hud {
                top: 5px;
                left: 5px;
                padding: 8px 12px;
                font-size: 0.75em;
                border-radius: 12px;
                border-width: 2px;
            }

            .friends-parade {
                top: 5px;
                right: 5px;
                padding: 6px 10px;
                font-size: 0.7em;
                border-radius: 12px;
                border-width: 2px;
                max-width: 140px;
            }

            .wardrobe {
                bottom: auto;
                top: 60px;
                right: 5px;
                padding: 6px;
                border-radius: 12px;
                border-width: 2px;
                max-width: 160px;
                font-size: 0.7em;
                max-height: 40vh;
                overflow-y: auto;
            }

            .wardrobe h3 {
                font-size: 0.85em;
                margin: 0 0 4px 0;
            }

            .wardrobe-item {
                font-size: 1.2em;
                padding: 4px;
            }

            .wardrobe-items {
                gap: 4px;
            }

            .hint {
                display: none !important;
            }

            .message {
                padding: 20px;
                border-width: 4px;
                border-radius: 20px;
                width: 90vw;
                max-width: 400px;
            }

            .message h2 {
                font-size: 1.3em !important;
            }

            .message p {
                font-size: 0.9em !important;
            }

            .message button {
                padding: 10px 25px;
                font-size: 1em;
            }
        }

        @media (max-width: 480px) {
            .hud {
                padding: 5px 8px;
                font-size: 0.65em;
            }

            .friends-parade {
                max-width: 110px;
                font-size: 0.6em;
            }

            .wardrobe {
                max-width: 120px;
                font-size: 0.6em;
            }
        }

        /* Show touch controls on touch devices */
        @media (hover: none) and (pointer: coarse) {
            .touch-controls {
                display: block !important;
            }

            .hint {
                display: none !important;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div class="hud">
        ü™ô Monety: <span id="coins">0</span><br>
        üç¨ Cukierki: <span id="score">0</span><br>
        üìç Pozycja: <span id="position">0</span>m<br>
        üéµ <span id="mood">Miau! üò∫</span>
    </div>

    <div class="friends-parade">
        <strong>Parada przyjaci√≥≈Ç:</strong><br>
        <div id="friends-list" style="margin-top: 10px; font-size: 1.5em;">
            (czeka na przyjaci√≥≈Ç)
        </div>
    </div>

    <div class="wardrobe">
        <h3>üëó Garderoba ü¶Ñ</h3>

        <div class="wardrobe-section">
            <div class="wardrobe-section-title">R√≥g:</div>
            <div class="wardrobe-items" id="horn-items"></div>
        </div>

        <div class="wardrobe-section">
            <div class="wardrobe-section-title">Ubranka:</div>
            <div class="wardrobe-items" id="outfit-items"></div>
        </div>

        <div class="wardrobe-section">
            <div class="wardrobe-section-title">Akcesoria:</div>
            <div class="wardrobe-items" id="accessory-items"></div>
        </div>

        <div class="wardrobe-section">
            <div class="wardrobe-section-title">Kolor futerka:</div>
            <div class="wardrobe-items" id="color-items"></div>
        </div>

        <div class="wardrobe-section">
            <div class="wardrobe-section-title">Fryzura:</div>
            <div class="wardrobe-items" id="hairstyle-items"></div>
        </div>

        <div class="wardrobe-section">
            <div class="wardrobe-section-title">Kolor w≈Ços√≥w:</div>
            <div class="wardrobe-items" id="haircolor-items"></div>
        </div>

        <div class="wardrobe-section">
            <div class="wardrobe-section-title">Spinki:</div>
            <div class="wardrobe-items" id="hairclip-items"></div>
        </div>
    </div>

    <div class="hint">
        ‚¨ÖÔ∏è‚û°Ô∏è A/D lub strza≈Çki - Spacer | ‚¨ÜÔ∏è SPACJA - Skocz / Walcz / Wejd≈∫ do domu üè† | Odkrywaj spokojny ≈õwiat! üå∏
    </div>

    <!-- Touch controls for mobile/tablet -->
    <div class="touch-controls" id="touch-controls">
        <div class="touch-dpad">
            <div class="touch-btn touch-btn-left" data-key="ArrowLeft">‚óÄ</div>
            <div class="touch-btn touch-btn-right" data-key="ArrowRight">‚ñ∂</div>
            <div class="touch-btn touch-btn-up" data-key="ArrowUp">‚ñ≤</div>
        </div>
        <div class="touch-action-area">
            <div class="touch-btn-jump" data-key="ArrowUp">‚¨Ü</div>
            <div class="touch-btn-action" data-key=" ">SPACJA</div>
        </div>
    </div>

    <div class="message active" id="start-screen">
        <h2 style="color: #FF1493; font-size: 2em; margin-bottom: 20px;">
            ü¶Ñüò∫ Witaj w Candy Krainie! üåà‚ú®
        </h2>
        <p style="color: #8B008B; font-size: 1.2em; margin: 20px 0; line-height: 1.6;">
            Jestem Kicioro≈ºek! üê±ü¶Ñ<br><br>
            Wyruszam w spokojnƒÖ podr√≥≈º po piƒôknej krainie! üíñ<br>
            Zbiorƒô cukierki i znajdƒô przyjaci√≥≈Ç! üç≠<br><br>
            <strong>üå∏ To spokojna przygoda bez niebezpiecze≈Ñstw!</strong><br>
            Spaceruj, eksploruj i ciesz siƒô podr√≥≈ºƒÖ! ‚ú®<br>
            Mo≈ºesz skakaƒá je≈õli chcesz, ale nie musisz! üòä<br><br>
            Ka≈ºdy znaleziony przyjaciel bƒôdzie za TobƒÖ podƒÖ≈ºa≈Ç! üíï
        </p>
        <button onclick="startGame()" ontouchend="startGame()">Dotknij lub naci≈õnij SPACJƒò - Zacznij podr√≥≈º! üöÄ‚ú®</button>
    </div>

    <div class="message" id="victory-screen">
        <h2 style="color: #FF1493; font-size: 2.5em;">Wspania≈Ça przygoda! üéâüåà</h2>
        <p style="color: #8B008B; font-size: 1.3em; margin: 20px 0; line-height: 1.6;">
            Znalaz≈Çe≈õ wszystkich 10 przyjaci√≥≈Ç! üéä<br>
            Twoja parada jest kompletna! üíï‚ú®<br><br>
            Zebrane cukierki: <strong id="final-score">0</strong> üç¨<br>
            Przebyta droga: <strong id="final-distance">0</strong>m üó∫Ô∏è<br><br>
            <span style="font-size: 2em;">üê±ü¶Ñüê∂üê∞üêªüêëüê¨ü¶äüêºü¶Ñüê∏ü¶ã</span><br><br>
            Mo≈ºesz dalej eksplorowaƒá lub zagraƒá ponownie! üòä
        </p>
        <button onclick="closeFriendMessage()">Dalej zwiedzaj! üåç</button>
        <button onclick="location.reload()">Nowa przygoda! üéÆ</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Stan gry
        let gameRunning = false;
        let score = 0;
        let coins = 0;
        let keys = {};
        let worldOffset = 0;
        let animationFrame = 0;

        // Pogoda i pora dnia
        let gameTimeStart = 0; // set on game start
        let raindrops = []; // active raindrops

        // Kicioro≈ºek
        const player = {
            x: 300,
            y: canvas.height - 150,
            width: 60,
            height: 80,
            speed: 8,
            velY: 0,
            jumping: false,
            gravity: 0.6,
            jumpPower: -12,
            facingRight: true,
            walkCycle: 0,
            tailSwing: 0,
            // Garderoba
            equippedHorn: 'gold',
            equippedOutfit: null,
            equippedAccessory: null,
            equippedColor: 'pink', // Domy≈õlny r√≥≈ºowy
            // Fryzjer
            equippedHairstyle: null,
            equippedHairColor: null,
            equippedHairClip: null
        };

        // Dostƒôpne przedmioty
        let collectedItems = {
            horns: ['gold'], // Z≈Çoty domy≈õlnie
            outfits: [],
            accessories: [],
            colors: ['pink'], // R√≥≈ºowy domy≈õlnie
            hairstyles: [],
            hairColors: [],
            hairClips: []
        };

        // Przedmioty do zbierania w ≈õwiecie
        let itemsToCollect = [];

        // Definicje przedmiot√≥w
        const itemDefinitions = {
            horns: [
                { id: 'gold', emoji: 'üåü', color: '#FFD700', name: 'Z≈Çoty r√≥g' },
                { id: 'rainbow', emoji: 'üåà', color: null, name: 'Tƒôczowy r√≥g' },
                { id: 'pink', emoji: 'üíñ', color: '#FF69B4', name: 'R√≥≈ºowy r√≥g' },
                { id: 'blue', emoji: 'üíé', color: '#87CEEB', name: 'Niebieski r√≥g' },
                { id: 'purple', emoji: 'üíú', color: '#9370DB', name: 'Fioletowy r√≥g' },
                { id: 'green', emoji: 'üíö', color: '#90EE90', name: 'Zielony r√≥g' }
            ],
            outfits: [
                { id: 'cape', emoji: 'ü¶∏', name: 'Peleryna' },
                { id: 'dress', emoji: 'üëó', name: 'Sukienka' },
                { id: 'scarf', emoji: 'üß£', name: 'Szalik' },
                { id: 'shirt', emoji: 'üëï', name: 'Koszulka' },
                { id: 'sweater', emoji: 'üß•', name: 'Sweterek' },
                { id: 'tutu', emoji: 'ü©∞', name: 'Tutu baletowe' },
                { id: 'pajamas', emoji: 'üõå', name: 'Pi≈ºamka' },
                { id: 'raincoat', emoji: 'üåßÔ∏è', name: 'P≈Çaszcz przeciwdeszczowy' },
                { id: 'armor', emoji: 'üõ°Ô∏è', name: 'Zbroja rycerska' },
                { id: 'kimono', emoji: 'üëò', name: 'Kimono' },
                { id: 'tuxedo', emoji: 'ü§µ', name: 'Smoking' },
                { id: 'overalls', emoji: 'üë®‚Äçüåæ', name: 'Ogrodniczki' }
            ],
            accessories: [
                { id: 'crown', emoji: 'üëë', name: 'Korona' },
                { id: 'bow', emoji: 'üéÄ', name: 'Kokarda' },
                { id: 'glasses', emoji: 'üëì', name: 'Okulary' },
                { id: 'hat', emoji: 'üé©', name: 'Kapelusz' },
                { id: 'flower', emoji: 'üå∏', name: 'Kwiatek' },
                { id: 'sunglasses', emoji: 'üï∂Ô∏è', name: 'Okulary przeciws≈Çoneczne' },
                { id: 'necklace', emoji: 'üìø', name: 'Naszyjnik' },
                { id: 'watch', emoji: '‚åö', name: 'Zegarek' },
                { id: 'backpack', emoji: 'üéí', name: 'Plecaczek' },
                { id: 'headphones', emoji: 'üéß', name: 'S≈Çuchawki' },
                { id: 'tiara', emoji: 'üíé', name: 'Tiara' },
                { id: 'scarf_acc', emoji: 'üß∂', name: 'Szaliczek we≈Çniany' }
            ],
            colors: [
                { id: 'pink', emoji: 'ü©∑', name: 'R√≥≈ºowy', bodyColor: '#FFC0CB', shadeColor: '#FFB6D9' },
                { id: 'white', emoji: 'ü§ç', name: 'Bia≈Çy', bodyColor: '#FFF', shadeColor: '#F5F5F5' },
                { id: 'orange', emoji: 'üß°', name: 'Pomara≈Ñczowy', bodyColor: '#FFA500', shadeColor: '#FF8C00' },
                { id: 'yellow', emoji: 'üíõ', name: '≈ª√≥≈Çty', bodyColor: '#FFD700', shadeColor: '#FFA500' },
                { id: 'green', emoji: 'üíö', name: 'Zielony', bodyColor: '#90EE90', shadeColor: '#7FBF7F' },
                { id: 'blue', emoji: 'üíô', name: 'Niebieski', bodyColor: '#87CEEB', shadeColor: '#6CA6CD' },
                { id: 'purple', emoji: 'üíú', name: 'Fioletowy', bodyColor: '#DDA0DD', shadeColor: '#BA7FBA' },
                { id: 'brown', emoji: 'ü§é', name: 'BrƒÖzowy', bodyColor: '#CD853F', shadeColor: '#8B4513' },
                { id: 'gray', emoji: 'ü©∂', name: 'Szary', bodyColor: '#C0C0C0', shadeColor: '#A9A9A9' },
                { id: 'black', emoji: 'üñ§', name: 'Czarny', bodyColor: '#696969', shadeColor: '#000' }
            ],
            hairstyles: [
                { id: 'ponytail', emoji: 'üéÄ', name: 'Kucyk' },
                { id: 'curly', emoji: 'üåÄ', name: 'Loki' },
                { id: 'spiky', emoji: '‚ö°', name: 'Je≈ºyk' },
                { id: 'long', emoji: 'üíá', name: 'D≈Çugie w≈Çosy' },
                { id: 'buns', emoji: 'üç°', name: 'Koczki' },
                { id: 'bob', emoji: '‚úÇÔ∏è', name: 'Bob' },
                { id: 'mohawk', emoji: 'ü¶Å', name: 'Irokez' },
                { id: 'braids', emoji: 'ü™¢', name: 'Warkoczyki' },
                { id: 'afro', emoji: '‚òÅÔ∏è', name: 'Afro' },
                { id: 'pigtails', emoji: 'üéÄ', name: 'Kitki' }
            ],
            hairColors: [
                { id: 'hc_blonde', emoji: 'üíõ', name: 'Blond', color: '#FFD700' },
                { id: 'hc_brown', emoji: 'ü§é', name: 'BrƒÖzowy', color: '#8B4513' },
                { id: 'hc_black', emoji: 'üñ§', name: 'Czarny', color: '#1a1a1a' },
                { id: 'hc_red', emoji: '‚ù§Ô∏è', name: 'Rudy', color: '#CC3300' },
                { id: 'hc_pink', emoji: 'ü©∑', name: 'R√≥≈ºowy', color: '#FF69B4' },
                { id: 'hc_blue', emoji: 'üíô', name: 'Niebieski', color: '#4169E1' },
                { id: 'hc_purple', emoji: 'üíú', name: 'Fioletowy', color: '#8A2BE2' },
                { id: 'hc_green', emoji: 'üíö', name: 'Zielony', color: '#32CD32' },
                { id: 'hc_silver', emoji: 'ü©∂', name: 'Srebrny', color: '#C0C0C0' },
                { id: 'hc_rainbow', emoji: 'üåà', name: 'Tƒôczowy', color: 'rainbow' }
            ],
            hairClips: [
                { id: 'clip_star', emoji: '‚≠ê', name: 'Gwiazdka' },
                { id: 'clip_heart', emoji: 'üíñ', name: 'Serduszko' },
                { id: 'clip_butterfly', emoji: 'ü¶ã', name: 'Motyl' },
                { id: 'clip_flower', emoji: 'üå∫', name: 'Kwiatek' },
                { id: 'clip_moon', emoji: 'üåô', name: 'Ksiƒô≈ºyc' }
            ]
        };

        // Przyjaciele
        let followingFriends = [];
        const friendTypes = [
            { emoji: 'üê∂', name: 'Tƒôczowy Piesek', sound: 'HAU HAU! Uwielbiam spacery!', color: '#FFD700' },
            { emoji: 'üê∞', name: 'R√≥≈ºowy Kr√≥liczek', sound: 'Hopsasa! Tak siƒô cieszƒô!', color: '#FF69B4' },
            { emoji: 'üêª', name: 'Gwiazdkowy Misiek', sound: 'Mi≈õkowe u≈õciski dla wszystkich!', color: '#DDA0DD' },
            { emoji: 'üêë', name: 'Chmurka Baranek', sound: 'Beeee! P≈Çynƒô jak chmurka!', color: '#E0C3FC' },
            { emoji: 'üê¨', name: 'Magiczny Delfinek', sound: 'P≈Çum p≈Çum! Weso≈Ço!', color: '#87CEEB' },
            { emoji: 'ü¶ä', name: 'Ognisty Lisek', sound: 'Yip yip! Przygoda!', color: '#FF8C00' },
            { emoji: 'üêº', name: 'Pandu≈õ', sound: 'Nom nom bambus√≥w!', color: '#98FB98' },
            { emoji: 'ü¶Ñ', name: 'Siostrzyczka Jednoro≈ºec', sound: 'Ihaha! Jeste≈õmy rodzinƒÖ!', color: '#E0B0FF' },
            { emoji: 'üê∏', name: '≈ªabka Skoczek', sound: 'Kwa kwa! Super zabawa!', color: '#90EE90' },
            { emoji: 'ü¶ã', name: 'Motyl B≈Çyszczek', sound: 'Fru fru! Piƒôkny dzie≈Ñ!', color: '#FFB6D9' }
        ];

        let playerHistory = [];
        const historyLength = 40;

        // Player 2 (co-op) state
        let player2 = {
            active: false,
            selectedIndex: -1,
            selectedType: null,
            // World
            worldX: 0, worldY: 0, velY: 0, jumping: false,
            facingRight: true, walkCycle: 0,
            speed: 8, gravity: 0.6, jumpPower: -12,
            // Interior
            interiorX: 200, interiorY: 0,
            interiorAction: 'none', interiorActionTimer: 0,
            bathFoam: false, bathtubWaterLevel: 0
        };
        let p2ControlledFriendEmoji = null;

        // ≈öwiat
        let ground = [];
        let candies = [];
        let friendsToFind = [];
        let decorations = [];
        let flowers = [];
        let trees = [];
        let passingAnimals = []; // Zwierzƒôta kt√≥re mijajƒÖ
        let dialogBubbles = []; // Chmurki dialogowe
        let fartClouds = []; // Chmurki pierdzenia
        let fartCooldown = 0; // Cooldown ≈ºeby nie spamowaƒá
        const chunkSize = 1000;
        let generatedChunks = new Set();
        let furthestPosition = 0;

        // State Management System
        let gameState = 'world'; // 'world' | 'interior' | 'battle' | 'kindergarten' | 'office' | 'shop' | 'hairdresser'
        let previousState = 'world';

        // House System
        let houses = []; // Dynamically generated houses

        // Interior State
        let interiorFriends = [];
        let interiorAnimationFrame = 0;
        let interiorOffset = 0; // Camera offset for scrolling interior
        let interiorPlayer = {
            x: 200, // World position
            y: 0, // set on enter based on floorY
            action: 'none', // 'none' | 'sleeping' | 'toilet' | 'washing' | 'eating' | 'playing' | 'bathing'
            actionTimer: 0,
            actionObject: null, // Which object player is interacting with
            bathFoam: false, // Toggle foam on head while bathing
            bathtubWaterLevel: 0,
            bathDone: false // Track if bath was completed (for drain on next space)
        };
        let interiorLightLevel = 1.0; // 1.0 = fully lit, 0.15 = sleeping darkness
        let tvChannel = 0; // 0 = bajka, 1 = wiadomo≈õci, 2 = pi≈Çka no≈ºna

        // Conversation system
        let activeConversation = null; // { friend, messages, currentMsg, timer, phase }

        // Photo system
        let wallPhoto = null; // Image data URL of captured photo
        let photoFlashTimer = 0; // Flash effect when taking photo

        // Cat needs system - values 0-100, need shows when >= 70
        // Needs grow every 50 steps walked
        let catNeeds = {
            hunger: 0,
            sleep: 0,
            toilet: 0,
            hygiene: 0
        };
        let catStepCounter = 0; // Total steps walked
        let interiorObjects = []; // Procedurally placed furniture

        // Slide System
        let slideState = {
            active: false,       // Is player on the slide?
            climbStep: 0,        // 0-3 (3 = at top, ready to slide)
            sliding: false,      // Currently sliding down?
            slideProgress: 0,    // 0-1 slide down progress
            slideHouseX: 0       // Which house's slide
        };

        // Kindergarten System
        let kindergartens = [];
        let kindergartenState = {
            active: false,
            playerX: 200,
            playerY: 0,
            // Math board
            mathBoard: {
                active: false,
                problem: null, // { text: '3+6=?', answer: 9, options: [7, 9, 12, 5] }
                selectedOption: 0,
                result: null, // 'correct' | 'wrong' | null
                resultTimer: 0,
                score: 0
            },
            // Word-picture board
            wordBoard: {
                active: false,
                word: null, // { text: 'kot', correctEmoji: 'üê±', options: ['üê±','üê∂','üê∞','üêª'] }
                selectedOption: 0,
                result: null,
                resultTimer: 0,
                score: 0
            }
        };
        const kindergartenWords = [
            { text: 'kot', emoji: 'üê±' },
            { text: 'pies', emoji: 'üê∂' },
            { text: 'baran', emoji: 'üêë' },
            { text: 'kr√≥lik', emoji: 'üê∞' },
            { text: 'mi≈õ', emoji: 'üêª' },
            { text: 'ko≈Ñ', emoji: 'üê¥' },
            { text: 'kura', emoji: 'üêî' },
            { text: 'ryba', emoji: 'üêü' },
            { text: 'ptak', emoji: 'üê¶' },
            { text: '≈ºaba', emoji: 'üê∏' }
        ];
        const allAnimalEmojis = ['üê±','üê∂','üêë','üê∞','üêª','üê¥','üêî','üêü','üê¶','üê∏','üê∑','üêÆ','ü¶ä','üê∫'];

        // Office (Praca) System
        let offices = [];
        let officeState = {
            active: false,
            playerX: 200,
            playerY: 0,
            computer: {
                active: false,
                task: null,
                selectedOption: 0,
                result: null,
                resultTimer: 0,
                score: 0,
                taskType: 'pattern' // 'pattern' | 'debug' | 'sort'
            }
        };
        // Pattern sequences for the computer minigame
        const patternSets = [
            { seq: ['üî¥','üîµ','üî¥','üîµ','üî¥'], answer: 'üîµ', distractors: ['üî¥','üü¢','üü°'] },
            { seq: ['‚≠ê','üåô','‚≠ê','üåô','‚≠ê'], answer: 'üåô', distractors: ['‚≠ê','‚òÄÔ∏è','üí´'] },
            { seq: ['üçé','üçé','üçä','üçé','üçé'], answer: 'üçä', distractors: ['üçé','üçã','üçá'] },
            { seq: ['üü¢','üü°','üî¥','üü¢','üü°'], answer: 'üî¥', distractors: ['üü¢','üü°','üîµ'] },
            { seq: ['‚ù§Ô∏è','üíô','üíö','‚ù§Ô∏è','üíô'], answer: 'üíö', distractors: ['‚ù§Ô∏è','üíô','üíõ'] },
            { seq: ['üê±','üê∂','üê±','üê∂','üê±'], answer: 'üê∂', distractors: ['üê±','üê∞','üêª'] },
            { seq: ['üå∏','üå∏','üå∫','üå∏','üå∏'], answer: 'üå∫', distractors: ['üå∏','üåª','üå∑'] },
            { seq: ['1Ô∏è‚É£','2Ô∏è‚É£','3Ô∏è‚É£','4Ô∏è‚É£','5Ô∏è‚É£'], answer: '6Ô∏è‚É£', distractors: ['7Ô∏è‚É£','4Ô∏è‚É£','1Ô∏è‚É£'] },
            { seq: ['üî∫','üîª','üî∫','üîª','üî∫'], answer: 'üîª', distractors: ['üî∫','‚¨õ','üî∑'] },
            { seq: ['‚òÄÔ∏è','üåßÔ∏è','‚òÄÔ∏è','üåßÔ∏è','‚òÄÔ∏è'], answer: 'üåßÔ∏è', distractors: ['‚òÄÔ∏è','‚ùÑÔ∏è','‚õàÔ∏è'] },
            { seq: ['üÖ∞Ô∏è','üÖ±Ô∏è','üÖ∞Ô∏è','üÖ±Ô∏è','üÖ∞Ô∏è'], answer: 'üÖ±Ô∏è', distractors: ['üÖ∞Ô∏è','¬©Ô∏è','‚ìÇÔ∏è'] },
            { seq: ['üöó','üöô','üöï','üöó','üöô'], answer: 'üöï', distractors: ['üöó','üöô','üèéÔ∏è'] },
        ];
        // Debug tasks - find the wrong equation
        const debugTasks = [
            { code: '2 + 2 = 4\n3 + 1 = 5\n5 - 2 = 3', bugLine: 1, fixOptions: ['= 4', '= 5', '= 3', '= 6'], answer: '= 4' },
            { code: '10 - 5 = 5\n7 + 2 = 8\n4 + 4 = 8', bugLine: 1, fixOptions: ['= 9', '= 8', '= 7', '= 10'], answer: '= 9' },
            { code: '6 + 3 = 9\n8 - 4 = 4\n5 + 5 = 11', bugLine: 2, fixOptions: ['= 10', '= 11', '= 9', '= 12'], answer: '= 10' },
            { code: '9 - 3 = 7\n4 + 1 = 5\n6 + 6 = 12', bugLine: 0, fixOptions: ['= 6', '= 7', '= 5', '= 8'], answer: '= 6' },
            { code: '3 √ó 2 = 6\n4 √ó 3 = 11\n2 √ó 5 = 10', bugLine: 1, fixOptions: ['= 12', '= 11', '= 10', '= 14'], answer: '= 12' },
            { code: '15 - 8 = 7\n12 + 3 = 16\n9 - 4 = 5', bugLine: 1, fixOptions: ['= 15', '= 16', '= 14', '= 13'], answer: '= 15' },
        ];

        // Shop System
        let shops = [];
        let shopState = {
            active: false,
            playerX: 200,
            playerY: 0,
            selectedItem: 0,
            scrollY: 0,
            category: 0, // 0=horns, 1=outfits, 2=accessories, 3=colors
            message: null,
            messageTimer: 0,
            _totalItems: 0,
            _contentH: 0
        };
        const shopCategories = ['horns', 'outfits', 'accessories', 'colors'];
        const shopCategoryNames = ['Rogi', 'Ubranka', 'Akcesoria', 'Kolory'];
        const ITEM_PRICES = { horns: 1, outfits: 3, accessories: 1, colors: 2 };

        // Hairdresser (Fryzjer) System
        let hairdressers = [];
        let hairdresserState = {
            active: false,
            playerX: 200,
            playerY: 0,
            selectedItem: 0,
            scrollY: 0,
            message: null,
            messageTimer: 0,
            _totalItems: 0,
            _contentH: 0
        };
        const HAIR_PRICES = { hairstyles: 2, hairColors: 2, hairClips: 1 };

        // Hycel System
        let hycels = [];

        // Battle System
        let currentBattle = null;
        let battleState = {
            playerHealth: 5,
            enemyHealth: 3,
            playerAttackCooldown: 0,
            enemyAttackCooldown: 60,
            message: '',
            victory: false,
            defeat: false,
            attackAnimation: 0,
            hitAnimation: 0,
            victoryAnimationFrame: 0,
            defeatAnimationFrame: 0
        };

        // System d≈∫wiƒôk√≥w - prawdziwe odg≈Çosy zwierzƒÖt
        // ≈πr√≥d≈Ço: freeanimalsounds.org (darmowe pliki mp3)
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const animalSoundCache = {};

        const animalSoundFiles = {
            cat:       { file: 'sounds/cat.mp3',       volume: 0.5 },
            dog:       { file: 'sounds/dog.mp3',       volume: 0.4 },
            rabbit:    { file: 'sounds/bird.mp3',      volume: 0.25 },
            bear:      { file: 'sounds/bear.mp3',      volume: 0.4 },
            sheep:     { file: 'sounds/sheep.mp3',     volume: 0.45 },
            dolphin:   { file: 'sounds/dolphin.mp3',   volume: 0.35 },
            fox:       { file: 'sounds/fox.mp3',       volume: 0.4 },
            panda:     { file: 'sounds/panda.mp3',     volume: 0.3 },
            unicorn:   { file: 'sounds/horse.mp3',     volume: 0.4 },
            frog:      { file: 'sounds/frog.mp3',      volume: 0.35 },
            butterfly: { file: 'sounds/butterfly.mp3', volume: 0.15 }
        };

        function preloadSounds() {
            Object.entries(animalSoundFiles).forEach(([key, info]) => {
                const audio = new Audio();
                audio.preload = 'auto';
                audio.volume = info.volume;
                audio.src = info.file;
                audio.load();
                animalSoundCache[key] = audio;
            });
        }
        preloadSounds();

        function playAnimalSound(animalType) {
            try {
                if (audioContext.state === 'suspended') audioContext.resume();
                const cached = animalSoundCache[animalType];
                if (cached) {
                    // Clone to allow overlapping plays
                    const sound = cached.cloneNode();
                    sound.volume = cached.volume;
                    sound.play().catch(() => {});
                }
            } catch (e) { /* ignore sound errors */ }
        }

        function playFartSound() {
            try {
                if (audioContext.state === 'suspended') audioContext.resume();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const now = audioContext.currentTime;

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(120, now);
                osc.frequency.linearRampToValueAtTime(60, now + 0.15);
                osc.frequency.linearRampToValueAtTime(40, now + 0.4);

                gain.gain.setValueAtTime(0.3, now);
                gain.gain.linearRampToValueAtTime(0.15, now + 0.2);
                gain.gain.linearRampToValueAtTime(0, now + 0.5);

                // Add some noise for realism
                const noise = audioContext.createOscillator();
                const noiseGain = audioContext.createGain();
                noise.type = 'triangle';
                noise.frequency.setValueAtTime(80, now);
                noise.frequency.linearRampToValueAtTime(30, now + 0.3);
                noiseGain.gain.setValueAtTime(0.15, now);
                noiseGain.gain.linearRampToValueAtTime(0, now + 0.4);
                noise.connect(noiseGain);
                noiseGain.connect(audioContext.destination);
                noise.start(now);
                noise.stop(now + 0.5);

                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.start(now);
                osc.stop(now + 0.5);
            } catch (e) { /* ignore */ }
        }

        function doFart() {
            if (fartCooldown > 0) return;
            const fartAllowedStates = ['world', 'interior', 'shop', 'hairdresser', 'hospital', 'playground'];
            if (!fartAllowedStates.includes(gameState)) return;
            fartCooldown = 40; // ~0.67s cooldown

            playFartSound();

            // Determine player position based on state
            let fartX, fartY, facingRight;
            if (gameState === 'world') {
                fartX = player.x;
                fartY = player.y;
                facingRight = player.facingRight;
            } else if (gameState === 'shop') {
                fartX = shopState.playerX;
                fartY = shopState.playerY;
                facingRight = player.facingRight;
            } else if (gameState === 'hairdresser') {
                fartX = hairdresserState.playerX;
                fartY = hairdresserState.playerY;
                facingRight = player.facingRight;
            } else if (gameState === 'hospital') {
                fartX = hospitalState.playerX;
                fartY = hospitalState.playerY;
                facingRight = player.facingRight;
            } else if (gameState === 'playground') {
                fartX = playgroundState.playerX;
                fartY = playgroundState.playerY;
                facingRight = player.facingRight;
            } else {
                // Interior
                fartX = interiorPlayer.x;
                fartY = interiorPlayer.y;
                facingRight = player.facingRight;
            }

            // Spawn fart cloud behind player (behind the tail)
            const tailOffsetX = facingRight ? -25 : 25;
            const isScreenCoords = gameState !== 'world';
            for (let i = 0; i < 5; i++) {
                fartClouds.push({
                    x: fartX + tailOffsetX + (Math.random() - 0.5) * 15,
                    y: fartY + 10 + (Math.random() - 0.5) * 10,
                    size: 8 + Math.random() * 12,
                    alpha: 0.7 + Math.random() * 0.3,
                    vx: (facingRight ? -1 : 1) * (0.3 + Math.random() * 0.5),
                    vy: -(0.5 + Math.random() * 1.0),
                    life: 90 + Math.random() * 40, // ~1.5-2s
                    maxLife: 0,
                    screenCoords: isScreenCoords // flag: don't subtract worldOffset
                });
                fartClouds[fartClouds.length - 1].maxLife = fartClouds[fartClouds.length - 1].life;
            }

            // Make nearby unfound friends panic and flee (only in world)
            if (gameState === 'world') {
                friendsToFind.forEach(friend => {
                    if (friend.found) return;
                    const dist = Math.abs(player.x - friend.x);
                    if (dist < 500) {
                        // Flee away from player
                        const fleeDir = friend.x > player.x ? 1 : -1;
                        friend.panicFlee = {
                            dir: fleeDir,
                            speed: 5 + Math.random() * 3,
                            timer: 120 + Math.random() * 60, // 2-3s of fleeing
                            originalX: friend.x
                        };
                    }
                });

                // Also scare passing animals
                passingAnimals.forEach(animal => {
                    const animalScreenX = animal.x;
                    const playerScreenX = player.x - worldOffset;
                    if (Math.abs(playerScreenX - animalScreenX) < 250) {
                        animal.scared = true;
                        animal.scaredTimer = 120;
                        animal.scaredDir = animalScreenX > playerScreenX ? 1 : -1;
                    }
                });

                // Scare following friends (they react in panic but stay following)
                followingFriends.forEach(friend => {
                    friend.fartPanic = {
                        timer: 90,
                        jumpOffset: 0,
                        jumpVel: -6
                    };
                });
            }

            // Scare interior friends (in house and other buildings)
            if (gameState === 'interior') {
                interiorFriends.forEach(friend => {
                    if (friend.activity === 'p2_controlled') return;
                    const dist = Math.abs(interiorPlayer.x - friend.x);
                    if (dist < 400) {
                        const fleeDir = friend.x > interiorPlayer.x ? 1 : -1;
                        friend.fartPanic = {
                            dir: fleeDir,
                            speed: 4 + Math.random() * 3,
                            timer: 90 + Math.random() * 40,
                            originalX: friend.x,
                            originalActivity: friend.activity
                        };
                        friend.activity = 'fart_fleeing';
                    }
                });
            }
        }

        function updateFartClouds() {
            if (fartCooldown > 0) fartCooldown--;

            fartClouds = fartClouds.filter(cloud => cloud.life > 0);
            fartClouds.forEach(cloud => {
                cloud.x += cloud.vx;
                cloud.y += cloud.vy;
                cloud.vy *= 0.99; // slow down rise
                cloud.size += 0.15; // expand
                cloud.alpha = (cloud.life / cloud.maxLife) * 0.7;
                cloud.life--;
            });

            // Update friend panic fleeing (unfound friends in world)
            friendsToFind.forEach(friend => {
                if (!friend.panicFlee) return;
                const pf = friend.panicFlee;
                if (pf.timer > 0) {
                    friend.x += pf.dir * pf.speed;
                    pf.timer--;
                } else {
                    // Slowly return
                    const dx = pf.originalX - friend.x;
                    if (Math.abs(dx) > 2) {
                        friend.x += Math.sign(dx) * 1.5;
                    } else {
                        friend.panicFlee = null;
                    }
                }
            });

            // Update following friends panic (jump reaction)
            followingFriends.forEach(friend => {
                if (!friend.fartPanic) return;
                const fp = friend.fartPanic;
                fp.timer--;
                fp.jumpOffset += fp.jumpVel;
                fp.jumpVel += 0.5; // gravity
                if (fp.jumpOffset > 0) {
                    fp.jumpOffset = 0;
                    fp.jumpVel = -4 - Math.random() * 2; // bounce again
                }
                if (fp.timer <= 0) {
                    friend.fartPanic = null;
                }
            });

            // Update interior friends fart fleeing
            interiorFriends.forEach(friend => {
                if (friend.activity !== 'fart_fleeing' || !friend.fartPanic) return;
                const fp = friend.fartPanic;
                if (fp.timer > 0) {
                    friend.x += fp.dir * fp.speed;
                    friend.x = Math.max(30, Math.min(canvas.width - 30, friend.x));
                    fp.timer--;
                } else {
                    // Return to original position
                    const dx = fp.originalX - friend.x;
                    if (Math.abs(dx) > 2) {
                        friend.x += Math.sign(dx) * 2;
                    } else {
                        friend.x = fp.originalX;
                        friend.activity = fp.originalActivity;
                        friend.fartPanic = null;
                    }
                }
            });
        }

        function drawFartClouds() {
            fartClouds.forEach(cloud => {
                const screenX = cloud.screenCoords ? cloud.x : (cloud.x - worldOffset);
                if (screenX < -50 || screenX > canvas.width + 50) return;

                ctx.save();
                ctx.globalAlpha = cloud.alpha;

                // Green stinky cloud
                const grad = ctx.createRadialGradient(screenX, cloud.y, 0, screenX, cloud.y, cloud.size);
                grad.addColorStop(0, 'rgba(100, 180, 50, 0.6)');
                grad.addColorStop(0.5, 'rgba(120, 200, 60, 0.3)');
                grad.addColorStop(1, 'rgba(140, 220, 70, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(screenX, cloud.y, cloud.size, 0, Math.PI * 2);
                ctx.fill();

                // Stink lines
                if (cloud.life > 30) {
                    ctx.strokeStyle = 'rgba(100, 160, 40, ' + (cloud.alpha * 0.5) + ')';
                    ctx.lineWidth = 1;
                    for (let s = 0; s < 3; s++) {
                        const sx = screenX + (s - 1) * cloud.size * 0.4;
                        const waveOffset = (cloud.maxLife - cloud.life) * 0.1 + s;
                        ctx.beginPath();
                        ctx.moveTo(sx, cloud.y);
                        ctx.quadraticCurveTo(
                            sx + Math.sin(waveOffset) * 4,
                            cloud.y - cloud.size * 0.5,
                            sx + Math.sin(waveOffset + 1) * 3,
                            cloud.y - cloud.size
                        );
                        ctx.stroke();
                    }
                }

                ctx.restore();
            });

            // Draw panic indicators on fleeing friends
            friendsToFind.forEach(friend => {
                if (!friend.panicFlee || friend.found) return;
                if (friend.panicFlee.timer <= 0) return;
                const screenX = friend.x - worldOffset;
                if (screenX < -100 || screenX > canvas.width + 100) return;

                // Green stink cloud around friend
                ctx.save();
                ctx.globalAlpha = 0.3;
                const stinkGrad = ctx.createRadialGradient(screenX, friend.y, 0, screenX, friend.y, 40);
                stinkGrad.addColorStop(0, 'rgba(100, 180, 50, 0.4)');
                stinkGrad.addColorStop(1, 'rgba(100, 180, 50, 0)');
                ctx.fillStyle = stinkGrad;
                ctx.beginPath();
                ctx.arc(screenX, friend.y, 40, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Panic emoji - big and bouncing
                const bounce = Math.sin(Date.now() / 80) * 5;
                ctx.font = 'bold 28px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('üò±', screenX, friend.y - 40 + bounce);

                // Sweat drops
                ctx.fillStyle = 'rgba(100, 180, 230, 0.8)';
                const dropOff = (Date.now() / 100) % 20;
                ctx.beginPath();
                ctx.ellipse(screenX + 18, friend.y - 15 + dropOff, 3, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(screenX - 15, friend.y - 10 + dropOff * 0.7, 3, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Speed lines behind the friend (showing movement)
                const dir = friend.panicFlee.dir;
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.6)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 4; i++) {
                    const lx = screenX - dir * (20 + i * 12);
                    const ly = friend.y - 5 + i * 10;
                    ctx.beginPath();
                    ctx.moveTo(lx, ly);
                    ctx.lineTo(lx - dir * 20, ly);
                    ctx.stroke();
                }
            });
        }

        // Muzyka w tle
        let musicStarted = false;

        function startBackgroundMusic() {
            if (!musicStarted && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            if (!musicStarted) {
                musicStarted = true;
            }
        }

        function playBackgroundMelody() {
            // Prosta, radosna melodia w pƒôtli
            const melody = [
                {note: 523.25, duration: 0.3}, // C5
                {note: 587.33, duration: 0.3}, // D5
                {note: 659.25, duration: 0.3}, // E5
                {note: 698.46, duration: 0.3}, // F5
                {note: 783.99, duration: 0.6}, // G5
                {note: 659.25, duration: 0.3}, // E5
                {note: 698.46, duration: 0.6}, // F5
                {note: 523.25, duration: 0.6}, // C5
            ];

            let time = audioContext.currentTime;

            function playNote(frequency, duration, startTime) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.type = 'sine';
                osc.frequency.value = frequency;

                osc.connect(gain);
                gain.connect(audioContext.destination);

                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(0.04, startTime + 0.02);
                gain.gain.linearRampToValueAtTime(0.025, startTime + duration - 0.05);
                gain.gain.linearRampToValueAtTime(0, startTime + duration);

                osc.start(startTime);
                osc.stop(startTime + duration);
            }

            function scheduleMelody() {
                time = audioContext.currentTime + 0.1;
                melody.forEach(note => {
                    playNote(note.note, note.duration, time);
                    time += note.duration + 0.1;
                });

                // Powt√≥rz melodiƒô
                setTimeout(scheduleMelody, (time - audioContext.currentTime) * 1000);
            }

            scheduleMelody();
        }

        const candyColors = ['#FF69B4', '#FFB6D9', '#E0C3FC', '#FFF4E0', '#D4F1F9', '#FF1493', '#DDA0DD', '#F0E68C'];

        // Generowanie chunka
        function generateChunk(chunkX) {
            if (generatedChunks.has(chunkX)) return;
            generatedChunks.add(chunkX);

            const startX = chunkX * chunkSize;

            // P≈Çaski grunt (opcjonalnie z delikatnymi wzg√≥rzami)
            const groundY = canvas.height - 100;
            ground.push({
                x: startX,
                y: groundY,
                width: chunkSize,
                height: 100
            });

            // Cukierki na ziemi
            const numCandies = 15 + Math.floor(Math.random() * 10);
            for (let i = 0; i < numCandies; i++) {
                candies.push({
                    x: startX + Math.random() * chunkSize,
                    y: groundY - 20,
                    collected: false,
                    type: Math.floor(Math.random() * 5)
                });
            }

            // Przyjaciel (co 2-3 chunki)
            if (chunkX > 0 && chunkX % 2 === 0) {
                const friendType = friendTypes[friendsToFind.length % friendTypes.length];
                const friendX = startX + chunkSize / 2;
                const hasHycel = (friendsToFind.length % 2 === 1); // Indices 1, 3, 5, 7, 9

                friendsToFind.push({
                    x: friendX,
                    y: groundY - 60,
                    type: friendType,
                    found: false,
                    bounceOffset: Math.random() * Math.PI * 2,
                    hasHycel: hasHycel
                });

                // Spawn hycel if needed
                if (hasHycel) {
                    hycels.push({
                        x: friendX - 100,
                        y: groundY - 80,
                        width: 70,
                        height: 80,
                        health: 3,
                        defeated: false,
                        friendIndex: friendsToFind.length - 1,
                        bounceOffset: 0,
                        angry: false,
                        friendType: friendType // Store which animal costume
                    });
                }

                // Budynki (co 2-3 zwierzƒÖtko) ‚Äî cyklicznie: domek, przedszkole, praca
                if (friendsToFind.length % 3 === 0 || friendsToFind.length % 2 === 0) {
                    const buildX = friendX + 150;
                    const buildingCycle = houses.length + kindergartens.length + offices.length + shops.length + hairdressers.length + hospitals.length + playgrounds.length;
                    const buildType = buildingCycle % 7;
                    if (buildType === 0) {
                        houses.push({
                            x: buildX,
                            y: groundY,
                            width: 250,
                            height: 200
                        });
                    } else if (buildType === 1) {
                        kindergartens.push({
                            x: buildX,
                            y: groundY,
                            width: 300,
                            height: 220
                        });
                    } else if (buildType === 2) {
                        offices.push({
                            x: buildX,
                            y: groundY,
                            width: 280,
                            height: 230
                        });
                    } else if (buildType === 3) {
                        shops.push({
                            x: buildX,
                            y: groundY,
                            width: 270,
                            height: 210
                        });
                    } else if (buildType === 4) {
                        hairdressers.push({
                            x: buildX,
                            y: groundY,
                            width: 280,
                            height: 220
                        });
                    } else if (buildType === 5) {
                        hospitals.push({
                            x: buildX,
                            y: groundY,
                            width: 280,
                            height: 230
                        });
                    } else {
                        playgrounds.push({
                            x: buildX,
                            y: groundY,
                            width: 280,
                            height: 200
                        });
                    }
                }
            }

            // Kwiaty
            for (let i = 0; i < 20; i++) {
                flowers.push({
                    x: startX + Math.random() * chunkSize,
                    y: groundY - 10,
                    color: candyColors[Math.floor(Math.random() * candyColors.length)],
                    size: 15 + Math.random() * 10,
                    swayOffset: Math.random() * Math.PI * 2
                });
            }

            // Drzewa
            for (let i = 0; i < 5; i++) {
                trees.push({
                    x: startX + Math.random() * chunkSize,
                    y: groundY,
                    height: 80 + Math.random() * 60,
                    width: 40 + Math.random() * 30
                });
            }

            // Dekoracje (motyle, ptaszki)
            for (let i = 0; i < 8; i++) {
                decorations.push({
                    x: startX + Math.random() * chunkSize,
                    y: 100 + Math.random() * 200,
                    type: Math.random() > 0.5 ? 'butterfly' : 'bird',
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.5 + Math.random()
                });
            }

            // Zwierzƒôta mijajƒÖce (pszczo≈Çy, ≈ºuki, inne)
            const groundYForAnimals = canvas.height - 100;
            const animalTypes = [
                { emoji: 'üêù', speed: 1.5, flying: true, height: 150 }, // Pszczo≈Ça
                { emoji: 'üêû', speed: 0.8, flying: true, height: 200 }, // Biedronka
                { emoji: 'ü¶ó', speed: 0.5, flying: false, height: 30 }, // ≈öwierszcz
                { emoji: 'üêõ', speed: 0.3, flying: false, height: 20 }, // GƒÖsienica
                { emoji: 'ü¶ü', speed: 2, flying: true, height: 180 }, // Komarek
                { emoji: 'üïäÔ∏è', speed: 1.2, flying: true, height: 120 }, // Go≈ÇƒÖbek
                { emoji: 'ü¶Ö', speed: 1.8, flying: true, height: 80 }, // Orze≈Ç
                { emoji: 'üêøÔ∏è', speed: 1, flying: false, height: 35 }, // Wiewi√≥rka
                { emoji: 'üêÅ', speed: 0.7, flying: false, height: 25 }, // Myszka
                { emoji: 'üê¢', speed: 0.2, flying: false, height: 25 }, // ≈ª√≥≈Çw
            ];

            for (let i = 0; i < 10; i++) {
                const animalType = animalTypes[Math.floor(Math.random() * animalTypes.length)];
                passingAnimals.push({
                    x: startX + Math.random() * chunkSize,
                    y: animalType.flying ? animalType.height : groundYForAnimals - animalType.height,
                    emoji: animalType.emoji,
                    speed: animalType.speed,
                    direction: Math.random() > 0.5 ? 1 : -1,
                    flying: animalType.flying,
                    phase: Math.random() * Math.PI * 2,
                    minX: startX - 200,
                    maxX: startX + chunkSize + 200
                });
            }

            // Przedmioty kupuje siƒô teraz w sklepie - nie pojawiajƒÖ siƒô w ≈õwiecie
        }

        function startGame() {
            document.getElementById('start-screen').classList.remove('active');
            gameRunning = true;
            score = 0;
            coins = 0;
            document.getElementById('coins').textContent = '0';
            worldOffset = 0;
            gameTimeStart = Date.now();
            raindrops = [];
            followingFriends = [];
            playerHistory = [];
            ground = [];
            candies = [];
            friendsToFind = [];
            decorations = [];
            flowers = [];
            trees = [];
            passingAnimals = [];
            dialogBubbles = [];
            fartClouds = [];
            fartCooldown = 0;
            itemsToCollect = [];
            kindergartens = [];
            offices = [];
            shops = [];
            hairdressers = [];
            generatedChunks.clear();

            player.x = 300;
            player.y = canvas.height - 150;
            player.velY = 0;

            for (let i = -1; i <= 3; i++) {
                generateChunk(i);
            }

            updateFriendsList();
            updateWardrobe();
            gameLoop();
        }

        function closeFriendMessage() {
            document.getElementById('victory-screen').classList.remove('active');
            if (!gameRunning) {
                gameRunning = true;
                gameLoop();
            }
        }

        // Rysowanie chmurki dialogowej
        function drawDialogBubble(x, y, text, fromLeft = true) {
            const padding = 15;
            const lineHeight = 20;
            const maxTextWidth = 260;

            // U≈ºyj tej samej czcionki do mierzenia i rysowania
            ctx.font = 'bold 16px Comic Sans MS';
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';

            words.forEach(word => {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxTextWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            });
            if (currentLine) lines.push(currentLine);

            // Oblicz faktycznƒÖ szeroko≈õƒá na podstawie najd≈Çu≈ºszej linii
            let actualTextWidth = 0;
            lines.forEach(line => {
                const w = ctx.measureText(line).width;
                if (w > actualTextWidth) actualTextWidth = w;
            });

            const bubbleWidth = actualTextWidth + padding * 2;
            const bubbleHeight = lines.length * lineHeight + padding * 2;

            // Pozycjonuj chmurkƒô tak, ≈ºeby ogon wskazywa≈Ç na m√≥wiƒÖcego
            let bubbleX;
            if (fromLeft) {
                bubbleX = x + 30;
            } else {
                bubbleX = x - bubbleWidth - 30;
            }
            // Nie pozw√≥l chmurce wyj≈õƒá poza ekran
            bubbleX = Math.max(5, Math.min(canvas.width - bubbleWidth - 5, bubbleX));
            const bubbleY = y - bubbleHeight - 40;

            // Chmurka (bia≈Çe t≈Ço)
            ctx.fillStyle = '#FFF';
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(bubbleX, bubbleY, bubbleWidth, bubbleHeight, 15);
            ctx.fill();
            ctx.stroke();

            // Ogon chmurki (tr√≥jkƒÖcik)
            ctx.fillStyle = '#FFF';
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 3;
            const tailX = Math.max(bubbleX + 15, Math.min(bubbleX + bubbleWidth - 15, x + 30));
            ctx.beginPath();
            ctx.moveTo(tailX - 10, bubbleY + bubbleHeight);
            ctx.lineTo(x + (fromLeft ? 20 : -20), y - 20);
            ctx.lineTo(tailX + 10, bubbleY + bubbleHeight);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Zakryj liniƒô obramowania pod ogonem
            ctx.fillStyle = '#FFF';
            ctx.fillRect(tailX - 9, bubbleY + bubbleHeight - 2, 18, 4);

            // Tekst (wycentrowany w chmurce)
            ctx.fillStyle = '#FF1493';
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.textAlign = 'center';
            const centerX = bubbleX + bubbleWidth / 2;
            lines.forEach((line, i) => {
                ctx.fillText(line, centerX, bubbleY + padding + (i + 1) * lineHeight);
            });
            ctx.textAlign = 'left'; // przywr√≥ƒá domy≈õlne
        }

        // Aktualizuj i rysuj chmurki dialogowe
        function updateAndDrawDialogBubbles() {
            const currentTime = Date.now();
            dialogBubbles = dialogBubbles.filter(bubble => currentTime - bubble.startTime < bubble.duration);

            dialogBubbles.forEach(bubble => {
                // Follow the speaker if followTarget is set
                const worldX = bubble.followTarget ? bubble.followTarget.x : bubble.x;
                const worldY = bubble.followTarget ? bubble.followTarget.y : bubble.y;
                const screenX = worldX - worldOffset;
                if (screenX > -300 && screenX < canvas.width + 300) {
                    drawDialogBubble(screenX, worldY, bubble.text, bubble.fromLeft);
                }
            });
        }

        // Mini podglƒÖd przedmiotu (rysowany zamiast emoji)
        function drawItemPreview(cx, cy, category, itemId, size) {
            ctx.save();
            const s = size / 30; // scale factor (30 = base size)

            if (category === 'hairstyles') {
                const col = '#8B4513';
                ctx.fillStyle = col;
                if (itemId === 'ponytail') {
                    ctx.beginPath();
                    ctx.arc(cx, cy - 2 * s, 10 * s, Math.PI, 0);
                    ctx.fill();
                    ctx.strokeStyle = col; ctx.lineWidth = 3 * s;
                    ctx.beginPath();
                    ctx.moveTo(cx - 8 * s, cy); ctx.quadraticCurveTo(cx - 12 * s, cy + 8 * s, cx - 10 * s, cy + 14 * s);
                    ctx.stroke();
                    ctx.fillStyle = '#FF69B4';
                    ctx.beginPath(); ctx.arc(cx - 8 * s, cy, 3 * s, 0, Math.PI * 2); ctx.fill();
                } else if (itemId === 'curly') {
                    for (let i = 0; i < 6; i++) {
                        const a = (i / 6) * Math.PI + Math.PI;
                        ctx.beginPath();
                        ctx.arc(cx + Math.cos(a) * 10 * s, cy - 2 * s + Math.sin(a) * 6 * s, 5 * s, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (itemId === 'spiky') {
                    for (let i = 0; i < 5; i++) {
                        ctx.beginPath();
                        ctx.moveTo(cx - 10 * s + i * 5 * s, cy + 4 * s);
                        ctx.lineTo(cx - 8 * s + i * 5 * s, cy - 10 * s - (i % 2) * 4 * s);
                        ctx.lineTo(cx - 6 * s + i * 5 * s, cy + 4 * s);
                        ctx.closePath(); ctx.fill();
                    }
                } else if (itemId === 'long') {
                    ctx.beginPath(); ctx.arc(cx, cy - 4 * s, 10 * s, Math.PI, 0); ctx.fill();
                    ctx.fillRect(cx - 10 * s, cy - 4 * s, 4 * s, 16 * s);
                    ctx.fillRect(cx + 6 * s, cy - 4 * s, 4 * s, 16 * s);
                } else if (itemId === 'buns') {
                    ctx.beginPath(); ctx.arc(cx, cy, 8 * s, Math.PI, 0); ctx.fill();
                    ctx.beginPath(); ctx.arc(cx - 8 * s, cy - 6 * s, 5 * s, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(cx + 8 * s, cy - 6 * s, 5 * s, 0, Math.PI * 2); ctx.fill();
                } else if (itemId === 'bob') {
                    ctx.beginPath(); ctx.arc(cx, cy - 2 * s, 11 * s, Math.PI, 0); ctx.fill();
                    ctx.fillRect(cx - 11 * s, cy - 2 * s, 4 * s, 10 * s);
                    ctx.fillRect(cx + 7 * s, cy - 2 * s, 4 * s, 10 * s);
                } else if (itemId === 'mohawk') {
                    for (let m = 0; m < 5; m++) {
                        const mh = (8 + (2 - Math.abs(m - 2)) * 4) * s;
                        ctx.beginPath();
                        ctx.ellipse(cx - 6 * s + m * 3 * s, cy - mh / 2, 3 * s, mh / 2, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (itemId === 'braids') {
                    ctx.beginPath(); ctx.arc(cx, cy - 2 * s, 9 * s, Math.PI, 0); ctx.fill();
                    ctx.strokeStyle = col; ctx.lineWidth = 2.5 * s;
                    for (let side = 0; side < 2; side++) {
                        const bx = side === 0 ? cx - 9 * s : cx + 9 * s;
                        ctx.beginPath(); ctx.moveTo(bx, cy);
                        for (let b = 0; b < 4; b++) ctx.lineTo(bx + (b % 2 === 0 ? 3 : -3) * s, cy + 4 * s + b * 4 * s);
                        ctx.stroke();
                    }
                } else if (itemId === 'afro') {
                    ctx.beginPath(); ctx.arc(cx, cy, 13 * s, 0, Math.PI * 2); ctx.fill();
                } else if (itemId === 'pigtails') {
                    ctx.beginPath(); ctx.arc(cx, cy - 2 * s, 8 * s, Math.PI, 0); ctx.fill();
                    for (let side = 0; side < 2; side++) {
                        const px = side === 0 ? cx - 10 * s : cx + 10 * s;
                        ctx.beginPath(); ctx.arc(px, cy + 2 * s, 4 * s, 0, Math.PI * 2); ctx.fill();
                        ctx.fillRect(px - 2 * s, cy + 2 * s, 4 * s, 10 * s);
                        ctx.beginPath(); ctx.arc(px, cy + 12 * s, 3 * s, 0, Math.PI * 2); ctx.fill();
                    }
                }
            } else if (category === 'hairColors') {
                const hcDef = itemDefinitions.hairColors.find(c => c.id === itemId);
                if (hcDef) {
                    if (hcDef.color === 'rainbow') {
                        const rg = ctx.createLinearGradient(cx - 10 * s, cy, cx + 10 * s, cy);
                        rg.addColorStop(0, '#FF0000'); rg.addColorStop(0.33, '#FFFF00');
                        rg.addColorStop(0.66, '#00FF00'); rg.addColorStop(1, '#9400D3');
                        ctx.fillStyle = rg;
                    } else {
                        ctx.fillStyle = hcDef.color;
                    }
                    // Poka≈º kosmyk w≈Ços√≥w w danym kolorze
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - 12 * s);
                    ctx.quadraticCurveTo(cx + 10 * s, cy - 5 * s, cx + 6 * s, cy + 8 * s);
                    ctx.quadraticCurveTo(cx + 2 * s, cy + 12 * s, cx - 2 * s, cy + 8 * s);
                    ctx.quadraticCurveTo(cx - 6 * s, cy, cx, cy - 12 * s);
                    ctx.fill();
                    // Po≈Çysk
                    ctx.fillStyle = 'rgba(255,255,255,0.35)';
                    ctx.beginPath(); ctx.ellipse(cx - 1 * s, cy - 4 * s, 2 * s, 6 * s, -0.3, 0, Math.PI * 2); ctx.fill();
                }
            } else if (category === 'hairClips') {
                // Spinka jako ma≈Ça ozdoba
                const clipCol = itemId === 'clip_star' ? '#FFD700' : itemId === 'clip_heart' ? '#FF69B4' : itemId === 'clip_butterfly' ? '#87CEEB' : itemId === 'clip_flower' ? '#FF6347' : '#C0C0FF';
                ctx.fillStyle = clipCol;
                if (itemId === 'clip_star') {
                    for (let j = 0; j < 5; j++) {
                        const a = (j * 2 * Math.PI / 5) - Math.PI / 2;
                        const r = j % 2 === 0 ? 10 * s : 5 * s;
                        const px = cx + Math.cos(a) * r;
                        const py = cy + Math.sin(a) * r;
                        if (j === 0) ctx.beginPath(), ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath(); ctx.fill();
                } else if (itemId === 'clip_heart') {
                    ctx.beginPath();
                    ctx.moveTo(cx, cy + 8 * s);
                    ctx.bezierCurveTo(cx - 12 * s, cy - 2 * s, cx - 12 * s, cy - 10 * s, cx, cy - 4 * s);
                    ctx.bezierCurveTo(cx + 12 * s, cy - 10 * s, cx + 12 * s, cy - 2 * s, cx, cy + 8 * s);
                    ctx.fill();
                } else if (itemId === 'clip_butterfly') {
                    ctx.beginPath(); ctx.ellipse(cx - 6 * s, cy - 3 * s, 6 * s, 8 * s, -0.3, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(cx + 6 * s, cy - 3 * s, 6 * s, 8 * s, 0.3, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#333'; ctx.fillRect(cx - 0.5 * s, cy - 8 * s, 1 * s, 16 * s);
                } else if (itemId === 'clip_flower') {
                    for (let p = 0; p < 5; p++) {
                        const a = (p / 5) * Math.PI * 2;
                        ctx.beginPath(); ctx.arc(cx + Math.cos(a) * 6 * s, cy + Math.sin(a) * 6 * s, 4 * s, 0, Math.PI * 2); ctx.fill();
                    }
                    ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(cx, cy, 3 * s, 0, Math.PI * 2); ctx.fill();
                } else if (itemId === 'clip_moon') {
                    ctx.beginPath(); ctx.arc(cx, cy, 9 * s, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#E8D5F5';
                    ctx.beginPath(); ctx.arc(cx + 4 * s, cy - 2 * s, 7 * s, 0, Math.PI * 2); ctx.fill();
                }
                // Spinka bazowa
                ctx.fillStyle = '#888';
                ctx.fillRect(cx - 1 * s, cy + 8 * s, 2 * s, 6 * s);
            } else if (category === 'outfits') {
                // Mini wersja ubranki
                if (itemId === 'cape') {
                    ctx.fillStyle = '#DC143C';
                    ctx.beginPath(); ctx.moveTo(cx, cy - 8 * s); ctx.lineTo(cx - 12 * s, cy + 10 * s);
                    ctx.lineTo(cx + 12 * s, cy + 10 * s); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = '#FFD700'; ctx.font = (8 * s) + 'px Arial'; ctx.textAlign = 'center';
                    ctx.fillText('‚≠ê', cx, cy + 4 * s);
                } else if (itemId === 'dress') {
                    ctx.fillStyle = '#FF1493';
                    ctx.fillRect(cx - 6 * s, cy - 8 * s, 12 * s, 8 * s);
                    ctx.beginPath(); ctx.moveTo(cx - 6 * s, cy); ctx.lineTo(cx - 12 * s, cy + 12 * s);
                    ctx.lineTo(cx + 12 * s, cy + 12 * s); ctx.lineTo(cx + 6 * s, cy); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = '#FFD700'; ctx.fillRect(cx - 6 * s, cy - 1 * s, 12 * s, 2 * s);
                } else if (itemId === 'scarf') {
                    ctx.strokeStyle = '#FF1493'; ctx.lineWidth = 6 * s; ctx.lineCap = 'round';
                    ctx.beginPath(); ctx.moveTo(cx - 10 * s, cy); ctx.lineTo(cx + 10 * s, cy + 2 * s); ctx.stroke();
                    ctx.strokeStyle = '#FFF'; ctx.lineWidth = 2 * s;
                    for (let i = 0; i < 3; i++) { ctx.beginPath(); ctx.moveTo(cx - 5 * s + i * 6 * s, cy - 2 * s); ctx.lineTo(cx - 3 * s + i * 6 * s, cy + 2 * s); ctx.stroke(); }
                } else if (itemId === 'shirt') {
                    ctx.fillStyle = '#1E90FF'; ctx.fillRect(cx - 8 * s, cy - 6 * s, 16 * s, 14 * s);
                    ctx.fillStyle = '#FFF'; ctx.beginPath();
                    ctx.moveTo(cx - 2 * s, cy - 6 * s); ctx.lineTo(cx, cy - 3 * s); ctx.lineTo(cx + 2 * s, cy - 6 * s); ctx.fill();
                } else if (itemId === 'sweater') {
                    ctx.fillStyle = '#9370DB'; ctx.fillRect(cx - 8 * s, cy - 6 * s, 16 * s, 14 * s);
                    ctx.fillStyle = '#E6E6FA'; ctx.fillRect(cx - 8 * s, cy - 2 * s, 16 * s, 2 * s);
                    ctx.fillRect(cx - 8 * s, cy + 4 * s, 16 * s, 2 * s);
                } else if (itemId === 'tutu') {
                    ctx.fillStyle = '#FFB6C1'; ctx.fillRect(cx - 6 * s, cy - 6 * s, 12 * s, 5 * s);
                    for (let l = 0; l < 3; l++) {
                        ctx.fillStyle = l % 2 === 0 ? '#FFB6C1' : '#FFC0CB';
                        ctx.fillRect(cx - 10 * s - l * 2 * s, cy - 1 * s + l * 4 * s, 20 * s + l * 4 * s, 3 * s);
                    }
                } else if (itemId === 'pajamas') {
                    ctx.fillStyle = '#6495ED'; ctx.fillRect(cx - 8 * s, cy - 6 * s, 16 * s, 14 * s);
                    ctx.fillStyle = '#FFD700'; ctx.font = (5 * s) + 'px Arial'; ctx.textAlign = 'center';
                    ctx.fillText('‚≠ê', cx - 3 * s, cy); ctx.fillText('‚≠ê', cx + 4 * s, cy + 5 * s);
                } else if (itemId === 'raincoat') {
                    ctx.fillStyle = '#FFD700'; ctx.fillRect(cx - 8 * s, cy - 6 * s, 16 * s, 16 * s);
                    ctx.fillStyle = '#FFC107'; ctx.beginPath(); ctx.arc(cx, cy - 8 * s, 6 * s, Math.PI, 0); ctx.fill();
                    ctx.strokeStyle = '#B8860B'; ctx.lineWidth = 1 * s;
                    ctx.beginPath(); ctx.moveTo(cx, cy - 4 * s); ctx.lineTo(cx, cy + 8 * s); ctx.stroke();
                } else if (itemId === 'armor') {
                    ctx.fillStyle = '#C0C0C0'; ctx.fillRect(cx - 8 * s, cy - 6 * s, 16 * s, 14 * s);
                    ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 2 * s;
                    ctx.beginPath(); ctx.moveTo(cx, cy - 4 * s); ctx.lineTo(cx, cy + 4 * s);
                    ctx.moveTo(cx - 4 * s, cy); ctx.lineTo(cx + 4 * s, cy); ctx.stroke();
                } else if (itemId === 'kimono') {
                    ctx.fillStyle = '#DC143C'; ctx.fillRect(cx - 8 * s, cy - 6 * s, 16 * s, 16 * s);
                    ctx.fillStyle = '#FFD700'; ctx.fillRect(cx - 8 * s, cy + 2 * s, 16 * s, 4 * s);
                    ctx.strokeStyle = '#FFF'; ctx.lineWidth = 1 * s;
                    ctx.beginPath(); ctx.moveTo(cx - 4 * s, cy - 6 * s); ctx.lineTo(cx, cy); ctx.lineTo(cx + 4 * s, cy - 6 * s); ctx.stroke();
                } else if (itemId === 'tuxedo') {
                    ctx.fillStyle = '#2C2C2C'; ctx.fillRect(cx - 8 * s, cy - 6 * s, 16 * s, 14 * s);
                    ctx.fillStyle = '#FFF'; ctx.fillRect(cx - 2 * s, cy - 6 * s, 4 * s, 12 * s);
                    ctx.fillStyle = '#FF1493';
                    ctx.beginPath(); ctx.moveTo(cx, cy - 5 * s); ctx.lineTo(cx - 3 * s, cy - 7 * s); ctx.lineTo(cx - 3 * s, cy - 3 * s); ctx.closePath(); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(cx, cy - 5 * s); ctx.lineTo(cx + 3 * s, cy - 7 * s); ctx.lineTo(cx + 3 * s, cy - 3 * s); ctx.closePath(); ctx.fill();
                } else if (itemId === 'overalls') {
                    ctx.fillStyle = '#4682B4';
                    ctx.fillRect(cx - 6 * s, cy - 2 * s, 12 * s, 6 * s);
                    ctx.fillRect(cx - 7 * s, cy + 4 * s, 5 * s, 8 * s);
                    ctx.fillRect(cx + 2 * s, cy + 4 * s, 5 * s, 8 * s);
                    ctx.strokeStyle = '#4682B4'; ctx.lineWidth = 2 * s;
                    ctx.beginPath(); ctx.moveTo(cx - 4 * s, cy - 2 * s); ctx.lineTo(cx - 2 * s, cy - 7 * s);
                    ctx.moveTo(cx + 4 * s, cy - 2 * s); ctx.lineTo(cx + 2 * s, cy - 7 * s); ctx.stroke();
                }
            } else if (category === 'accessories') {
                if (itemId === 'crown') {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.moveTo(cx - 10 * s, cy + 4 * s); ctx.lineTo(cx - 8 * s, cy - 6 * s);
                    ctx.lineTo(cx - 3 * s, cy); ctx.lineTo(cx, cy - 8 * s);
                    ctx.lineTo(cx + 3 * s, cy); ctx.lineTo(cx + 8 * s, cy - 6 * s);
                    ctx.lineTo(cx + 10 * s, cy + 4 * s); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = '#FF1493';
                    ctx.beginPath(); ctx.arc(cx, cy - 3 * s, 2 * s, 0, Math.PI * 2); ctx.fill();
                } else if (itemId === 'bow') {
                    ctx.fillStyle = '#FF1493';
                    ctx.beginPath(); ctx.arc(cx - 6 * s, cy, 6 * s, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(cx + 6 * s, cy, 6 * s, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath(); ctx.arc(cx, cy, 3 * s, 0, Math.PI * 2); ctx.fill();
                } else if (itemId === 'glasses') {
                    ctx.strokeStyle = '#000'; ctx.lineWidth = 2 * s;
                    ctx.beginPath(); ctx.arc(cx - 6 * s, cy, 5 * s, 0, Math.PI * 2); ctx.stroke();
                    ctx.beginPath(); ctx.arc(cx + 6 * s, cy, 5 * s, 0, Math.PI * 2); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(cx - 1 * s, cy); ctx.lineTo(cx + 1 * s, cy); ctx.stroke();
                    ctx.fillStyle = 'rgba(135,206,250,0.3)';
                    ctx.beginPath(); ctx.arc(cx - 6 * s, cy, 4 * s, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(cx + 6 * s, cy, 4 * s, 0, Math.PI * 2); ctx.fill();
                } else if (itemId === 'hat') {
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(cx - 8 * s, cy - 6 * s, 16 * s, 8 * s);
                    ctx.beginPath(); ctx.ellipse(cx, cy + 2 * s, 13 * s, 4 * s, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#8B0000'; ctx.fillRect(cx - 8 * s, cy, 16 * s, 2 * s);
                } else if (itemId === 'flower') {
                    ctx.fillStyle = '#FF69B4';
                    for (let i = 0; i < 6; i++) {
                        const a = (i / 6) * Math.PI * 2;
                        ctx.beginPath(); ctx.arc(cx + Math.cos(a) * 6 * s, cy + Math.sin(a) * 6 * s, 4 * s, 0, Math.PI * 2); ctx.fill();
                    }
                    ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(cx, cy, 3 * s, 0, Math.PI * 2); ctx.fill();
                } else if (itemId === 'sunglasses') {
                    ctx.fillStyle = 'rgba(40,40,40,0.85)';
                    ctx.beginPath(); ctx.ellipse(cx - 6 * s, cy, 6 * s, 5 * s, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(cx + 6 * s, cy, 6 * s, 5 * s, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#FF1493'; ctx.lineWidth = 1.5 * s;
                    ctx.beginPath(); ctx.ellipse(cx - 6 * s, cy, 6 * s, 5 * s, 0, 0, Math.PI * 2); ctx.stroke();
                    ctx.beginPath(); ctx.ellipse(cx + 6 * s, cy, 6 * s, 5 * s, 0, 0, Math.PI * 2); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(cx - 1 * s, cy); ctx.lineTo(cx + 1 * s, cy); ctx.stroke();
                } else if (itemId === 'necklace') {
                    ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 2 * s;
                    ctx.beginPath(); ctx.arc(cx, cy - 2 * s, 8 * s, 0.2, Math.PI - 0.2); ctx.stroke();
                    ctx.fillStyle = '#FF1493';
                    ctx.beginPath(); ctx.arc(cx, cy + 6 * s, 3 * s, 0, Math.PI * 2); ctx.fill();
                } else if (itemId === 'watch') {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath(); ctx.arc(cx, cy, 7 * s, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath(); ctx.arc(cx, cy, 5 * s, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#000'; ctx.lineWidth = 1 * s;
                    ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx, cy - 4 * s);
                    ctx.moveTo(cx, cy); ctx.lineTo(cx + 3 * s, cy); ctx.stroke();
                    ctx.fillStyle = '#8B4513'; ctx.fillRect(cx - 2 * s, cy - 9 * s, 4 * s, 3 * s);
                    ctx.fillRect(cx - 2 * s, cy + 6 * s, 4 * s, 3 * s);
                } else if (itemId === 'backpack') {
                    ctx.fillStyle = '#E53935';
                    ctx.beginPath(); ctx.roundRect(cx - 7 * s, cy - 8 * s, 14 * s, 16 * s, 3 * s); ctx.fill();
                    ctx.fillStyle = '#C62828';
                    ctx.beginPath(); ctx.roundRect(cx - 5 * s, cy - 8 * s, 10 * s, 5 * s, [2 * s, 2 * s, 0, 0]); ctx.fill();
                    ctx.fillStyle = '#EF5350';
                    ctx.beginPath(); ctx.roundRect(cx - 4 * s, cy + 2 * s, 8 * s, 4 * s, 1 * s); ctx.fill();
                } else if (itemId === 'headphones') {
                    ctx.strokeStyle = '#333'; ctx.lineWidth = 2 * s;
                    ctx.beginPath(); ctx.arc(cx, cy - 2 * s, 10 * s, Math.PI, 0); ctx.stroke();
                    ctx.fillStyle = '#FF1493';
                    ctx.beginPath(); ctx.roundRect(cx - 12 * s, cy - 4 * s, 6 * s, 8 * s, 2 * s); ctx.fill();
                    ctx.beginPath(); ctx.roundRect(cx + 6 * s, cy - 4 * s, 6 * s, 8 * s, 2 * s); ctx.fill();
                    ctx.fillStyle = '#333';
                    ctx.beginPath(); ctx.roundRect(cx - 11 * s, cy - 3 * s, 4 * s, 6 * s, 1 * s); ctx.fill();
                    ctx.beginPath(); ctx.roundRect(cx + 7 * s, cy - 3 * s, 4 * s, 6 * s, 1 * s); ctx.fill();
                } else if (itemId === 'tiara') {
                    ctx.fillStyle = '#C0C0C0';
                    ctx.beginPath();
                    ctx.moveTo(cx - 10 * s, cy + 3 * s); ctx.lineTo(cx - 6 * s, cy - 4 * s);
                    ctx.lineTo(cx - 2 * s, cy); ctx.lineTo(cx, cy - 8 * s);
                    ctx.lineTo(cx + 2 * s, cy); ctx.lineTo(cx + 6 * s, cy - 4 * s);
                    ctx.lineTo(cx + 10 * s, cy + 3 * s); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = '#87CEEB';
                    ctx.beginPath(); ctx.arc(cx, cy - 4 * s, 2 * s, 0, Math.PI * 2); ctx.fill();
                } else if (itemId === 'scarf_acc') {
                    ctx.fillStyle = '#8B008B';
                    ctx.beginPath(); ctx.ellipse(cx, cy - 2 * s, 10 * s, 4 * s, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.fillRect(cx + 6 * s, cy, 5 * s, 10 * s);
                    ctx.fillStyle = '#FF69B4';
                    ctx.fillRect(cx + 6 * s, cy + 3 * s, 5 * s, 2 * s);
                    ctx.fillRect(cx + 6 * s, cy + 7 * s, 5 * s, 2 * s);
                }
            } else if (category === 'horns') {
                const hornDef = itemDefinitions.horns.find(h => h.id === itemId);
                if (hornDef) {
                    if (hornDef.id === 'rainbow') {
                        const rg = ctx.createLinearGradient(cx, cy - 12 * s, cx, cy + 8 * s);
                        rg.addColorStop(0, '#FF0000'); rg.addColorStop(0.5, '#00FF00'); rg.addColorStop(1, '#9400D3');
                        ctx.fillStyle = rg;
                    } else {
                        ctx.fillStyle = hornDef.color;
                    }
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - 12 * s);
                    ctx.lineTo(cx - 5 * s, cy + 8 * s);
                    ctx.lineTo(cx + 5 * s, cy + 8 * s);
                    ctx.closePath(); ctx.fill();
                    // Spirala
                    ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.lineWidth = 1 * s;
                    for (let sp = 0; sp < 3; sp++) {
                        const sy2 = cy - 8 * s + sp * 6 * s;
                        ctx.beginPath(); ctx.moveTo(cx - 3 * s + sp * 0.5 * s, sy2); ctx.lineTo(cx + 3 * s - sp * 0.5 * s, sy2); ctx.stroke();
                    }
                }
            } else if (category === 'colors') {
                const cDef = itemDefinitions.colors.find(c => c.id === itemId);
                if (cDef) {
                    // Mini kociak w tym kolorze
                    ctx.fillStyle = cDef.bodyColor;
                    ctx.beginPath(); ctx.arc(cx, cy, 10 * s, 0, Math.PI * 2); ctx.fill();
                    // Uszka
                    ctx.beginPath();
                    ctx.moveTo(cx - 6 * s, cy - 7 * s); ctx.lineTo(cx - 10 * s, cy - 14 * s); ctx.lineTo(cx - 2 * s, cy - 9 * s); ctx.closePath(); ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(cx + 6 * s, cy - 7 * s); ctx.lineTo(cx + 10 * s, cy - 14 * s); ctx.lineTo(cx + 2 * s, cy - 9 * s); ctx.closePath(); ctx.fill();
                    // Oczy
                    ctx.fillStyle = '#000';
                    ctx.beginPath(); ctx.arc(cx - 3 * s, cy - 1 * s, 1.5 * s, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(cx + 3 * s, cy - 1 * s, 1.5 * s, 0, Math.PI * 2); ctx.fill();
                    // Nos
                    ctx.fillStyle = '#FF69B4';
                    ctx.beginPath(); ctx.arc(cx, cy + 2 * s, 1.5 * s, 0, Math.PI * 2); ctx.fill();
                }
            }
            ctx.restore();
        }

        // Rysowanie realistycznego Kicioro≈ºka
        function drawPlayer(x, y) {
            ctx.save();

            // Odbicie lustrzane gdy idzie w lewo
            if (!player.facingRight) {
                ctx.translate(x + player.width / 2, y + player.height / 2);
                ctx.scale(-1, 1);
                ctx.translate(-x - player.width / 2, -y - player.height / 2);
            }

            const walkOffset = Math.sin(player.walkCycle) * 3;
            player.tailSwing += 0.1;

            // Kolory z wybranego koloru futerka
            const colorDef = itemDefinitions.colors.find(c => c.id === player.equippedColor);
            const bodyColor = colorDef.bodyColor;
            const shadeColor = colorDef.shadeColor;

            // Cie≈Ñ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.ellipse(x + 30, y + 75, 25, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Ogon (d≈Çugi i puszyty)
            ctx.strokeStyle = shadeColor;
            ctx.lineWidth = 12;
            ctx.lineCap = 'round';
            const tailX = x + 10;
            const tailY = y + 40;
            const tailCurve = Math.sin(player.tailSwing) * 20;
            ctx.beginPath();
            ctx.moveTo(tailX, tailY);
            ctx.quadraticCurveTo(
                tailX - 30 + tailCurve, tailY - 20,
                tailX - 40, tailY - 40
            );
            ctx.stroke();

            // Koniec ogona (puszysty)
            ctx.fillStyle = shadeColor;
            ctx.beginPath();
            ctx.arc(tailX - 40, tailY - 40, 8, 0, Math.PI * 2);
            ctx.fill();

            // PELERYNA (rysowana ZA PLECAMI!)
            if (player.equippedOutfit === 'cape') {
                ctx.fillStyle = '#DC143C';
                ctx.beginPath();
                ctx.moveTo(x + 20, y + 30);
                ctx.lineTo(x, y + 70);
                ctx.lineTo(x + 40, y + 70);
                ctx.lineTo(x + 40, y + 30);
                ctx.fill();
                // Z≈Çoty ko≈Çnierz
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(x + 15, y + 28, 30, 6);
            }

            // Tylne ≈Çapki
            ctx.fillStyle = bodyColor;
            // Lewa tylna
            ctx.beginPath();
            ctx.ellipse(x + 15, y + 60 + walkOffset, 10, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            // Prawa tylna
            ctx.beginPath();
            ctx.ellipse(x + 35, y + 60 - walkOffset, 10, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Cia≈Ço (wiƒôksze, bardziej kocie)
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.ellipse(x + 30, y + 45, 28, 35, 0, 0, Math.PI * 2);
            ctx.fill();

            // Gradient na brzuszku (ja≈õniejszy odcie≈Ñ)
            const gradient = ctx.createRadialGradient(x + 30, y + 50, 5, x + 30, y + 50, 25);
            // Normalize short hex (#FFF) to full form (#FFFFFF) for safe alpha appending
            const fullBodyColor = bodyColor.length === 4
                ? '#' + bodyColor[1] + bodyColor[1] + bodyColor[2] + bodyColor[2] + bodyColor[3] + bodyColor[3]
                : bodyColor;
            gradient.addColorStop(0, fullBodyColor + 'EE');
            gradient.addColorStop(1, fullBodyColor + '00');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.ellipse(x + 30, y + 50, 18, 25, 0, 0, Math.PI * 2);
            ctx.fill();

            // Przednie ≈Çapki
            ctx.fillStyle = bodyColor;
            // Lewa przednia
            ctx.beginPath();
            ctx.ellipse(x + 20, y + 65 - walkOffset, 8, 18, 0, 0, Math.PI * 2);
            ctx.fill();
            // Prawa przednia
            ctx.beginPath();
            ctx.ellipse(x + 40, y + 65 + walkOffset, 8, 18, 0, 0, Math.PI * 2);
            ctx.fill();

            // Paluszki na ≈Çapkach (ciemniejszy odcie≈Ñ)
            ctx.fillStyle = shadeColor;
            [20, 40].forEach(offsetX => {
                for (let i = -1; i <= 1; i++) {
                    ctx.beginPath();
                    ctx.arc(x + offsetX + i * 3, y + 75, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // G≈Çowa (wiƒôksza, bardziej szczeg√≥≈Çowa)
            ctx.fillStyle = shadeColor;
            ctx.beginPath();
            ctx.arc(x + 35, y + 25, 22, 0, Math.PI * 2);
            ctx.fill();

            // Policzki (rumie≈Ñce - zawsze r√≥≈ºowe)
            ctx.fillStyle = 'rgba(255, 105, 180, 0.3)';
            ctx.beginPath();
            ctx.arc(x + 20, y + 30, 8, 0, Math.PI * 2);
            ctx.arc(x + 50, y + 30, 8, 0, Math.PI * 2);
            ctx.fill();

            // Uszy (wiƒôksze)
            ctx.fillStyle = shadeColor;
            // Lewe ucho
            ctx.beginPath();
            ctx.moveTo(x + 20, y + 15);
            ctx.lineTo(x + 15, y);
            ctx.lineTo(x + 25, y + 10);
            ctx.fill();
            // ≈örodek lewego ucha (ja≈õniejszy)
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.moveTo(x + 20, y + 13);
            ctx.lineTo(x + 18, y + 5);
            ctx.lineTo(x + 23, y + 11);
            ctx.fill();

            // Prawe ucho
            ctx.fillStyle = shadeColor;
            ctx.beginPath();
            ctx.moveTo(x + 50, y + 15);
            ctx.lineTo(x + 55, y);
            ctx.lineTo(x + 45, y + 10);
            ctx.fill();
            // ≈örodek prawego ucha (ja≈õniejszy)
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.moveTo(x + 50, y + 13);
            ctx.lineTo(x + 52, y + 5);
            ctx.lineTo(x + 47, y + 11);
            ctx.fill();

            // R√≥g jednoro≈ºca (piƒôkny, spiralny, w wybranym kolorze! DU≈ªO WIƒòKSZY - 2x!)
            const hornDef = itemDefinitions.horns.find(h => h.id === player.equippedHorn);

            if (hornDef.id === 'rainbow') {
                // Tƒôczowy r√≥g (gradient) - 2x wiƒôkszy, na czole
                const rainbowGradient = ctx.createLinearGradient(x + 29, y - 20, x + 41, y + 10);
                rainbowGradient.addColorStop(0, '#FF0000');
                rainbowGradient.addColorStop(0.17, '#FF7F00');
                rainbowGradient.addColorStop(0.33, '#FFFF00');
                rainbowGradient.addColorStop(0.5, '#00FF00');
                rainbowGradient.addColorStop(0.67, '#0000FF');
                rainbowGradient.addColorStop(0.83, '#4B0082');
                rainbowGradient.addColorStop(1, '#9400D3');
                ctx.fillStyle = rainbowGradient;
            } else {
                ctx.fillStyle = hornDef.color;
            }

            // Wiƒôkszy tr√≥jkƒÖt rogu - na czole zamiast na nosie
            ctx.beginPath();
            ctx.moveTo(x + 35, y - 20);  // G√≥ra znacznie wy≈ºej (na czole)
            ctx.lineTo(x + 29, y + 10);  // Lewa krawƒôd≈∫ - podstawa na czole
            ctx.lineTo(x + 41, y + 10);  // Prawa krawƒôd≈∫ - podstawa na czole
            ctx.fill();

            // Spirala na rogu (ciemniejszy odcie≈Ñ) - wiƒôksza
            if (hornDef.id === 'rainbow') {
                ctx.strokeStyle = '#9400D3';
            } else if (hornDef.color) {
                // Ciemniejszy odcie≈Ñ koloru rogu
                ctx.strokeStyle = hornDef.color.replace(/[0-9A-F]{2}([0-9A-F]{2})([0-9A-F]{2})/i, (match, p1, p2) => {
                    return match.slice(0, -6) +
                           Math.max(0, parseInt(p1, 16) - 30).toString(16).padStart(2, '0') +
                           Math.max(0, parseInt(p2, 16) - 30).toString(16).padStart(2, '0');
                });
            } else {
                ctx.strokeStyle = '#FFA500';
            }

            ctx.lineWidth = 3;  // Grubsza spirala
            for (let i = 0; i < 5; i++) {  // Wiƒôcej spiral (5 zamiast 3)
                ctx.beginPath();
                ctx.arc(x + 35, y - 15 + i * 6, 5, 0, Math.PI);  // Spirale wy≈ºej, na czole
                ctx.stroke();
            }

            // Blask na rogu - wiƒôkszy i wy≈ºej
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(x + 37, y - 13, 4, 0, Math.PI * 2);
            ctx.fill();

            // Oczy (du≈ºe, s≈Çodkie)
            ctx.fillStyle = '#000';
            // Lewe oko
            ctx.beginPath();
            ctx.ellipse(x + 26, y + 23, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            // Prawe oko
            ctx.beginPath();
            ctx.ellipse(x + 44, y + 23, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // B≈Çyski w oczach
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x + 27, y + 22, 2, 0, Math.PI * 2);
            ctx.arc(x + 45, y + 22, 2, 0, Math.PI * 2);
            ctx.fill();

            // Nosek (tr√≥jkƒÖcik)
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.moveTo(x + 35, y + 28);
            ctx.lineTo(x + 33, y + 32);
            ctx.lineTo(x + 37, y + 32);
            ctx.fill();

            // Buzia (u≈õmiech)
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(x + 35, y + 32, 6, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // WƒÖsy (d≈Çugie)
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            // Lewe wƒÖsy
            ctx.beginPath();
            ctx.moveTo(x + 35, y + 30);
            ctx.lineTo(x + 15, y + 26);
            ctx.moveTo(x + 35, y + 30);
            ctx.lineTo(x + 15, y + 32);
            ctx.stroke();
            // Prawe wƒÖsy
            ctx.beginPath();
            ctx.moveTo(x + 35, y + 30);
            ctx.lineTo(x + 55, y + 26);
            ctx.moveTo(x + 35, y + 30);
            ctx.lineTo(x + 55, y + 32);
            ctx.stroke();

            // ===== FRYZURA (W≈ÅOSY) =====
            if (player.equippedHairstyle) {
                // Kolor w≈Ços√≥w
                let hairColor = '#8B4513'; // domy≈õlny brƒÖz
                if (player.equippedHairColor) {
                    const hcDef = itemDefinitions.hairColors.find(c => c.id === player.equippedHairColor);
                    if (hcDef) hairColor = hcDef.color;
                }
                const useRainbow = hairColor === 'rainbow';
                if (useRainbow) {
                    const rg = ctx.createLinearGradient(x + 15, y - 5, x + 55, y + 20);
                    rg.addColorStop(0, '#FF0000');
                    rg.addColorStop(0.2, '#FF7F00');
                    rg.addColorStop(0.4, '#FFFF00');
                    rg.addColorStop(0.6, '#00FF00');
                    rg.addColorStop(0.8, '#0000FF');
                    rg.addColorStop(1, '#9400D3');
                    ctx.fillStyle = rg;
                } else {
                    ctx.fillStyle = hairColor;
                }

                const hsId = player.equippedHairstyle;
                if (hsId === 'ponytail') {
                    // Grzywka
                    ctx.beginPath();
                    ctx.arc(x + 35, y + 8, 20, Math.PI, 0);
                    ctx.fill();
                    // Kucyk z ty≈Çu
                    ctx.lineWidth = 6;
                    ctx.strokeStyle = useRainbow ? '#FF00FF' : hairColor;
                    ctx.beginPath();
                    ctx.moveTo(x + 15, y + 15);
                    ctx.quadraticCurveTo(x + 5, y + 25, x + 8, y + 45);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(x + 8, y + 45, 5, 0, Math.PI * 2);
                    ctx.fillStyle = useRainbow ? '#FF00FF' : hairColor;
                    ctx.fill();
                } else if (hsId === 'curly') {
                    for (let ci = 0; ci < 7; ci++) {
                        const angle = (ci / 7) * Math.PI + Math.PI;
                        const cx2 = x + 35 + Math.cos(angle) * 20;
                        const cy2 = y + 10 + Math.sin(angle) * 12;
                        ctx.beginPath();
                        ctx.arc(cx2, cy2, 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (hsId === 'spiky') {
                    for (let sp = 0; sp < 5; sp++) {
                        const spx = x + 22 + sp * 7;
                        ctx.beginPath();
                        ctx.moveTo(spx, y + 10);
                        ctx.lineTo(spx + 3, y - 10 - sp % 2 * 5);
                        ctx.lineTo(spx + 7, y + 10);
                        ctx.closePath();
                        ctx.fill();
                    }
                } else if (hsId === 'long') {
                    ctx.beginPath();
                    ctx.arc(x + 35, y + 10, 22, Math.PI, 0);
                    ctx.fill();
                    // D≈Çugie w≈Çosy po bokach
                    ctx.fillRect(x + 12, y + 10, 7, 40);
                    ctx.fillRect(x + 51, y + 10, 7, 40);
                    // ZaokrƒÖglone ko≈Ñce
                    ctx.beginPath();
                    ctx.arc(x + 15.5, y + 50, 3.5, 0, Math.PI * 2);
                    ctx.arc(x + 54.5, y + 50, 3.5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (hsId === 'buns') {
                    ctx.beginPath();
                    ctx.arc(x + 35, y + 8, 18, Math.PI, 0);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + 20, y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + 50, y, 8, 0, Math.PI * 2);
                    ctx.fill();
                } else if (hsId === 'bob') {
                    ctx.beginPath();
                    ctx.arc(x + 35, y + 10, 22, Math.PI, 0);
                    ctx.fill();
                    ctx.fillRect(x + 13, y + 10, 8, 20);
                    ctx.fillRect(x + 49, y + 10, 8, 20);
                } else if (hsId === 'mohawk') {
                    for (let m = 0; m < 6; m++) {
                        const mx = x + 25 + m * 4;
                        const mh = 12 + (3 - Math.abs(m - 2.5)) * 5;
                        ctx.beginPath();
                        ctx.ellipse(mx, y + 5 - mh / 2, 4, mh / 2, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (hsId === 'braids') {
                    ctx.beginPath();
                    ctx.arc(x + 35, y + 8, 18, Math.PI, 0);
                    ctx.fill();
                    // Warkocze (zygzak)
                    ctx.strokeStyle = useRainbow ? '#FF00FF' : hairColor;
                    ctx.lineWidth = 4;
                    for (let side = 0; side < 2; side++) {
                        const bx = side === 0 ? x + 16 : x + 54;
                        ctx.beginPath();
                        ctx.moveTo(bx, y + 15);
                        for (let b = 0; b < 5; b++) {
                            ctx.lineTo(bx + (b % 2 === 0 ? 4 : -4), y + 20 + b * 7);
                        }
                        ctx.stroke();
                    }
                } else if (hsId === 'afro') {
                    ctx.beginPath();
                    ctx.arc(x + 35, y + 8, 26, 0, Math.PI * 2);
                    ctx.fill();
                } else if (hsId === 'pigtails') {
                    ctx.beginPath();
                    ctx.arc(x + 35, y + 8, 18, Math.PI, 0);
                    ctx.fill();
                    // Kitki
                    ctx.beginPath();
                    ctx.arc(x + 12, y + 20, 7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(x + 10, y + 20, 5, 20);
                    ctx.beginPath();
                    ctx.arc(x + 12, y + 40, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + 58, y + 20, 7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(x + 55, y + 20, 5, 20);
                    ctx.beginPath();
                    ctx.arc(x + 58, y + 40, 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ===== SPINKA DO W≈ÅOS√ìW =====
                if (player.equippedHairClip) {
                    const clipDef = itemDefinitions.hairClips.find(c => c.id === player.equippedHairClip);
                    if (clipDef) {
                        ctx.font = '12px serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(clipDef.emoji, x + 48, y + 10);
                        ctx.textAlign = 'left';
                    }
                }
            }

            // Ubranka NA CIELE (WIƒòKSZE I BARDZIEJ WIDOCZNE!)
            if (player.equippedOutfit) {
                const outfitDef = itemDefinitions.outfits.find(o => o.id === player.equippedOutfit);

                if (outfitDef.id === 'cape') {
                    // Gwiazda na pelerynie (peleryna ju≈º narysowana wcze≈õniej)
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText('‚≠ê', x + 20, y + 52);
                } else if (outfitDef.id === 'dress') {
                    // Sukienka ksiƒô≈ºniczki (R√ì≈ªOWA, ROZKLOSZOWANA!)
                    // G√≥ra sukienki (dopasowana)
                    ctx.fillStyle = '#FF1493';
                    ctx.fillRect(x + 15, y + 38, 30, 15);

                    // D√≥≈Ç sukienki (rozkloszowany trapez)
                    ctx.beginPath();
                    ctx.moveTo(x + 15, y + 53); // lewy g√≥rny r√≥g
                    ctx.lineTo(x + 5, y + 72);  // lewy dolny r√≥g (szerszy)
                    ctx.lineTo(x + 55, y + 72); // prawy dolny r√≥g (szerszy)
                    ctx.lineTo(x + 45, y + 53); // prawy g√≥rny r√≥g
                    ctx.closePath();
                    ctx.fill();

                    // Wzorki - bia≈Çe kropki na sukience
                    ctx.fillStyle = '#FFF';
                    for (let i = 0; i < 8; i++) {
                        for (let j = 0; j < 2; j++) {
                            ctx.beginPath();
                            ctx.arc(x + 12 + i * 6, y + 58 + j * 8, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Pasek (z≈Çoty)
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(x + 14, y + 52, 32, 4);

                    // Kokarda na pasku
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(x + 25, y + 54, 4, 0, Math.PI * 2);
                    ctx.arc(x + 35, y + 54, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + 30, y + 54, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (outfitDef.id === 'scarf') {
                    // Szalik (GRUBY I KOLOROWY!)
                    ctx.strokeStyle = '#FF1493';
                    ctx.lineWidth = 12;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(x + 15, y + 32);
                    ctx.lineTo(x + 50, y + 35);
                    ctx.stroke();
                    // Paski na szaliku
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(x + 20 + i * 10, y + 30);
                        ctx.lineTo(x + 25 + i * 10, y + 36);
                        ctx.stroke();
                    }
                    // Frƒôdzle
                    ctx.strokeStyle = '#FF1493';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(x + 48, y + 36);
                    ctx.lineTo(x + 52, y + 46);
                    ctx.moveTo(x + 52, y + 36);
                    ctx.lineTo(x + 56, y + 48);
                    ctx.stroke();
                } else if (outfitDef.id === 'shirt') {
                    // Koszulka (NIEBIESKA!)
                    ctx.fillStyle = '#1E90FF';
                    ctx.fillRect(x + 12, y + 38, 36, 28);
                    // Ko≈Çnierzyk
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.moveTo(x + 25, y + 38);
                    ctx.lineTo(x + 20, y + 42);
                    ctx.lineTo(x + 30, y + 42);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(x + 35, y + 38);
                    ctx.lineTo(x + 40, y + 42);
                    ctx.lineTo(x + 30, y + 42);
                    ctx.fill();
                    // Kieszonka
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x + 22, y + 50, 8, 8);
                } else if (outfitDef.id === 'sweater') {
                    // Sweterek (FIOLETOWY!)
                    ctx.fillStyle = '#9370DB';
                    ctx.fillRect(x + 10, y + 36, 40, 32);
                    // Paski
                    ctx.fillStyle = '#E6E6FA';
                    ctx.fillRect(x + 10, y + 44, 40, 4);
                    ctx.fillRect(x + 10, y + 56, 40, 4);
                    // Guziki (DU≈ªE!)
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(x + 30, y + 42, 3, 0, Math.PI * 2);
                    ctx.arc(x + 30, y + 51, 3, 0, Math.PI * 2);
                    ctx.arc(x + 30, y + 60, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (outfitDef.id === 'tutu') {
                    // Tutu baletowe (R√ì≈ªOWE!)
                    ctx.fillStyle = '#FFB6C1';
                    ctx.fillRect(x + 15, y + 38, 30, 10);
                    // Sp√≥dniczka tutu - warstwy falbanek
                    for (let layer = 0; layer < 3; layer++) {
                        ctx.fillStyle = layer % 2 === 0 ? '#FFB6C1' : '#FFC0CB';
                        ctx.beginPath();
                        ctx.moveTo(x + 10 - layer * 3, y + 48 + layer * 6);
                        ctx.lineTo(x + 50 + layer * 3, y + 48 + layer * 6);
                        ctx.lineTo(x + 48 + layer * 3, y + 54 + layer * 6);
                        ctx.lineTo(x + 12 - layer * 3, y + 54 + layer * 6);
                        ctx.closePath();
                        ctx.fill();
                    }
                    // Kokardka
                    ctx.fillStyle = '#FF69B4';
                    ctx.beginPath();
                    ctx.arc(x + 30, y + 48, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (outfitDef.id === 'pajamas') {
                    // Pi≈ºamka (NIEBIESKA Z GWIAZDKAMI!)
                    ctx.fillStyle = '#6495ED';
                    ctx.fillRect(x + 12, y + 36, 36, 32);
                    // Gwiazdki
                    ctx.fillStyle = '#FFD700';
                    ctx.font = '8px Arial';
                    ctx.fillText('‚≠ê', x + 16, y + 48);
                    ctx.fillText('‚≠ê', x + 32, y + 55);
                    ctx.fillText('‚≠ê', x + 22, y + 64);
                    // Guziczki
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(x + 30, y + 44, 2, 0, Math.PI * 2);
                    ctx.arc(x + 30, y + 52, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (outfitDef.id === 'raincoat') {
                    // P≈Çaszcz przeciwdeszczowy (≈ª√ì≈ÅTY!)
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(x + 10, y + 36, 40, 34);
                    // Kaptur (na plecach)
                    ctx.fillStyle = '#FFC107';
                    ctx.beginPath();
                    ctx.arc(x + 30, y + 34, 12, Math.PI, 0);
                    ctx.fill();
                    // Zamek
                    ctx.strokeStyle = '#B8860B';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + 30, y + 38);
                    ctx.lineTo(x + 30, y + 68);
                    ctx.stroke();
                    // Kieszenie
                    ctx.strokeStyle = '#B8860B';
                    ctx.lineWidth = 1.5;
                    ctx.strokeRect(x + 14, y + 54, 10, 8);
                    ctx.strokeRect(x + 36, y + 54, 10, 8);
                } else if (outfitDef.id === 'armor') {
                    // Zbroja rycerska (SREBRNA!)
                    ctx.fillStyle = '#C0C0C0';
                    ctx.fillRect(x + 12, y + 36, 36, 30);
                    // Napier≈õnik
                    ctx.fillStyle = '#A9A9A9';
                    ctx.beginPath();
                    ctx.moveTo(x + 20, y + 38);
                    ctx.lineTo(x + 40, y + 38);
                    ctx.lineTo(x + 38, y + 55);
                    ctx.lineTo(x + 22, y + 55);
                    ctx.closePath();
                    ctx.fill();
                    // Krzy≈º na napier≈õniku
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x + 30, y + 40);
                    ctx.lineTo(x + 30, y + 52);
                    ctx.moveTo(x + 24, y + 46);
                    ctx.lineTo(x + 36, y + 46);
                    ctx.stroke();
                } else if (outfitDef.id === 'kimono') {
                    // Kimono (CZERWONE!)
                    ctx.fillStyle = '#DC143C';
                    ctx.fillRect(x + 10, y + 36, 40, 34);
                    // Obi (pas)
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(x + 10, y + 50, 40, 8);
                    // Wz√≥r kwiatowy
                    ctx.fillStyle = '#FFF';
                    ctx.font = '10px Arial';
                    ctx.fillText('üå∏', x + 14, y + 47);
                    ctx.fillText('üå∏', x + 34, y + 65);
                    // Ko≈Çnierz V
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + 20, y + 36);
                    ctx.lineTo(x + 30, y + 46);
                    ctx.lineTo(x + 40, y + 36);
                    ctx.stroke();
                } else if (outfitDef.id === 'tuxedo') {
                    // Smoking (CZARNY Z MUSZKƒÑ!)
                    ctx.fillStyle = '#2C2C2C';
                    ctx.fillRect(x + 12, y + 36, 36, 32);
                    // Bia≈Ça koszula
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.moveTo(x + 25, y + 36);
                    ctx.lineTo(x + 35, y + 36);
                    ctx.lineTo(x + 33, y + 60);
                    ctx.lineTo(x + 27, y + 60);
                    ctx.closePath();
                    ctx.fill();
                    // Muszka
                    ctx.fillStyle = '#FF1493';
                    ctx.beginPath();
                    ctx.moveTo(x + 30, y + 38);
                    ctx.lineTo(x + 24, y + 35);
                    ctx.lineTo(x + 24, y + 41);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(x + 30, y + 38);
                    ctx.lineTo(x + 36, y + 35);
                    ctx.lineTo(x + 36, y + 41);
                    ctx.closePath();
                    ctx.fill();
                    // Guziki
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(x + 30, y + 48, 2, 0, Math.PI * 2);
                    ctx.arc(x + 30, y + 56, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (outfitDef.id === 'overalls') {
                    // Ogrodniczki (D≈ªINSOWE!)
                    ctx.fillStyle = '#4682B4';
                    // Nogawki
                    ctx.fillRect(x + 14, y + 48, 14, 22);
                    ctx.fillRect(x + 32, y + 48, 14, 22);
                    // Klatka
                    ctx.fillRect(x + 14, y + 40, 32, 12);
                    // Szelki
                    ctx.fillStyle = '#4682B4';
                    ctx.lineWidth = 4;
                    ctx.strokeStyle = '#4682B4';
                    ctx.beginPath();
                    ctx.moveTo(x + 18, y + 40);
                    ctx.lineTo(x + 22, y + 34);
                    ctx.moveTo(x + 42, y + 40);
                    ctx.lineTo(x + 38, y + 34);
                    ctx.stroke();
                    // Kieszonka z kwiatkiem
                    ctx.fillStyle = '#3A6F9F';
                    ctx.fillRect(x + 22, y + 44, 10, 8);
                    ctx.fillStyle = '#FFD700';
                    ctx.font = '7px Arial';
                    ctx.fillText('üåª', x + 23, y + 51);
                }
            }

            // Akcesoria (WIƒòKSZE I WYRA≈πNIEJSZE!)
            if (player.equippedAccessory) {
                const accessoryDef = itemDefinitions.accessories.find(a => a.id === player.equippedAccessory);

                if (accessoryDef.id === 'crown') {
                    // Korona (DU≈ªA!)
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.moveTo(x + 20, y + 3);
                    ctx.lineTo(x + 22, y - 8);
                    ctx.lineTo(x + 27, y);
                    ctx.lineTo(x + 30, y - 10);
                    ctx.lineTo(x + 33, y);
                    ctx.lineTo(x + 38, y - 8);
                    ctx.lineTo(x + 40, y + 3);
                    ctx.lineTo(x + 35, y + 6);
                    ctx.lineTo(x + 25, y + 6);
                    ctx.closePath();
                    ctx.fill();
                    // Klejnoty (DU≈ªE!)
                    ctx.fillStyle = '#FF1493';
                    ctx.beginPath();
                    ctx.arc(x + 27, y - 2, 3, 0, Math.PI * 2);
                    ctx.arc(x + 33, y - 2, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#00FF00';
                    ctx.beginPath();
                    ctx.arc(x + 30, y - 5, 4, 0, Math.PI * 2);
                    ctx.fill();
                    // Obw√≥dka
                    ctx.strokeStyle = '#B8860B';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + 20, y + 3);
                    ctx.lineTo(x + 40, y + 3);
                    ctx.stroke();
                } else if (accessoryDef.id === 'bow') {
                    // Kokarda (DU≈ªA!)
                    ctx.fillStyle = '#FF1493';
                    ctx.beginPath();
                    ctx.arc(x + 24, y + 6, 9, 0, Math.PI * 2);
                    ctx.arc(x + 46, y + 6, 9, 0, Math.PI * 2);
                    ctx.fill();
                    // ≈örodek kokardy
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(x + 30, y + 2, 10, 8);
                    // Wzory kropki
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(x + 24, y + 4, 2, 0, Math.PI * 2);
                    ctx.arc(x + 46, y + 4, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (accessoryDef.id === 'glasses') {
                    // Okulary (WIƒòKSZE!)
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    // Lewe szk≈Ço
                    ctx.beginPath();
                    ctx.arc(x + 24, y + 23, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    // Prawe szk≈Ço
                    ctx.beginPath();
                    ctx.arc(x + 46, y + 23, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    // Mostek
                    ctx.beginPath();
                    ctx.moveTo(x + 32, y + 23);
                    ctx.lineTo(x + 38, y + 23);
                    ctx.stroke();
                    // Zauszniki
                    ctx.beginPath();
                    ctx.moveTo(x + 16, y + 23);
                    ctx.lineTo(x + 12, y + 25);
                    ctx.moveTo(x + 54, y + 23);
                    ctx.lineTo(x + 58, y + 25);
                    ctx.stroke();
                    // B≈Çysk na szk≈Çach
                    ctx.fillStyle = 'rgba(135, 206, 250, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x + 24, y + 23, 7, 0, Math.PI * 2);
                    ctx.arc(x + 46, y + 23, 7, 0, Math.PI * 2);
                    ctx.fill();
                } else if (accessoryDef.id === 'hat') {
                    // Kapelusz (WIƒòKSZY!)
                    ctx.fillStyle = '#654321';
                    // Korpus
                    ctx.fillRect(x + 20, y - 4, 30, 12);
                    // Rondo
                    ctx.beginPath();
                    ctx.ellipse(x + 35, y + 8, 24, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // WstƒÖ≈ºka
                    ctx.fillStyle = '#8B0000';
                    ctx.fillRect(x + 20, y + 4, 30, 4);
                } else if (accessoryDef.id === 'flower') {
                    // Kwiatek (DU≈ªY!)
                    ctx.fillStyle = '#FF69B4';
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const px = x + 24 + Math.cos(angle) * 9;
                        const py = y + 6 + Math.sin(angle) * 9;
                        ctx.beginPath();
                        ctx.arc(px, py, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // ≈örodek kwiatka
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(x + 24, y + 6, 5, 0, Math.PI * 2);
                    ctx.fill();
                    // ≈Åody≈ºka
                    ctx.strokeStyle = '#228B22';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x + 24, y + 11);
                    ctx.lineTo(x + 24, y + 18);
                    ctx.stroke();
                } else if (accessoryDef.id === 'sunglasses') {
                    // Okulary przeciws≈Çoneczne (CIEMNE!)
                    // Lewe szk≈Ço
                    ctx.fillStyle = 'rgba(40, 40, 40, 0.85)';
                    ctx.beginPath();
                    ctx.ellipse(x + 23, y + 23, 9, 7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Prawe szk≈Ço
                    ctx.beginPath();
                    ctx.ellipse(x + 47, y + 23, 9, 7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Oprawki
                    ctx.strokeStyle = '#FF1493';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.ellipse(x + 23, y + 23, 9, 7, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.ellipse(x + 47, y + 23, 9, 7, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    // Mostek
                    ctx.beginPath();
                    ctx.moveTo(x + 32, y + 22);
                    ctx.lineTo(x + 38, y + 22);
                    ctx.stroke();
                    // B≈Çysk
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x + 20, y + 21, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (accessoryDef.id === 'necklace') {
                    // Naszyjnik (Z≈ÅOTY Z PERE≈ÅKƒÑ!)
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.arc(x + 30, y + 32, 14, Math.PI * 0.15, Math.PI * 0.85);
                    ctx.stroke();
                    // Per≈Ça/wisiorek
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(x + 30, y + 46, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FF1493';
                    ctx.beginPath();
                    ctx.arc(x + 30, y + 46, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (accessoryDef.id === 'watch') {
                    // Zegarek (NA ≈ÅAPCE!)
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(x + 52, y + 55, 6, 0, Math.PI * 2);
                    ctx.fill();
                    // Tarcza
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(x + 52, y + 55, 4.5, 0, Math.PI * 2);
                    ctx.fill();
                    // Wskaz√≥wki
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x + 52, y + 55);
                    ctx.lineTo(x + 52, y + 52);
                    ctx.moveTo(x + 52, y + 55);
                    ctx.lineTo(x + 55, y + 55);
                    ctx.stroke();
                    // Pasek
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(x + 49, y + 49, 6, 3);
                    ctx.fillRect(x + 49, y + 59, 6, 3);
                } else if (accessoryDef.id === 'backpack') {
                    // Plecaczek (CZERWONY, NA PLECACH!)
                    ctx.fillStyle = '#E53935';
                    ctx.beginPath();
                    ctx.roundRect(x + 5, y + 30, 18, 22, 4);
                    ctx.fill();
                    // Klapka
                    ctx.fillStyle = '#C62828';
                    ctx.beginPath();
                    ctx.roundRect(x + 7, y + 30, 14, 8, [4, 4, 0, 0]);
                    ctx.fill();
                    // Kieszonka
                    ctx.fillStyle = '#EF5350';
                    ctx.beginPath();
                    ctx.roundRect(x + 8, y + 42, 12, 7, 2);
                    ctx.fill();
                    // Szelki
                    ctx.strokeStyle = '#C62828';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + 14, y + 30);
                    ctx.lineTo(x + 18, y + 36);
                    ctx.moveTo(x + 14, y + 30);
                    ctx.lineTo(x + 10, y + 36);
                    ctx.stroke();
                } else if (accessoryDef.id === 'headphones') {
                    // S≈Çuchawki (NA G≈ÅOWIE!)
                    // Pa≈ÇƒÖk
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x + 30, y + 10, 18, Math.PI, 0);
                    ctx.stroke();
                    // Lewa s≈Çuchawka
                    ctx.fillStyle = '#FF1493';
                    ctx.beginPath();
                    ctx.roundRect(x + 9, y + 6, 10, 14, 3);
                    ctx.fill();
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.roundRect(x + 10, y + 8, 8, 10, 2);
                    ctx.fill();
                    // Prawa s≈Çuchawka
                    ctx.fillStyle = '#FF1493';
                    ctx.beginPath();
                    ctx.roundRect(x + 41, y + 6, 10, 14, 3);
                    ctx.fill();
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.roundRect(x + 42, y + 8, 8, 10, 2);
                    ctx.fill();
                } else if (accessoryDef.id === 'tiara') {
                    // Tiara (SREBRNA Z DIAMENTAMI!)
                    ctx.fillStyle = '#C0C0C0';
                    ctx.beginPath();
                    ctx.moveTo(x + 18, y + 6);
                    ctx.lineTo(x + 22, y - 2);
                    ctx.lineTo(x + 26, y + 3);
                    ctx.lineTo(x + 30, y - 6);
                    ctx.lineTo(x + 34, y + 3);
                    ctx.lineTo(x + 38, y - 2);
                    ctx.lineTo(x + 42, y + 6);
                    ctx.closePath();
                    ctx.fill();
                    // Obw√≥dka
                    ctx.strokeStyle = '#A9A9A9';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    // Diamenty
                    ctx.fillStyle = '#87CEEB';
                    ctx.beginPath();
                    ctx.arc(x + 30, y - 2, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#E0E0E0';
                    ctx.beginPath();
                    ctx.arc(x + 24, y + 1, 2, 0, Math.PI * 2);
                    ctx.arc(x + 36, y + 1, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (accessoryDef.id === 'scarf_acc') {
                    // Szaliczek we≈Çniany (KOLOROWY NA SZYI!)
                    ctx.fillStyle = '#8B008B';
                    ctx.lineWidth = 1;
                    // Owiniƒôty na szyi
                    ctx.beginPath();
                    ctx.ellipse(x + 30, y + 34, 18, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // ZwisajƒÖcy koniec
                    ctx.fillRect(x + 40, y + 34, 8, 20);
                    ctx.fillRect(x + 44, y + 34, 8, 16);
                    // Paski
                    ctx.fillStyle = '#FF69B4';
                    ctx.fillRect(x + 40, y + 40, 8, 3);
                    ctx.fillRect(x + 40, y + 48, 8, 3);
                    ctx.fillRect(x + 44, y + 38, 8, 3);
                    ctx.fillRect(x + 44, y + 44, 8, 3);
                }
            }

            ctx.restore();
        }

        // Rysowanie psa (Tƒôczowy Piesek)
        function drawDog(x, y, scale = 1) {
            const s = scale;
            // Ogon
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x - 15 * s, y + 30 * s, 12 * s, 0, Math.PI * 2);
            ctx.fill();

            // Cia≈Ço
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.ellipse(x, y + 30 * s, 18 * s, 25 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // ≈Åapki
            ctx.fillStyle = '#FFA500';
            ctx.fillRect(x - 12 * s, y + 50 * s, 8 * s, 18 * s);
            ctx.fillRect(x + 4 * s, y + 50 * s, 8 * s, 18 * s);

            // G≈Ç√≥wka
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x, y + 10 * s, 15 * s, 0, Math.PI * 2);
            ctx.fill();

            // Uszy
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.ellipse(x - 12 * s, y + 8 * s, 6 * s, 12 * s, -0.3, 0, Math.PI * 2);
            ctx.ellipse(x + 12 * s, y + 8 * s, 6 * s, 12 * s, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 5 * s, y + 8 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(x + 5 * s, y + 8 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // B≈Çysk w oczach
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 4 * s, y + 7 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.arc(x + 6 * s, y + 7 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y + 15 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // Jƒôzyk
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.ellipse(x, y + 20 * s, 3 * s, 5 * s, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie kr√≥liczka
        function drawRabbit(x, y, scale = 1) {
            const s = scale;
            // Ogon (puszek)
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.arc(x - 12 * s, y + 40 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();

            // Cia≈Ço
            ctx.fillStyle = '#FFC0CB';
            ctx.beginPath();
            ctx.ellipse(x, y + 35 * s, 16 * s, 22 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // ≈Åapki
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.ellipse(x - 10 * s, y + 55 * s, 7 * s, 10 * s, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 10 * s, y + 55 * s, 7 * s, 10 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // G≈Ç√≥wka
            ctx.fillStyle = '#FFC0CB';
            ctx.beginPath();
            ctx.arc(x, y + 15 * s, 13 * s, 0, Math.PI * 2);
            ctx.fill();

            // D≈Çugie uszy
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.ellipse(x - 8 * s, y - 5 * s, 5 * s, 20 * s, -0.2, 0, Math.PI * 2);
            ctx.ellipse(x + 8 * s, y - 5 * s, 5 * s, 20 * s, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // ≈örodek ucha
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.ellipse(x - 8 * s, y - 5 * s, 3 * s, 15 * s, -0.2, 0, Math.PI * 2);
            ctx.ellipse(x + 8 * s, y - 5 * s, 3 * s, 15 * s, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 5 * s, y + 13 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(x + 5 * s, y + 13 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.moveTo(x, y + 18 * s);
            ctx.lineTo(x - 2 * s, y + 21 * s);
            ctx.lineTo(x + 2 * s, y + 21 * s);
            ctx.fill();
        }

        // Rysowanie misia
        function drawBear(x, y, scale = 1) {
            const s = scale;
            // Cia≈Ço
            ctx.fillStyle = '#DDA0DD';
            ctx.beginPath();
            ctx.ellipse(x, y + 35 * s, 20 * s, 28 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek
            ctx.fillStyle = '#E6B8E6';
            ctx.beginPath();
            ctx.ellipse(x, y + 40 * s, 14 * s, 20 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // ≈Åapki
            ctx.fillStyle = '#DDA0DD';
            ctx.beginPath();
            ctx.ellipse(x - 18 * s, y + 30 * s, 8 * s, 12 * s, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 18 * s, y + 30 * s, 8 * s, 12 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nogi
            ctx.fillStyle = '#DDA0DD';
            ctx.fillRect(x - 12 * s, y + 58 * s, 10 * s, 12 * s);
            ctx.fillRect(x + 2 * s, y + 58 * s, 10 * s, 12 * s);

            // G≈Ç√≥wka
            ctx.fillStyle = '#DDA0DD';
            ctx.beginPath();
            ctx.arc(x, y + 12 * s, 16 * s, 0, Math.PI * 2);
            ctx.fill();

            // Uszy (okrƒÖg≈Çe)
            ctx.fillStyle = '#BA7FBA';
            ctx.beginPath();
            ctx.arc(x - 12 * s, y + 2 * s, 8 * s, 0, Math.PI * 2);
            ctx.arc(x + 12 * s, y + 2 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();

            // Pysk
            ctx.fillStyle = '#E6B8E6';
            ctx.beginPath();
            ctx.ellipse(x, y + 16 * s, 10 * s, 8 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 6 * s, y + 10 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(x + 6 * s, y + 10 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y + 18 * s, 4 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie baranka
        function drawSheep(x, y, scale = 1) {
            const s = scale;
            // We≈Çniane kulki na ciele
            ctx.fillStyle = '#E0C3FC';
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const rx = Math.cos(angle) * 15 * s;
                const ry = Math.sin(angle) * 18 * s;
                ctx.beginPath();
                ctx.arc(x + rx, y + 35 * s + ry, 10 * s, 0, Math.PI * 2);
                ctx.fill();
            }

            // G≈Ç√≥wne cia≈Ço
            ctx.fillStyle = '#E0C3FC';
            ctx.beginPath();
            ctx.ellipse(x, y + 35 * s, 18 * s, 22 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nogi
            ctx.fillStyle = '#D8BFD8';
            ctx.fillRect(x - 14 * s, y + 52 * s, 7 * s, 16 * s);
            ctx.fillRect(x - 3 * s, y + 52 * s, 7 * s, 16 * s);
            ctx.fillRect(x + 8 * s, y + 52 * s, 7 * s, 16 * s);

            // G≈Ç√≥wka
            ctx.fillStyle = '#F0E6FF';
            ctx.beginPath();
            ctx.ellipse(x, y + 12 * s, 12 * s, 14 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // We≈Çniane kulki na g≈Çowie
            ctx.fillStyle = '#E0C3FC';
            ctx.beginPath();
            ctx.arc(x - 8 * s, y + 5 * s, 7 * s, 0, Math.PI * 2);
            ctx.arc(x + 8 * s, y + 5 * s, 7 * s, 0, Math.PI * 2);
            ctx.arc(x, y + 0, 7 * s, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 4 * s, y + 12 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(x + 4 * s, y + 12 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y + 18 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie delfina
        function drawDolphin(x, y, scale = 1) {
            const s = scale;
            // Cia≈Ço
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.ellipse(x, y + 30 * s, 15 * s, 25 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek
            ctx.fillStyle = '#B0E0E6';
            ctx.beginPath();
            ctx.ellipse(x, y + 35 * s, 10 * s, 18 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // P≈Çetwy boczne
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.ellipse(x - 15 * s, y + 30 * s, 10 * s, 6 * s, -0.5, 0, Math.PI * 2);
            ctx.ellipse(x + 15 * s, y + 30 * s, 10 * s, 6 * s, 0.5, 0, Math.PI * 2);
            ctx.fill();

            // G≈Ç√≥wka z dziobem
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.arc(x, y + 10 * s, 13 * s, 0, Math.PI * 2);
            ctx.fill();

            // Dzi√≥b
            ctx.fillStyle = '#6CA6CD';
            ctx.beginPath();
            ctx.ellipse(x, y + 2 * s, 8 * s, 6 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 5 * s, y + 8 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(x + 5 * s, y + 8 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // B≈Çysk w oczach
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 4 * s, y + 7 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.arc(x + 6 * s, y + 7 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.fill();

            // Ogon
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.moveTo(x - 10 * s, y + 55 * s);
            ctx.lineTo(x, y + 50 * s);
            ctx.lineTo(x + 10 * s, y + 55 * s);
            ctx.fill();

            // P≈Çetwa grzbietowa
            ctx.fillStyle = '#6CA6CD';
            ctx.beginPath();
            ctx.moveTo(x - 5 * s, y + 25 * s);
            ctx.lineTo(x, y + 15 * s);
            ctx.lineTo(x + 5 * s, y + 25 * s);
            ctx.fill();
        }

        // Rysowanie lisa
        function drawFox(x, y, scale = 1) {
            const s = scale;
            // Puszysty ogon
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.arc(x - 18 * s, y + 40 * s, 20 * s, 0, Math.PI * 2);
            ctx.fill();

            // Bia≈Çy czubek ogona
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 22 * s, y + 35 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();

            // Cia≈Ço
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.ellipse(x, y + 35 * s, 18 * s, 25 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek (bia≈Çe)
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.ellipse(x, y + 40 * s, 12 * s, 18 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nogi
            ctx.fillStyle = '#FF8C00';
            ctx.fillRect(x - 12 * s, y + 55 * s, 8 * s, 14 * s);
            ctx.fillRect(x + 4 * s, y + 55 * s, 8 * s, 14 * s);

            // Bia≈Çe ≈Çapki
            ctx.fillStyle = '#FFF';
            ctx.fillRect(x - 12 * s, y + 65 * s, 8 * s, 4 * s);
            ctx.fillRect(x + 4 * s, y + 65 * s, 8 * s, 4 * s);

            // G≈Ç√≥wka
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.arc(x, y + 12 * s, 14 * s, 0, Math.PI * 2);
            ctx.fill();

            // Bia≈Çe policzki/pysk
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.ellipse(x, y + 18 * s, 10 * s, 8 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Uszy (tr√≥jkƒÖtne)
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.moveTo(x - 10 * s, y + 5 * s);
            ctx.lineTo(x - 14 * s, y - 8 * s);
            ctx.lineTo(x - 6 * s, y + 2 * s);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x + 10 * s, y + 5 * s);
            ctx.lineTo(x + 14 * s, y - 8 * s);
            ctx.lineTo(x + 6 * s, y + 2 * s);
            ctx.fill();

            // Bia≈Çe ≈õrodki uszu
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.moveTo(x - 10 * s, y + 3 * s);
            ctx.lineTo(x - 12 * s, y - 4 * s);
            ctx.lineTo(x - 8 * s, y + 1 * s);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x + 10 * s, y + 3 * s);
            ctx.lineTo(x + 12 * s, y - 4 * s);
            ctx.lineTo(x + 8 * s, y + 1 * s);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 5 * s, y + 10 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(x + 5 * s, y + 10 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // B≈Çysk w oczach
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 4 * s, y + 9 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.arc(x + 6 * s, y + 9 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y + 17 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie pandy
        function drawPanda(x, y, scale = 1) {
            const s = scale;
            // Cia≈Ço (bia≈Çe)
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.ellipse(x, y + 38 * s, 20 * s, 28 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Czarna ≈Çata na brzuchu
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(x, y + 45 * s, 12 * s, 15 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // ≈Åapy (czarne)
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(x - 18 * s, y + 32 * s, 9 * s, 14 * s, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 18 * s, y + 32 * s, 9 * s, 14 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nogi (czarne)
            ctx.fillStyle = '#000';
            ctx.fillRect(x - 14 * s, y + 60 * s, 11 * s, 12 * s);
            ctx.fillRect(x + 3 * s, y + 60 * s, 11 * s, 12 * s);

            // G≈Ç√≥wka (bia≈Ça)
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x, y + 14 * s, 17 * s, 0, Math.PI * 2);
            ctx.fill();

            // Uszy (czarne, okrƒÖg≈Çe)
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 13 * s, y + 3 * s, 9 * s, 0, Math.PI * 2);
            ctx.arc(x + 13 * s, y + 3 * s, 9 * s, 0, Math.PI * 2);
            ctx.fill();

            // Oczy z czarnymi plamami
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(x - 7 * s, y + 12 * s, 8 * s, 10 * s, -0.2, 0, Math.PI * 2);
            ctx.ellipse(x + 7 * s, y + 12 * s, 8 * s, 10 * s, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Bia≈Çe ga≈Çki oczne
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 7 * s, y + 13 * s, 4 * s, 0, Math.PI * 2);
            ctx.arc(x + 7 * s, y + 13 * s, 4 * s, 0, Math.PI * 2);
            ctx.fill();

            // ≈πrenice
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 6 * s, y + 13 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(x + 8 * s, y + 13 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y + 20 * s, 4 * s, 0, Math.PI * 2);
            ctx.fill();

            // U≈õmiech
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.arc(x, y + 22 * s, 6 * s, 0.2, Math.PI - 0.2);
            ctx.stroke();
        }

        // Rysowanie jednoro≈ºca (siostrzyczka)
        function drawUnicorn(x, y, scale = 1) {
            const s = scale;
            // Ogon (tƒôczowy!)
            const tailGradient = ctx.createLinearGradient(x - 25 * s, y + 30 * s, x - 35 * s, y + 50 * s);
            tailGradient.addColorStop(0, '#FF69B4');
            tailGradient.addColorStop(0.5, '#E0C3FC');
            tailGradient.addColorStop(1, '#87CEEB');
            ctx.strokeStyle = tailGradient;
            ctx.lineWidth = 15 * s;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x - 10 * s, y + 40 * s);
            ctx.quadraticCurveTo(x - 25 * s, y + 35 * s, x - 35 * s, y + 50 * s);
            ctx.stroke();

            // Cia≈Ço
            ctx.fillStyle = '#E0B0FF';
            ctx.beginPath();
            ctx.ellipse(x, y + 38 * s, 20 * s, 28 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek (ja≈õniejszy)
            ctx.fillStyle = '#F0E0FF';
            ctx.beginPath();
            ctx.ellipse(x, y + 42 * s, 14 * s, 20 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nogi
            ctx.fillStyle = '#E0B0FF';
            ctx.fillRect(x - 14 * s, y + 60 * s, 10 * s, 16 * s);
            ctx.fillRect(x + 4 * s, y + 60 * s, 10 * s, 16 * s);

            // Kopytka (z≈Çote)
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(x - 14 * s, y + 72 * s, 10 * s, 4 * s);
            ctx.fillRect(x + 4 * s, y + 72 * s, 10 * s, 4 * s);

            // G≈Ç√≥wka
            ctx.fillStyle = '#E0B0FF';
            ctx.beginPath();
            ctx.arc(x, y + 14 * s, 16 * s, 0, Math.PI * 2);
            ctx.fill();

            // Grzywka (tƒôczowa!)
            const maneGradient = ctx.createLinearGradient(x - 15 * s, y, x + 15 * s, y + 20 * s);
            maneGradient.addColorStop(0, '#FF69B4');
            maneGradient.addColorStop(0.33, '#FFD700');
            maneGradient.addColorStop(0.67, '#87CEEB');
            maneGradient.addColorStop(1, '#E0C3FC');
            ctx.fillStyle = maneGradient;
            ctx.beginPath();
            ctx.arc(x - 12 * s, y + 5 * s, 10 * s, 0, Math.PI * 2);
            ctx.arc(x - 5 * s, y + 2 * s, 10 * s, 0, Math.PI * 2);
            ctx.arc(x + 5 * s, y + 2 * s, 10 * s, 0, Math.PI * 2);
            ctx.arc(x + 12 * s, y + 5 * s, 10 * s, 0, Math.PI * 2);
            ctx.fill();

            // R√≥g (tƒôczowy gradient)
            const hornGradient = ctx.createLinearGradient(x - 2 * s, y - 10 * s, x + 2 * s, y + 10 * s);
            hornGradient.addColorStop(0, '#FFD700');
            hornGradient.addColorStop(0.5, '#FF69B4');
            hornGradient.addColorStop(1, '#E0C3FC');
            ctx.fillStyle = hornGradient;
            ctx.beginPath();
            ctx.moveTo(x, y - 10 * s);
            ctx.lineTo(x - 4 * s, y + 5 * s);
            ctx.lineTo(x + 4 * s, y + 5 * s);
            ctx.fill();

            // Spirala na rogu
            ctx.strokeStyle = '#9370DB';
            ctx.lineWidth = 2 * s;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(x, y - 5 * s + i * 4 * s, 3 * s, 0, Math.PI);
                ctx.stroke();
            }

            // Oczy (du≈ºe, bajkowe)
            ctx.fillStyle = '#8B008B';
            ctx.beginPath();
            ctx.arc(x - 6 * s, y + 13 * s, 4 * s, 0, Math.PI * 2);
            ctx.arc(x + 6 * s, y + 13 * s, 4 * s, 0, Math.PI * 2);
            ctx.fill();

            // B≈Çyski w oczach
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 5 * s, y + 12 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(x + 7 * s, y + 12 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.arc(x, y + 20 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // Gwiazdki wok√≥≈Ç (magiczne!)
            ctx.fillStyle = '#FFD700';
            [[x - 22 * s, y + 10 * s], [x + 22 * s, y + 10 * s], [x, y - 15 * s]].forEach(([sx, sy]) => {
                ctx.beginPath();
                for (let j = 0; j < 5; j++) {
                    const angle = (j * 2 * Math.PI / 5) - Math.PI / 2;
                    const r = j % 2 === 0 ? 4 * s : 2 * s;
                    const px = sx + Math.cos(angle) * r;
                    const py = sy + Math.sin(angle) * r;
                    if (j === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
            });
        }

        // Rysowanie ≈ºabki
        function drawFrog(x, y, scale = 1) {
            const s = scale;
            // Cia≈Ço (zielone)
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.ellipse(x, y + 40 * s, 20 * s, 22 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek (ja≈õniejszy)
            ctx.fillStyle = '#B0FFB0';
            ctx.beginPath();
            ctx.ellipse(x, y + 45 * s, 14 * s, 16 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tylne nogi (du≈ºe, ≈ºabie)
            ctx.fillStyle = '#90EE90';
            // Lewa noga
            ctx.beginPath();
            ctx.ellipse(x - 20 * s, y + 55 * s, 12 * s, 8 * s, -0.5, 0, Math.PI * 2);
            ctx.fill();
            // Stopa lewa
            ctx.beginPath();
            ctx.ellipse(x - 28 * s, y + 62 * s, 10 * s, 6 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Prawa noga
            ctx.beginPath();
            ctx.ellipse(x + 20 * s, y + 55 * s, 12 * s, 8 * s, 0.5, 0, Math.PI * 2);
            ctx.fill();
            // Stopa prawa
            ctx.beginPath();
            ctx.ellipse(x + 28 * s, y + 62 * s, 10 * s, 6 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Palce na stopach
            ctx.fillStyle = '#7FBF7F';
            for (let i = -1; i <= 1; i++) {
                ctx.beginPath();
                ctx.ellipse(x - 28 * s + i * 5 * s, y + 66 * s, 2 * s, 4 * s, 0, 0, Math.PI * 2);
                ctx.ellipse(x + 28 * s + i * 5 * s, y + 66 * s, 2 * s, 4 * s, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Przednie ≈Çapki (ma≈Çe)
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.ellipse(x - 15 * s, y + 38 * s, 6 * s, 10 * s, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 15 * s, y + 38 * s, 6 * s, 10 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // G≈Ç√≥wka (szeroka)
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.ellipse(x, y + 18 * s, 18 * s, 16 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Oczy (wypuk≈Çe!)
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x - 10 * s, y + 12 * s, 8 * s, 0, Math.PI * 2);
            ctx.arc(x + 10 * s, y + 12 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();

            // ≈πrenice
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(x - 10 * s, y + 13 * s, 3 * s, 5 * s, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 10 * s, y + 13 * s, 3 * s, 5 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // B≈Çyski w oczach
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 9 * s, y + 11 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(x + 11 * s, y + 11 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Buzia (szeroki u≈õmiech)
            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.arc(x, y + 22 * s, 12 * s, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // Policzki (r√≥≈ºowe)
            ctx.fillStyle = 'rgba(255, 192, 203, 0.4)';
            ctx.beginPath();
            ctx.arc(x - 16 * s, y + 20 * s, 5 * s, 0, Math.PI * 2);
            ctx.arc(x + 16 * s, y + 20 * s, 5 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie motyla (jako przyjaciel - wiƒôkszy)
        function drawButterflyFriend(x, y, scale = 1) {
            const s = scale;
            // G√≥rne skrzyd≈Ça (du≈ºe, kolorowe)
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.ellipse(x - 18 * s, y + 20 * s, 22 * s, 28 * s, -0.3, 0, Math.PI * 2);
            ctx.ellipse(x + 18 * s, y + 20 * s, 22 * s, 28 * s, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Dolne skrzyd≈Ça
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.ellipse(x - 15 * s, y + 50 * s, 18 * s, 22 * s, -0.2, 0, Math.PI * 2);
            ctx.ellipse(x + 15 * s, y + 50 * s, 18 * s, 22 * s, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Wzory na g√≥rnych skrzyd≈Çach
            ctx.fillStyle = '#FFF';
            [[x - 18 * s, y + 15 * s], [x + 18 * s, y + 15 * s]].forEach(([px, py]) => {
                ctx.beginPath();
                ctx.arc(px, py, 6 * s, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.fillStyle = '#FFD700';
            [[x - 18 * s, y + 28 * s], [x + 18 * s, y + 28 * s]].forEach(([px, py]) => {
                ctx.beginPath();
                ctx.arc(px, py, 5 * s, 0, Math.PI * 2);
                ctx.fill();
            });

            // Wzory na dolnych skrzyd≈Çach
            ctx.fillStyle = '#E0C3FC';
            [[x - 15 * s, y + 50 * s], [x + 15 * s, y + 50 * s]].forEach(([px, py]) => {
                ctx.beginPath();
                ctx.arc(px, py, 4 * s, 0, Math.PI * 2);
                ctx.fill();
            });

            // Cia≈Ço (grube, puszyste)
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - 5 * s, y + 10 * s, 10 * s, 50 * s, 0, 0, Math.PI * 2);

            // G≈Ç√≥wka
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y + 5 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();

            // Oczka
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 3 * s, y + 5 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(x + 3 * s, y + 5 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Czu≈Çki (d≈Çugie, z kulkami)
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.moveTo(x - 4 * s, y);
            ctx.lineTo(x - 10 * s, y - 15 * s);
            ctx.moveTo(x + 4 * s, y);
            ctx.lineTo(x + 10 * s, y - 15 * s);
            ctx.stroke();

            // Kulki na czu≈Çkach
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.arc(x - 10 * s, y - 15 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(x + 10 * s, y - 15 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // B≈Çysk na skrzyd≈Çach (magiczny efekt)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            [[x - 22 * s, y + 12 * s], [x + 22 * s, y + 12 * s]].forEach(([px, py]) => {
                ctx.beginPath();
                ctx.arc(px, py, 4 * s, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Funkcja wyboru rysowania przyjaciela
        function drawFriend(friend, x, y, scale = 1) {
            ctx.save();

            switch(friend.emoji) {
                case 'üê∂':
                    drawDog(x, y, scale);
                    break;
                case 'üê∞':
                    drawRabbit(x, y, scale);
                    break;
                case 'üêª':
                    drawBear(x, y, scale);
                    break;
                case 'üêë':
                    drawSheep(x, y, scale);
                    break;
                case 'üê¨':
                    drawDolphin(x, y, scale);
                    break;
                case 'ü¶ä':
                    drawFox(x, y, scale);
                    break;
                case 'üêº':
                    drawPanda(x, y, scale);
                    break;
                case 'ü¶Ñ':
                    drawUnicorn(x, y, scale);
                    break;
                case 'üê∏':
                    drawFrog(x, y, scale);
                    break;
                case 'ü¶ã':
                    drawButterflyFriend(x, y, scale);
                    break;
                default:
                    // Dla pozosta≈Çych u≈ºyj prostego kszta≈Çtu
                    ctx.fillStyle = friend.color;
                    ctx.beginPath();
                    ctx.ellipse(x, y + 30 * scale, 18 * scale, 25 * scale, 0, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = friend.color;
                    ctx.beginPath();
                    ctx.arc(x, y + 10 * scale, 15 * scale, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(x - 5 * scale, y + 10 * scale, 2 * scale, 0, Math.PI * 2);
                    ctx.arc(x + 5 * scale, y + 10 * scale, 2 * scale, 0, Math.PI * 2);
                    ctx.fill();
            }

            ctx.restore();
        }

        // T≈Ço
        function drawBackground() {
            // Time of day cycle: 1 minute = full day cycle (0..1)
            const elapsed = (Date.now() - gameTimeStart) / 1000; // seconds
            const dayCycle = (elapsed % 60) / 60; // 0..1 over 60 seconds

            // dayCycle phases: 0-0.25 = dawn->day, 0.25-0.5 = day, 0.5-0.75 = dusk, 0.75-1.0 = night
            let skyTop, skyMid, skyBot, sunAlpha, darkness;
            if (dayCycle < 0.2) {
                // Dawn
                const t = dayCycle / 0.2;
                skyTop = lerpColor('#1a1a3e', '#87CEEB', t);
                skyMid = lerpColor('#2d1b4e', '#FFE5F1', t);
                skyBot = lerpColor('#4a2040', '#FFF4E0', t);
                sunAlpha = t;
                darkness = (1 - t) * 0.4;
            } else if (dayCycle < 0.5) {
                // Full day
                skyTop = '#87CEEB';
                skyMid = '#FFE5F1';
                skyBot = '#FFF4E0';
                sunAlpha = 1;
                darkness = 0;
            } else if (dayCycle < 0.7) {
                // Dusk
                const t = (dayCycle - 0.5) / 0.2;
                skyTop = lerpColor('#87CEEB', '#FF6B35', t);
                skyMid = lerpColor('#FFE5F1', '#FF4500', t);
                skyBot = lerpColor('#FFF4E0', '#8B0000', t);
                sunAlpha = 1 - t * 0.5;
                darkness = t * 0.15;
            } else {
                // Night
                const t = Math.min(1, (dayCycle - 0.7) / 0.15);
                skyTop = lerpColor('#FF6B35', '#0a0a2e', t);
                skyMid = lerpColor('#FF4500', '#1a1a3e', t);
                skyBot = lerpColor('#8B0000', '#1a1040', t);
                sunAlpha = Math.max(0, 0.5 - t);
                darkness = 0.15 + t * 0.35;
            }

            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, skyTop);
            gradient.addColorStop(0.6, skyMid);
            gradient.addColorStop(1, skyBot);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Stars (only at night)
            if (darkness > 0.2) {
                const starAlpha = Math.min(1, (darkness - 0.2) * 3);
                ctx.fillStyle = `rgba(255, 255, 220, ${starAlpha})`;
                for (let i = 0; i < 30; i++) {
                    // Deterministic star positions
                    const sx = ((i * 137 + 50) % canvas.width);
                    const sy = ((i * 97 + 20) % (canvas.height * 0.4));
                    const twinkle = Math.sin(elapsed * 2 + i * 0.7) * 0.3 + 0.7;
                    ctx.globalAlpha = starAlpha * twinkle;
                    ctx.beginPath();
                    ctx.arc(sx, sy, 1 + (i % 3) * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                // Moon (at night)
                if (darkness > 0.3) {
                    const moonAlpha = Math.min(1, (darkness - 0.3) * 3);
                    const moonX = canvas.width - 120 - worldOffset * 0.05;
                    ctx.globalAlpha = moonAlpha;
                    ctx.fillStyle = '#FFFDE7';
                    ctx.beginPath();
                    ctx.arc(moonX, 70, 30, 0, Math.PI * 2);
                    ctx.fill();
                    // Crescent shadow
                    ctx.fillStyle = skyTop;
                    ctx.beginPath();
                    ctx.arc(moonX + 10, 65, 25, 0, Math.PI * 2);
                    ctx.fill();
                    // Moon glow
                    const moonGlow = ctx.createRadialGradient(moonX, 70, 20, moonX, 70, 60);
                    moonGlow.addColorStop(0, `rgba(255, 253, 231, ${0.15 * moonAlpha})`);
                    moonGlow.addColorStop(1, 'rgba(255, 253, 231, 0)');
                    ctx.fillStyle = moonGlow;
                    ctx.beginPath();
                    ctx.arc(moonX, 70, 60, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            }

            // Sun (during day, fades at night)
            if (sunAlpha > 0) {
                const sunX = 200 - worldOffset * 0.1;
                // Sun position follows day arc
                const sunArc = Math.sin(dayCycle * Math.PI); // 0 at start/end, 1 at midday
                const sunY = 200 - sunArc * 120;
                if (sunX > -100 && sunX < canvas.width + 100) {
                    ctx.globalAlpha = sunAlpha * 0.6;
                    ctx.fillStyle = '#FFFF66';
                    ctx.beginPath();
                    ctx.arc(sunX, sunY, 60, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = sunAlpha;
                    ctx.fillStyle = '#FFFF00';
                    ctx.beginPath();
                    ctx.arc(sunX, sunY, 50, 0, Math.PI * 2);
                    ctx.fill();
                    // Sunset tint
                    if (dayCycle > 0.5 && dayCycle < 0.75) {
                        ctx.fillStyle = `rgba(255, 100, 0, ${(dayCycle - 0.5) * 2})`;
                        ctx.beginPath();
                        ctx.arc(sunX, sunY, 50, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }
            }

            // Rainbow
            const rainbowX = 600 - worldOffset * 0.2;
            if (rainbowX > -500 && rainbowX < canvas.width + 500) {
                const rainbowColors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
                ctx.globalAlpha = 0.5 * (1 - darkness);
                rainbowColors.forEach((color, i) => {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 12;
                    ctx.beginPath();
                    ctx.arc(rainbowX, canvas.height, 400 - i * 30, Math.PI, 0);
                    ctx.stroke();
                });
                ctx.globalAlpha = 1;
            }

            // Clouds (darker when rainy/night)
            // Rain cycle: every 3 minutes, rain for 30 seconds
            const rainCycle = elapsed % 600; // 10 minutes
            const isRaining = rainCycle > 550; // rain for last 30 seconds of cycle
            const rainIntensity = isRaining ? Math.min(1, (rainCycle - 150) / 5) : 0; // fade in over 5 seconds

            const time = Date.now() / 1000;
            const cloudCount = isRaining ? 6 : 3;
            for (let i = 0; i < cloudCount; i++) {
                const cloudBaseX = 300 + i * (isRaining ? 200 : 400);
                const cloudX = cloudBaseX + (time * 5) - (worldOffset * 0.1);
                const screenCloudX = cloudX % (canvas.width + 200);
                const cloudY = 60 + (i % 3) * 40;

                if (isRaining) {
                    // Dark rain clouds
                    ctx.fillStyle = `rgba(80, 80, 100, ${0.7 + rainIntensity * 0.2})`;
                } else {
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.8 - darkness * 0.4})`;
                }
                ctx.beginPath();
                ctx.arc(screenCloudX, cloudY, 30 + (isRaining ? 10 : 0), 0, Math.PI * 2);
                ctx.arc(screenCloudX + 35, cloudY, 40 + (isRaining ? 10 : 0), 0, Math.PI * 2);
                ctx.arc(screenCloudX + 70, cloudY, 30 + (isRaining ? 10 : 0), 0, Math.PI * 2);
                ctx.fill();
            }

            // Darkness overlay
            if (darkness > 0) {
                ctx.fillStyle = `rgba(0, 0, 20, ${darkness})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Rain overlay
            if (isRaining) {
                // Rain darkening
                ctx.fillStyle = `rgba(30, 30, 50, ${rainIntensity * 0.2})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        function lerpColor(a, b, t) {
            const ah = parseInt(a.replace('#', ''), 16);
            const bh = parseInt(b.replace('#', ''), 16);
            const ar = (ah >> 16) & 0xFF, ag = (ah >> 8) & 0xFF, ab = ah & 0xFF;
            const br = (bh >> 16) & 0xFF, bg = (bh >> 8) & 0xFF, bb = bh & 0xFF;
            const rr = Math.round(ar + (br - ar) * t);
            const rg = Math.round(ag + (bg - ag) * t);
            const rb = Math.round(ab + (bb - ab) * t);
            return `rgb(${rr},${rg},${rb})`;
        }

        function drawRain() {
            const elapsed = (Date.now() - gameTimeStart) / 1000;
            const rainCycle = elapsed % 180;
            const isRaining = rainCycle > 150;
            if (!isRaining) { raindrops = []; return; }

            const rainIntensity = Math.min(1, (rainCycle - 150) / 5);

            // Add new raindrops
            const dropsPerFrame = Math.floor(rainIntensity * 15);
            for (let i = 0; i < dropsPerFrame; i++) {
                raindrops.push({
                    x: Math.random() * (canvas.width + 100) - 50,
                    y: -10 - Math.random() * 20,
                    speed: 8 + Math.random() * 6,
                    length: 10 + Math.random() * 10,
                    opacity: 0.2 + Math.random() * 0.4
                });
            }

            // Draw and update raindrops
            ctx.strokeStyle = 'rgba(150, 180, 255, 0.5)';
            ctx.lineWidth = 1;
            for (let i = raindrops.length - 1; i >= 0; i--) {
                const drop = raindrops[i];
                ctx.globalAlpha = drop.opacity * rainIntensity;
                ctx.beginPath();
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x - 2, drop.y + drop.length);
                ctx.stroke();

                drop.y += drop.speed;
                drop.x -= 1; // slight wind

                // Splash on ground
                if (drop.y > canvas.height - 150) {
                    // Draw splash
                    ctx.fillStyle = 'rgba(150, 180, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(drop.x, canvas.height - 150, 2, 0, Math.PI * 2);
                    ctx.fill();
                    raindrops.splice(i, 1);
                }
            }
            ctx.globalAlpha = 1;

            // Limit raindrop count
            if (raindrops.length > 300) raindrops.splice(0, raindrops.length - 300);
        }

        // Drzewa
        function drawTrees() {
            trees.forEach(tree => {
                const screenX = tree.x - worldOffset;
                if (screenX < -100 || screenX > canvas.width + 100) return;

                // Pie≈Ñ
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(screenX - tree.width/4, tree.y - tree.height, tree.width/2, tree.height);

                // Korona (r√≥≈ºowa/fioletowa candy)
                const crownColors = ['#FF69B4', '#E0C3FC', '#FFB6D9'];
                crownColors.forEach((color, i) => {
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(
                        screenX + (i - 1) * tree.width/4,
                        tree.y - tree.height + 10,
                        tree.width/2,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                });
            });
        }

        // Kwiaty
        function drawFlowers() {
            const time = Date.now() / 1000;
            flowers.forEach(flower => {
                const screenX = flower.x - worldOffset;
                if (screenX < -50 || screenX > canvas.width + 50) return;

                const sway = Math.sin(time + flower.swayOffset) * 2;

                // ≈Åodyga
                ctx.strokeStyle = '#90EE90';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(screenX, flower.y);
                ctx.quadraticCurveTo(screenX + sway, flower.y - flower.size/2, screenX + sway, flower.y - flower.size);
                ctx.stroke();

                // P≈Çatki
                ctx.fillStyle = flower.color;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const px = screenX + sway + Math.cos(angle) * flower.size/3;
                    const py = flower.y - flower.size + Math.sin(angle) * flower.size/3;
                    ctx.beginPath();
                    ctx.arc(px, py, flower.size/4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ≈örodek
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(screenX + sway, flower.y - flower.size, flower.size/5, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Grunt
        function drawGround() {
            ground.forEach(g => {
                const screenX = g.x - worldOffset;
                if (screenX + g.width < -100 || screenX > canvas.width + 100) return;

                // Trawa
                const grassGradient = ctx.createLinearGradient(screenX, g.y, screenX, g.y + g.height);
                grassGradient.addColorStop(0, '#90EE90');
                grassGradient.addColorStop(1, '#228B22');
                ctx.fillStyle = grassGradient;
                ctx.fillRect(screenX, g.y, g.width, g.height);

                // Trawka (detale)
                ctx.strokeStyle = '#7FBF7F';
                ctx.lineWidth = 2;
                for (let i = 0; i < g.width; i += 20) {
                    ctx.beginPath();
                    ctx.moveTo(screenX + i, g.y);
                    ctx.lineTo(screenX + i - 2, g.y - 8);
                    ctx.moveTo(screenX + i, g.y);
                    ctx.lineTo(screenX + i + 2, g.y - 6);
                    ctx.stroke();
                }
            });
        }

        // Cukierki
        function drawCandies() {
            const time = Date.now() / 1000;
            candies.forEach(candy => {
                if (candy.collected) return;

                const screenX = candy.x - worldOffset;
                if (screenX < -50 || screenX > canvas.width + 50) return;

                const bounce = Math.sin(time * 3 + candy.x) * 3;
                const candyTypes = ['üç¨', 'üç≠', 'üç∞', 'üßÅ', 'üç©'];

                ctx.font = '25px Arial';
                ctx.fillText(candyTypes[candy.type], screenX - 12, candy.y + bounce);

                // B≈Çysk
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(screenX, candy.y + bounce - 8, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Rysowanie przedmiot√≥w do zbierania
        function drawItemsToCollect() {
            const time = Date.now() / 1000;
            itemsToCollect.forEach(item => {
                if (item.collected) return;

                const screenX = item.x - worldOffset;
                if (screenX < -70 || screenX > canvas.width + 70) return;

                const bounce = Math.sin(time * 2 + item.x) * 8;
                const y = item.y + bounce;

                // ≈öwiecƒÖca aureola
                ctx.fillStyle = '#FFD700' + '30';
                ctx.beginPath();
                ctx.arc(screenX, y, 35, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#FFD700' + '50';
                ctx.beginPath();
                ctx.arc(screenX, y, 25, 0, Math.PI * 2);
                ctx.fill();

                // Gwiazdki wok√≥≈Ç
                for (let i = 0; i < 3; i++) {
                    const angle = time * 3 + i * (Math.PI * 2 / 3);
                    const sx = screenX + Math.cos(angle) * 30;
                    const sy = y + Math.sin(angle) * 30;

                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    for (let j = 0; j < 5; j++) {
                        const starAngle = (j * 2 * Math.PI / 5) - Math.PI / 2;
                        const r = j % 2 === 0 ? 5 : 2;
                        const px = sx + Math.cos(starAngle) * r;
                        const py = sy + Math.sin(starAngle) * r;
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                // Przedmiot (emoji)
                ctx.font = '40px Arial';
                ctx.fillText(item.item.emoji, screenX - 20, y + 15);

                // Nazwa przedmiotu
                ctx.fillStyle = '#FF1493';
                ctx.font = 'bold 14px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText(item.item.name, screenX, y + 35);
                ctx.textAlign = 'left';
            });
        }

        // Przyjaciele do znalezienia
        function drawFriendsToFind() {
            const time = Date.now() / 1000;
            friendsToFind.forEach(friend => {
                if (friend.found) return;

                const screenX = friend.x - worldOffset;
                if (screenX < -100 || screenX > canvas.width + 100) return;

                const bounce = Math.sin(time * 2 + friend.bounceOffset) * 15;

                // Du≈ºa ≈õwiecƒÖca aureola
                for (let r = 80; r > 20; r -= 12) {
                    ctx.fillStyle = friend.type.color + Math.floor((1 - r/80) * 50).toString(16).padStart(2, '0');
                    ctx.beginPath();
                    ctx.arc(screenX, friend.y + bounce + 20, r, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Rysuj przyjaciela realistycznie
                ctx.save();
                drawFriend(friend.type, screenX, friend.y + bounce, 1);
                ctx.restore();

                // Gwiazdy wok√≥≈Ç (narysowane)
                for (let i = 0; i < 4; i++) {
                    const angle = time * 2 + i * Math.PI / 2;
                    const sx = screenX + Math.cos(angle) * 65;
                    const sy = friend.y + bounce + 20 + Math.sin(angle) * 65;

                    // Gwiazdka rysowana
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    for (let j = 0; j < 5; j++) {
                        const starAngle = (j * 2 * Math.PI / 5) - Math.PI / 2;
                        const r = j % 2 === 0 ? 12 : 5;
                        const px = sx + Math.cos(starAngle) * r;
                        const py = sy + Math.sin(starAngle) * r;
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                // Serduszka (narysowane)
                const drawHeart = (hx, hy) => {
                    ctx.fillStyle = '#FF69B4';
                    ctx.beginPath();
                    ctx.moveTo(hx, hy + 5);
                    ctx.bezierCurveTo(hx, hy, hx - 8, hy - 8, hx - 12, hy - 5);
                    ctx.bezierCurveTo(hx - 16, hy, hx - 16, hy + 5, hx - 16, hy + 8);
                    ctx.bezierCurveTo(hx - 16, hy + 12, hx - 12, hy + 18, hx, hy + 25);
                    ctx.bezierCurveTo(hx + 12, hy + 18, hx + 16, hy + 12, hx + 16, hy + 8);
                    ctx.bezierCurveTo(hx + 16, hy + 5, hx + 16, hy, hx + 12, hy - 5);
                    ctx.bezierCurveTo(hx + 8, hy - 8, hx, hy, hx, hy + 5);
                    ctx.fill();
                };

                drawHeart(screenX - 45, friend.y + bounce - 40);
                drawHeart(screenX + 35, friend.y + bounce - 40);
            });
        }

        // Dekoracje (motyle, ptaszki)
        function drawDecorations() {
            const time = Date.now() / 1000;
            decorations.forEach(deco => {
                const screenX = deco.x - worldOffset * 0.5 + Math.sin(time * deco.speed + deco.phase) * 50;
                const screenY = deco.y + Math.cos(time * deco.speed + deco.phase) * 30;

                if (screenX < -50 || screenX > canvas.width + 50) return;

                ctx.save();
                if (deco.type === 'butterfly') {
                    drawButterfly(screenX, screenY);
                } else {
                    drawBird(screenX, screenY);
                }
                ctx.restore();
            });
        }

        // Rysowanie pszczo≈Çy
        function drawBee(x, y) {
            // Cie≈Ñ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.beginPath();
            ctx.ellipse(x, canvas.height - 95, 12, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Skrzyd≈Ça
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.ellipse(x - 8, y - 5, 8, 12, -0.3, 0, Math.PI * 2);
            ctx.ellipse(x + 8, y - 5, 8, 12, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Cia≈Ço (paski)
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.ellipse(x, y, 10, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Czarne paski
            ctx.fillStyle = '#000';
            ctx.fillRect(x - 10, y - 5, 20, 3);
            ctx.fillRect(x - 10, y + 3, 20, 3);

            // G≈Ç√≥wka
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y - 12, 6, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 2, y - 12, 2, 0, Math.PI * 2);
            ctx.arc(x + 2, y - 12, 2, 0, Math.PI * 2);
            ctx.fill();

            // Czu≈Çki
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x - 3, y - 16);
            ctx.lineTo(x - 6, y - 20);
            ctx.moveTo(x + 3, y - 16);
            ctx.lineTo(x + 6, y - 20);
            ctx.stroke();
        }

        // Rysowanie biedronki
        function drawLadybug(x, y) {
            // Cie≈Ñ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.beginPath();
            ctx.ellipse(x, canvas.height - 95, 10, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Cia≈Ço
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.ellipse(x, y, 12, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Linia ≈õrodkowa
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y - 15);
            ctx.lineTo(x, y + 15);
            ctx.stroke();

            // Kropki
            ctx.fillStyle = '#000';
            const dots = [[-4, -5], [4, -5], [-5, 3], [5, 3], [-3, 10], [3, 10]];
            dots.forEach(([dx, dy]) => {
                ctx.beginPath();
                ctx.arc(x + dx, y + dy, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // G≈Ç√≥wka
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y - 18, 5, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 2, y - 18, 1.5, 0, Math.PI * 2);
            ctx.arc(x + 2, y - 18, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie ptaka
        function drawBird(x, y) {
            // Cie≈Ñ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.beginPath();
            ctx.ellipse(x, canvas.height - 95, 15, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Skrzyd≈Ça
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.ellipse(x - 12, y, 15, 8, -0.5, 0, Math.PI * 2);
            ctx.ellipse(x + 12, y, 15, 8, 0.5, 0, Math.PI * 2);
            ctx.fill();

            // Cia≈Ço
            ctx.fillStyle = '#ADD8E6';
            ctx.beginPath();
            ctx.ellipse(x, y, 12, 18, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek
            ctx.fillStyle = '#E6F3FF';
            ctx.beginPath();
            ctx.ellipse(x, y + 5, 8, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // G≈Ç√≥wka
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.arc(x, y - 15, 8, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 3, y - 15, 2, 0, Math.PI * 2);
            ctx.arc(x + 3, y - 15, 2, 0, Math.PI * 2);
            ctx.fill();

            // Dzi√≥b
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.moveTo(x, y - 13);
            ctx.lineTo(x - 2, y - 10);
            ctx.lineTo(x + 2, y - 10);
            ctx.fill();

            // Ogon
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.moveTo(x, y + 18);
            ctx.lineTo(x - 8, y + 25);
            ctx.lineTo(x + 8, y + 25);
            ctx.fill();
        }

        // Rysowanie motyla
        function drawButterfly(x, y) {
            // Cie≈Ñ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.beginPath();
            ctx.ellipse(x, canvas.height - 95, 12, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // G√≥rne skrzyd≈Ça
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.ellipse(x - 10, y - 8, 12, 15, -0.4, 0, Math.PI * 2);
            ctx.ellipse(x + 10, y - 8, 12, 15, 0.4, 0, Math.PI * 2);
            ctx.fill();

            // Dolne skrzyd≈Ça
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.ellipse(x - 8, y + 8, 10, 12, -0.3, 0, Math.PI * 2);
            ctx.ellipse(x + 8, y + 8, 10, 12, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Wzory na skrzyd≈Çach
            ctx.fillStyle = '#FFF';
            [[x - 10, y - 8], [x + 10, y - 8], [x - 8, y + 8], [x + 8, y + 8]].forEach(([px, py]) => {
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // Cia≈Ço
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - 2, y - 15, 4, 30);

            // G≈Ç√≥wka
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y - 17, 3, 0, Math.PI * 2);
            ctx.fill();

            // Czu≈Çki
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x - 2, y - 18);
            ctx.lineTo(x - 5, y - 22);
            ctx.moveTo(x + 2, y - 18);
            ctx.lineTo(x + 5, y - 22);
            ctx.stroke();

            // Kulki na czu≈Çkach
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 5, y - 22, 1.5, 0, Math.PI * 2);
            ctx.arc(x + 5, y - 22, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie wiewi√≥rki
        function drawSquirrel(x, y) {
            // Puszysty ogon
            ctx.fillStyle = '#D2691E';
            ctx.beginPath();
            ctx.arc(x - 15, y - 20, 18, 0, Math.PI * 2);
            ctx.fill();

            // Cia≈Ço
            ctx.fillStyle = '#CD853F';
            ctx.beginPath();
            ctx.ellipse(x, y, 12, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek
            ctx.fillStyle = '#F4A460';
            ctx.beginPath();
            ctx.ellipse(x, y + 3, 8, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // G≈Ç√≥wka
            ctx.fillStyle = '#CD853F';
            ctx.beginPath();
            ctx.arc(x, y - 12, 8, 0, Math.PI * 2);
            ctx.fill();

            // Uszy
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.moveTo(x - 5, y - 16);
            ctx.lineTo(x - 7, y - 22);
            ctx.lineTo(x - 3, y - 18);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x + 5, y - 16);
            ctx.lineTo(x + 7, y - 22);
            ctx.lineTo(x + 3, y - 18);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 3, y - 12, 2, 0, Math.PI * 2);
            ctx.arc(x + 3, y - 12, 2, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(x, y - 9, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // ≈Åapki
            ctx.fillStyle = '#CD853F';
            ctx.beginPath();
            ctx.ellipse(x - 8, y + 12, 4, 6, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 8, y + 12, 4, 6, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie myszki
        function drawMouse(x, y) {
            // Ogon
            ctx.strokeStyle = '#FFB6D9';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + 10, y);
            ctx.quadraticCurveTo(x + 20, y - 5, x + 25, y + 5);
            ctx.stroke();

            // Cia≈Ço
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.ellipse(x, y, 10, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // G≈Ç√≥wka
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.arc(x - 8, y - 5, 7, 0, Math.PI * 2);
            ctx.fill();

            // Uszy
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.arc(x - 10, y - 10, 5, 0, Math.PI * 2);
            ctx.arc(x - 6, y - 10, 5, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 10, y - 5, 2, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.arc(x - 12, y - 3, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // WƒÖsy
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x - 12, y - 3);
            ctx.lineTo(x - 18, y - 5);
            ctx.moveTo(x - 12, y - 3);
            ctx.lineTo(x - 18, y - 1);
            ctx.stroke();
        }

        // Rysowanie ≈º√≥≈Çwia
        function drawTurtle(x, y) {
            // Skorupa
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.ellipse(x, y - 5, 15, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Wz√≥r na skorupie
            ctx.strokeStyle = '#006400';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - 10, y - 5);
            ctx.lineTo(x + 10, y - 5);
            ctx.moveTo(x, y - 15);
            ctx.lineTo(x - 7, y);
            ctx.moveTo(x, y - 15);
            ctx.lineTo(x + 7, y);
            ctx.stroke();

            // G≈Ç√≥wka
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.arc(x - 12, y - 3, 5, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 13, y - 4, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // ≈Åapki
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.ellipse(x - 10, y + 5, 4, 3, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 10, y + 5, 4, 3, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // Zwierzƒôta mijajƒÖce
        function drawPassingAnimals() {
            const time = Date.now() / 1000;
            passingAnimals.forEach(animal => {
                const screenX = animal.x - worldOffset;
                if (screenX < -100 || screenX > canvas.width + 100) return;

                let displayY = animal.y;

                // Animacja latania (ko≈Çysanie)
                if (animal.flying) {
                    displayY += Math.sin(time * 2 + animal.phase) * 10;
                }

                ctx.save();

                // Odbicie lustrzane gdy idzie w lewo
                if (animal.direction < 0 && !animal.flying) {
                    ctx.translate(screenX, displayY);
                    ctx.scale(-1, 1);
                    ctx.translate(-screenX, -displayY);
                }

                // Rysuj odpowiednie zwierzƒô
                switch(animal.emoji) {
                    case 'üêù':
                        drawBee(screenX, displayY);
                        break;
                    case 'üêû':
                        drawLadybug(screenX, displayY);
                        break;
                    case 'üïäÔ∏è':
                    case 'ü¶Ö':
                    case 'üê¶':
                        drawBird(screenX, displayY);
                        break;
                    case 'ü¶ã':
                        drawButterfly(screenX, displayY);
                        break;
                    case 'üêøÔ∏è':
                        drawSquirrel(screenX, displayY);
                        break;
                    case 'üêÅ':
                        drawMouse(screenX, displayY);
                        break;
                    case 'üê¢':
                        drawTurtle(screenX, displayY);
                        break;
                }

                ctx.restore();

                // Scared indicator when fleeing from fart
                if (animal.scared && animal.scaredTimer > 0) {
                    const bounce = Math.sin(Date.now() / 80) * 4;
                    ctx.font = 'bold 22px Comic Sans MS';
                    ctx.textAlign = 'center';
                    ctx.fillText('üò±', screenX, displayY - 30 + bounce);
                    // Speed lines
                    ctx.strokeStyle = 'rgba(200, 200, 200, 0.5)';
                    ctx.lineWidth = 2;
                    const sDir = animal.scaredDir;
                    for (let sl = 0; sl < 3; sl++) {
                        const lx = screenX - sDir * (15 + sl * 10);
                        const ly = displayY - 5 + sl * 8;
                        ctx.beginPath();
                        ctx.moveTo(lx, ly);
                        ctx.lineTo(lx - sDir * 15, ly);
                        ctx.stroke();
                    }
                }
            });
        }

        // Aktualizacja zwierzƒÖt mijajƒÖcych
        function updatePassingAnimals() {
            passingAnimals.forEach(animal => {
                // Scared by fart - run fast!
                if (animal.scared && animal.scaredTimer > 0) {
                    animal.x += animal.scaredDir * 5;
                    animal.scaredTimer--;
                    if (animal.scaredTimer <= 0) {
                        animal.scared = false;
                    }
                    return;
                }

                animal.x += animal.speed * animal.direction;

                // Odbicie od granic
                if (animal.x <= animal.minX || animal.x >= animal.maxX) {
                    animal.direction *= -1;
                }
            });
        }

        // Parada przyjaci√≥≈Ç
        function drawFollowingFriends() {
            let drawIndex = 0;
            followingFriends.forEach((friend, index) => {
                // Skip P2-controlled friend
                if (player2.active && friend.type.emoji === p2ControlledFriendEmoji) return;
                const histIdx = historyLength * drawIndex + historyLength;
                if (histIdx < playerHistory.length) {
                    const pos = playerHistory[histIdx];
                    if (pos) {
                        const sx = pos.x - worldOffset - 30;
                        const sy = pos.y - 10;
                        const panicY = friend.fartPanic ? friend.fartPanic.jumpOffset : 0;
                        drawFriend(friend.type, sx, sy + panicY, 0.9);

                        // Panic indicators
                        if (friend.fartPanic && friend.fartPanic.timer > 0) {
                            const bounce = Math.sin(Date.now() / 80) * 4;
                            ctx.font = 'bold 24px Comic Sans MS';
                            ctx.textAlign = 'center';
                            ctx.fillText('üò±', sx, sy + panicY - 35 + bounce);
                            // Green stink around
                            ctx.save();
                            ctx.globalAlpha = 0.25;
                            const sg = ctx.createRadialGradient(sx, sy + panicY, 0, sx, sy + panicY, 35);
                            sg.addColorStop(0, 'rgba(100, 180, 50, 0.4)');
                            sg.addColorStop(1, 'rgba(100, 180, 50, 0)');
                            ctx.fillStyle = sg;
                            ctx.beginPath();
                            ctx.arc(sx, sy + panicY, 35, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    }
                }
                drawIndex++;
            });
        }

        // Update
        function updatePlayer() {
            // Update slide animation
            if (slideState.active && slideState.sliding) {
                slideState.slideProgress += 0.025;
                if (slideState.slideProgress >= 1) {
                    // Finished sliding - return to normal
                    slideState.active = false;
                    slideState.sliding = false;
                    slideState.slideProgress = 0;
                    slideState.climbStep = 0;
                    // Position player at bottom of slide
                    houses.forEach(house => {
                        if (Math.abs(slideState.slideHouseX - house.x) < 10) {
                            player.x = house.x + house.width + 80 + 35 + 100 + 30;
                        }
                    });
                }
                return; // Don't move while on slide
            }
            if (slideState.active) return; // Climbing - don't move

            let moving = false;

            if (keys['ArrowLeft']) {
                player.x -= player.speed;
                player.facingRight = false;
                moving = true;
            }
            if (keys['ArrowRight']) {
                player.x += player.speed;
                player.facingRight = true;
                moving = true;
            }

            // Opcjonalne skakanie
            if ((keys[' '] || keys['ArrowUp']) && !player.jumping) {
                player.velY = player.jumpPower;
                player.jumping = true;
            }

            // Grawitacja (≈Çagodna)
            if (player.jumping) {
                player.velY += player.gravity;
                player.y += player.velY;

                // LƒÖdowanie
                const groundY = canvas.height - 150;
                if (player.y >= groundY) {
                    player.y = groundY;
                    player.velY = 0;
                    player.jumping = false;
                }
            }

            // Animacja chodzenia + licznik krok√≥w
            if (moving) {
                player.walkCycle += 0.2;
                catStepCounter++;
                if (catStepCounter % 50 === 0) {
                    // Co 50 krok√≥w rosnƒÖ potrzeby
                    catNeeds.hunger = Math.min(100, catNeeds.hunger + 8);
                    catNeeds.sleep = Math.min(100, catNeeds.sleep + 5);
                    catNeeds.toilet = Math.min(100, catNeeds.toilet + 10);
                    catNeeds.hygiene = Math.min(100, catNeeds.hygiene + 6);
                }
            }

            // Kamera
            const targetOffset = player.x - canvas.width / 3;
            worldOffset += (targetOffset - worldOffset) * 0.08;

            // Generuj chunki
            const currentChunk = Math.floor(player.x / chunkSize);
            for (let i = currentChunk - 1; i <= currentChunk + 2; i++) {
                generateChunk(i);
            }

            // Historia
            playerHistory.unshift({ x: player.x, y: player.y });
            if (playerHistory.length > historyLength * (followingFriends.length + 2)) {
                playerHistory.pop();
            }

            // Pozycja
            if (player.x > furthestPosition) {
                furthestPosition = player.x;
                document.getElementById('position').textContent = Math.floor(furthestPosition / 100);
            }

            // Nastr√≥j
            const moods = ['Miau! üò∫', 'Mrrr üíï', 'Purr~ ‚ú®', 'Miuu üåà'];
            if (animationFrame % 180 === 0) {
                document.getElementById('mood').textContent = moods[Math.floor(Math.random() * moods.length)];
            }
        }

        // ========== PLAYER 2 (CO-OP) WORLD ==========

        function handleP2CycleAnimal() {
            if (gameState === 'battle') return;

            if (gameState === 'world') {
                if (followingFriends.length === 0) return;
                if (!player2.active) {
                    // Activate P2 with first friend
                    player2.active = true;
                    player2.selectedIndex = 0;
                    player2.selectedType = followingFriends[0].type;
                    p2ControlledFriendEmoji = followingFriends[0].type.emoji;
                    // Initialize position from friend's history position
                    const pos = playerHistory[followingFriends[0].historyIndex];
                    if (pos) {
                        player2.worldX = pos.x;
                        player2.worldY = pos.y;
                    } else {
                        player2.worldX = player.x - 60;
                        player2.worldY = player.y;
                    }
                    player2.velY = 0;
                    player2.jumping = false;
                } else {
                    // Cycle to next friend
                    player2.selectedIndex++;
                    if (player2.selectedIndex >= followingFriends.length) {
                        // Past last friend ‚Äî deactivate P2
                        player2.active = false;
                        player2.selectedIndex = -1;
                        player2.selectedType = null;
                        p2ControlledFriendEmoji = null;
                    } else {
                        player2.selectedType = followingFriends[player2.selectedIndex].type;
                        p2ControlledFriendEmoji = followingFriends[player2.selectedIndex].type.emoji;
                        const pos = playerHistory[followingFriends[player2.selectedIndex].historyIndex];
                        if (pos) {
                            player2.worldX = pos.x;
                            player2.worldY = pos.y;
                        } else {
                            player2.worldX = player.x - 60;
                            player2.worldY = player.y;
                        }
                        player2.velY = 0;
                        player2.jumping = false;
                    }
                }
            } else if (gameState === 'interior') {
                if (interiorFriends.length === 0) return;
                if (!player2.active) {
                    // Activate P2 with first interior friend
                    player2.active = true;
                    player2.selectedIndex = 0;
                    player2.selectedType = interiorFriends[0].type;
                    p2ControlledFriendEmoji = interiorFriends[0].type.emoji;
                    player2.interiorX = interiorFriends[0].x;
                    player2.interiorY = interiorFriends[0].y;
                    player2.interiorAction = 'none';
                    player2.interiorActionTimer = 0;
                    // Cancel AI activity
                    interiorFriends[0].activity = 'p2_controlled';
                    interiorFriends[0].furnitureTarget = null;
                } else {
                    // Find current controlled friend and release it
                    for (const f of interiorFriends) {
                        if (f.type.emoji === p2ControlledFriendEmoji) {
                            f.activity = 'walking';
                            f.activityTimer = 50 + Math.floor(Math.random() * 50);
                            f.velX = (Math.random() - 0.5) * 3;
                            break;
                        }
                    }
                    // Cycle to next interior friend
                    let currentIdx = interiorFriends.findIndex(f => f.type.emoji === p2ControlledFriendEmoji);
                    let nextIdx = currentIdx + 1;
                    if (nextIdx >= interiorFriends.length) {
                        // Past last ‚Äî deactivate
                        player2.active = false;
                        player2.selectedIndex = -1;
                        player2.selectedType = null;
                        p2ControlledFriendEmoji = null;
                        player2.interiorAction = 'none';
                    } else {
                        player2.selectedIndex = nextIdx;
                        player2.selectedType = interiorFriends[nextIdx].type;
                        p2ControlledFriendEmoji = interiorFriends[nextIdx].type.emoji;
                        player2.interiorX = interiorFriends[nextIdx].x;
                        player2.interiorY = interiorFriends[nextIdx].y;
                        player2.interiorAction = 'none';
                        player2.interiorActionTimer = 0;
                        interiorFriends[nextIdx].activity = 'p2_controlled';
                        interiorFriends[nextIdx].furnitureTarget = null;
                    }
                }
            }
        }

        function updatePlayer2World() {
            if (!player2.active || gameState !== 'world') return;

            // Re-verify selectedIndex by emoji (handles index shifts from new rescues)
            const idx = followingFriends.findIndex(f => f.type.emoji === p2ControlledFriendEmoji);
            if (idx === -1) {
                // Friend no longer in parade ‚Äî deactivate P2
                player2.active = false;
                player2.selectedIndex = -1;
                player2.selectedType = null;
                p2ControlledFriendEmoji = null;
                return;
            }
            player2.selectedIndex = idx;

            let moving = false;

            if (keys['a'] || keys['A']) {
                player2.worldX -= player2.speed;
                player2.facingRight = false;
                moving = true;
            }
            if (keys['d'] || keys['D']) {
                player2.worldX += player2.speed;
                player2.facingRight = true;
                moving = true;
            }

            // Jump
            if ((keys['w'] || keys['W']) && !player2.jumping) {
                player2.velY = player2.jumpPower;
                player2.jumping = true;
            }

            // Gravity
            if (player2.jumping) {
                player2.velY += player2.gravity;
                player2.worldY += player2.velY;
                const groundY = canvas.height - 150;
                if (player2.worldY >= groundY) {
                    player2.worldY = groundY;
                    player2.velY = 0;
                    player2.jumping = false;
                }
            }

            // Walk animation
            if (moving) {
                player2.walkCycle += 0.2;
            }

            // Pull-along: teleport if off-screen left
            const screenX = player2.worldX - worldOffset;
            if (screenX < -50) {
                player2.worldX = worldOffset - 30;
            }

            // Prevent going too far right of P1
            if (player2.worldX > player.x + canvas.width) {
                player2.worldX = player.x + canvas.width;
            }
        }

        function drawPlayer2World() {
            if (!player2.active || gameState !== 'world') return;

            const screenX = player2.worldX - worldOffset;
            const screenY = player2.worldY;

            ctx.save();
            ctx.translate(screenX, screenY);
            if (!player2.facingRight) ctx.scale(-1, 1);
            drawFriend(player2.selectedType, 0, 0, 0.9);
            ctx.restore();

            // P2 badge
            ctx.save();
            ctx.fillStyle = 'rgba(70, 130, 230, 0.85)';
            ctx.beginPath();
            ctx.roundRect(screenX - 14, screenY - 45, 28, 16, 6);
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 10px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('P2', screenX, screenY - 33);
            ctx.restore();
        }

        // Zbieranie
        function checkCollectibles() {
            candies.forEach(candy => {
                if (!candy.collected &&
                    Math.abs(player.x - candy.x) < 40 &&
                    Math.abs(player.y - candy.y) < 50) {
                    candy.collected = true;
                    score++;
                    document.getElementById('score').textContent = score;
                }
            });

            // Przedmioty kupuje siƒô teraz w sklepie

            // Check special building door collisions FIRST (higher priority)
            let enteredHouse = false;
            kindergartens.forEach(kg => {
                const kgDoorX = kg.x + 150;
                const horizontalDistance = Math.abs(player.x - kgDoorX);
                if (horizontalDistance < 100 && keys[' '] && !enteredHouse && !slideState.active) {
                    enterKindergarten();
                    enteredHouse = true;
                }
            });
            if (!enteredHouse) {
                offices.forEach(ofc => {
                    const ofcDoorX = ofc.x + 140;
                    const horizontalDistance = Math.abs(player.x - ofcDoorX);
                    if (horizontalDistance < 100 && keys[' '] && !enteredHouse && !slideState.active) {
                        enterOffice();
                        enteredHouse = true;
                    }
                });
            }
            if (!enteredHouse) {
                shops.forEach(shop => {
                    const shopDoorX = shop.x + 135;
                    const horizontalDistance = Math.abs(player.x - shopDoorX);
                    if (horizontalDistance < 100 && keys[' '] && !enteredHouse && !slideState.active) {
                        enterShop();
                        enteredHouse = true;
                    }
                });
            }

            if (!enteredHouse) {
                hairdressers.forEach(hd => {
                    const hdDoorX = hd.x + 140;
                    const horizontalDistance = Math.abs(player.x - hdDoorX);
                    if (horizontalDistance < 100 && keys[' '] && !enteredHouse && !slideState.active) {
                        enterHairdresser();
                        enteredHouse = true;
                    }
                });
            }

            if (!enteredHouse) {
                hospitals.forEach(hosp => {
                    const hospDoorX = hosp.x + 140;
                    const horizontalDistance = Math.abs(player.x - hospDoorX);
                    if (horizontalDistance < 100 && keys[' '] && !enteredHouse && !slideState.active) {
                        enterHospital();
                        enteredHouse = true;
                    }
                });
            }

            if (!enteredHouse) {
                playgrounds.forEach(pg => {
                    const pgDoorX = pg.x + pg.width / 2;
                    const horizontalDistance = Math.abs(player.x - pgDoorX);
                    if (horizontalDistance < 100 && keys[' '] && !enteredHouse && !slideState.active) {
                        enterPlayground();
                        enteredHouse = true;
                    }
                });
            }

            // Check house door collision (SPACJA to enter) and slide
            if (!enteredHouse) {
                houses.forEach(house => {
                    // Slide interaction
                    const slideInteractX = house.x + house.width + 87;
                    const slideDist = Math.abs(player.x - slideInteractX);
                    if (slideDist < 60 && keys[' '] && !slideState.active && !enteredHouse) {
                        slideState.active = true;
                        slideState.climbStep = 0;
                        slideState.sliding = false;
                        slideState.slideProgress = 0;
                        slideState.slideHouseX = house.x;
                        keys[' '] = false; // Consume key
                        enteredHouse = true;
                        return;
                    }

                    const houseDoorX = house.x + 125;
                    const horizontalDistance = Math.abs(player.x - houseDoorX);

                    if (horizontalDistance < 150 && keys[' '] && !enteredHouse && !slideState.active) {
                        enterHouse();
                        enteredHouse = true;
                    }
                });
            }

            // Check hycel collision (only if didn't enter house)
            if (!enteredHouse) {
                hycels.forEach(hycel => {
                    if (!hycel.defeated) {
                        const distance = Math.sqrt(
                            Math.pow(player.x - hycel.x, 2) +
                            Math.pow(player.y - hycel.y, 2)
                        );

                        if (distance < 150 && keys[' ']) {
                            startBattle(hycel);
                        }
                    }
                });
            }

            friendsToFind.forEach(friend => {
                if (!friend.found &&
                    Math.abs(player.x - friend.x) < 70 &&
                    Math.abs(player.y - friend.y) < 70) {

                    // Check if friend has an active hycel guarding them
                    if (friend.hasHycel) {
                        const friendHycel = hycels.find(h => h.friendIndex === friendsToFind.indexOf(friend));
                        if (friendHycel && !friendHycel.defeated) {
                            // Show friend's cry for help
                            dialogBubbles.push({
                                x: friend.x,
                                y: friend.y,
                                followTarget: friend,
                                text: 'üò± Hycel mnie strze≈ºe! Pom√≥≈º mi!',
                                fromLeft: false,
                                startTime: Date.now(),
                                duration: 2500
                            });
                            return; // Don't collect friend yet
                        }
                    }

                    friend.found = true;

                    // Dodaj chmurki dialogowe (r√≥≈ºnorodne rozmowy!)
                    const conversations = [
                        ['Piƒôkny dzie≈Ñ, prawda? üåû', 'O tak! Idealna pogoda!'],
                        ['Widzia≈Çe≈õ te chmurki? ‚òÅÔ∏è', 'Tak! Takie puszyste!'],
                        ['Uwielbiam cukierki! üç¨', 'Ja te≈º! SƒÖ przepyszne!'],
                        ['DokƒÖd idziesz? üó∫Ô∏è', 'Na przygodƒô! Idziesz?'],
                        ['Co za piƒôkna tƒôcza! üåà', 'Magiczna, prawda?'],
                        ['Hej! Zgubi≈Çe≈õ siƒô? üíï', 'Nie! Zwiedzam ≈õwiat!'],
                        ['≈Åadny masz r√≥g! ‚ú®', 'Dziƒôkujƒô! Jeste≈õ super!'],
                        ['Trawa jest taka zielona! üå±', 'I kwiaty ≈õliczne!'],
                        ['S≈Çyszysz ptaki? üê¶', 'Tak! ≈öpiewajƒÖ piƒôknie!'],
                        ['Witaj przyjacielu! üíñ', 'Witaj! Idƒô z TobƒÖ!'],
                        ['Lubisz przygody? üéí', 'Uwielbiam! Chod≈∫my!'],
                        ['Jestem trochƒô g≈Çodny... üç∞', 'Poszukajmy cukierk√≥w!'],
                        ['Wieje dzi≈õ wiatr! üí®', 'Ale przyjemnie!'],
                        ['S≈Ço≈Ñce tak grzeje! ‚òÄÔ∏è', 'Cudownie ciep≈Ço!'],
                        ['Co tam za g√≥rkƒÖ? üèîÔ∏è', 'Sprawd≈∫my razem!'],
                        ['Nie boisz siƒô? üòä', 'Z TobƒÖ siƒô nie bojƒô!'],
                        ['Miau! Hej tam! üò∫', 'Cze≈õƒá kiciusiu!'],
                        ['To bƒôdzie super! üéâ', 'Najlepsza przygoda!'],
                        ['Gdzie sƒÖ inni? üë•', 'Razem ich znajdziemy!'],
                        ['Jest tak kolorowo! üé®', 'Jak w bajce!']
                    ];
                    const randomConversation = conversations[Math.floor(Math.random() * conversations.length)];

                    // Mapowanie emoji na typy d≈∫wiƒôk√≥w
                    const soundMap = {
                        'üê∂': 'dog',
                        'üê∞': 'rabbit',
                        'üêª': 'bear',
                        'üêë': 'sheep',
                        'üê¨': 'dolphin',
                        'ü¶ä': 'fox',
                        'üêº': 'panda',
                        'ü¶Ñ': 'unicorn',
                        'üê∏': 'frog',
                        'ü¶ã': 'butterfly'
                    };

                    // Chmurka Kicioro≈ºka
                    playAnimalSound('cat'); // Miauczenie!
                    dialogBubbles.push({
                        x: player.x,
                        y: player.y,
                        followTarget: player,
                        text: randomConversation[0],
                        fromLeft: true,
                        startTime: Date.now(),
                        duration: 3500
                    });

                    // Chmurka przyjaciela (pojawia siƒô po chwili)
                    setTimeout(() => {
                        const friendSoundType = soundMap[friend.type.emoji] || 'dog';
                        playAnimalSound(friendSoundType); // D≈∫wiƒôk przyjaciela!
                        dialogBubbles.push({
                            x: friend.x,
                            y: friend.y,
                            text: randomConversation[1],
                            fromLeft: false,
                            startTime: Date.now(),
                            duration: 3500
                        });
                    }, 1000);

                    followingFriends.push({
                        type: friend.type,
                        historyIndex: historyLength * followingFriends.length + historyLength
                    });

                    updateFriendsList();
                }
            });
        }

        function updateFriendsList() {
            const list = document.getElementById('friends-list');
            if (followingFriends.length === 0) {
                list.textContent = '(czeka na przyjaci√≥≈Ç)';
            } else {
                list.innerHTML = followingFriends.map(f => f.type.emoji).join(' ') +
                    `<br><small style="font-size: 0.7em;">${followingFriends.length}</small>`;
            }
        }

        // Aktualizacja garderoby
        function updateWardrobe() {
            // Rogi
            const hornItems = document.getElementById('horn-items');
            hornItems.innerHTML = '';
            collectedItems.horns.forEach(hornId => {
                const horn = itemDefinitions.horns.find(h => h.id === hornId);
                const div = document.createElement('div');
                div.className = 'wardrobe-item' + (player.equippedHorn === hornId ? ' equipped' : '');
                div.textContent = horn.emoji;
                div.title = horn.name;
                div.onclick = () => equipItem('horn', hornId);
                hornItems.appendChild(div);
            });

            // Ubranka
            const outfitItems = document.getElementById('outfit-items');
            outfitItems.innerHTML = '';
            // Opcja "Bez ubranka"
            const noneOutfit = document.createElement('div');
            noneOutfit.className = 'wardrobe-item' + (player.equippedOutfit === null ? ' equipped' : '');
            noneOutfit.textContent = 'üö´';
            noneOutfit.title = 'Bez ubranka';
            noneOutfit.onclick = () => equipItem('outfit', null);
            outfitItems.appendChild(noneOutfit);

            collectedItems.outfits.forEach(outfitId => {
                const outfit = itemDefinitions.outfits.find(o => o.id === outfitId);
                const div = document.createElement('div');
                div.className = 'wardrobe-item' + (player.equippedOutfit === outfitId ? ' equipped' : '');
                div.textContent = outfit.emoji;
                div.title = outfit.name;
                div.onclick = () => equipItem('outfit', outfitId);
                outfitItems.appendChild(div);
            });

            // Akcesoria
            const accessoryItems = document.getElementById('accessory-items');
            accessoryItems.innerHTML = '';
            // Opcja "Bez akcesorium"
            const noneAccessory = document.createElement('div');
            noneAccessory.className = 'wardrobe-item' + (player.equippedAccessory === null ? ' equipped' : '');
            noneAccessory.textContent = 'üö´';
            noneAccessory.title = 'Bez akcesorium';
            noneAccessory.onclick = () => equipItem('accessory', null);
            accessoryItems.appendChild(noneAccessory);

            collectedItems.accessories.forEach(accessoryId => {
                const accessory = itemDefinitions.accessories.find(a => a.id === accessoryId);
                const div = document.createElement('div');
                div.className = 'wardrobe-item' + (player.equippedAccessory === accessoryId ? ' equipped' : '');
                div.textContent = accessory.emoji;
                div.title = accessory.name;
                div.onclick = () => equipItem('accessory', accessoryId);
                accessoryItems.appendChild(div);
            });

            // Kolory
            const colorItems = document.getElementById('color-items');
            colorItems.innerHTML = '';
            collectedItems.colors.forEach(colorId => {
                const colorDef = itemDefinitions.colors.find(c => c.id === colorId);
                const div = document.createElement('div');
                div.className = 'wardrobe-item' + (player.equippedColor === colorId ? ' equipped' : '');
                div.textContent = colorDef.emoji;
                div.title = colorDef.name;
                div.style.backgroundColor = colorDef.bodyColor;
                div.onclick = () => equipItem('color', colorId);
                colorItems.appendChild(div);
            });

            // Fryzury
            const hairstyleItems = document.getElementById('hairstyle-items');
            if (hairstyleItems) {
                hairstyleItems.innerHTML = '';
                const noneHair = document.createElement('div');
                noneHair.className = 'wardrobe-item' + (player.equippedHairstyle === null ? ' equipped' : '');
                noneHair.textContent = 'üö´';
                noneHair.title = 'Bez fryzury';
                noneHair.onclick = () => equipItem('hairstyle', null);
                hairstyleItems.appendChild(noneHair);
                collectedItems.hairstyles.forEach(hsId => {
                    const hs = itemDefinitions.hairstyles.find(h => h.id === hsId);
                    const div = document.createElement('div');
                    div.className = 'wardrobe-item' + (player.equippedHairstyle === hsId ? ' equipped' : '');
                    div.textContent = hs.emoji;
                    div.title = hs.name;
                    div.onclick = () => equipItem('hairstyle', hsId);
                    hairstyleItems.appendChild(div);
                });
            }

            // Kolory w≈Ços√≥w
            const hairColorItems = document.getElementById('haircolor-items');
            if (hairColorItems) {
                hairColorItems.innerHTML = '';
                const noneHC = document.createElement('div');
                noneHC.className = 'wardrobe-item' + (player.equippedHairColor === null ? ' equipped' : '');
                noneHC.textContent = 'üö´';
                noneHC.title = 'Bez koloru';
                noneHC.onclick = () => equipItem('hairColor', null);
                hairColorItems.appendChild(noneHC);
                collectedItems.hairColors.forEach(hcId => {
                    const hc = itemDefinitions.hairColors.find(c => c.id === hcId);
                    const div = document.createElement('div');
                    div.className = 'wardrobe-item' + (player.equippedHairColor === hcId ? ' equipped' : '');
                    div.textContent = hc.emoji;
                    div.title = hc.name;
                    div.onclick = () => equipItem('hairColor', hcId);
                    hairColorItems.appendChild(div);
                });
            }

            // Spinki
            const hairClipItems = document.getElementById('hairclip-items');
            if (hairClipItems) {
                hairClipItems.innerHTML = '';
                const noneClip = document.createElement('div');
                noneClip.className = 'wardrobe-item' + (player.equippedHairClip === null ? ' equipped' : '');
                noneClip.textContent = 'üö´';
                noneClip.title = 'Bez spinki';
                noneClip.onclick = () => equipItem('hairClip', null);
                hairClipItems.appendChild(noneClip);
                collectedItems.hairClips.forEach(clipId => {
                    const clip = itemDefinitions.hairClips.find(c => c.id === clipId);
                    const div = document.createElement('div');
                    div.className = 'wardrobe-item' + (player.equippedHairClip === clipId ? ' equipped' : '');
                    div.textContent = clip.emoji;
                    div.title = clip.name;
                    div.onclick = () => equipItem('hairClip', clipId);
                    hairClipItems.appendChild(div);
                });
            }
        }

        function addCoins(amount) {
            coins += amount;
            document.getElementById('coins').textContent = coins;
        }

        // Zak≈Çadanie przedmiotu
        function equipItem(type, itemId) {
            if (type === 'horn') {
                player.equippedHorn = itemId;
            } else if (type === 'outfit') {
                player.equippedOutfit = itemId;
            } else if (type === 'accessory') {
                player.equippedAccessory = itemId;
            } else if (type === 'color') {
                player.equippedColor = itemId;
            } else if (type === 'hairstyle') {
                player.equippedHairstyle = itemId;
            } else if (type === 'hairColor') {
                player.equippedHairColor = itemId;
            } else if (type === 'hairClip') {
                player.equippedHairClip = itemId;
            }
            updateWardrobe();
        }

        // ========== HOUSE SYSTEM ==========

        function drawHouses() {
            const groundY = canvas.height - 100;

            houses.forEach(house => {
                const screenX = house.x - worldOffset;
                const screenY = groundY - house.height; // On ground level

                if (screenX < -300 || screenX > canvas.width + 100) return;

                ctx.save();

            // House body (light blue)
            ctx.fillStyle = '#ADD8E6';
            ctx.fillRect(screenX, screenY, house.width, house.height);

            // Roof (rainbow gradient)
            const roofGradient = ctx.createLinearGradient(screenX, screenY - 80, screenX + house.width, screenY);
            roofGradient.addColorStop(0, '#FF0000');
            roofGradient.addColorStop(0.2, '#FF7F00');
            roofGradient.addColorStop(0.4, '#FFFF00');
            roofGradient.addColorStop(0.6, '#00FF00');
            roofGradient.addColorStop(0.8, '#0000FF');
            roofGradient.addColorStop(1, '#8B00FF');
            ctx.fillStyle = roofGradient;
            ctx.beginPath();
            ctx.moveTo(screenX - 30, screenY);
            ctx.lineTo(screenX + house.width / 2, screenY - 80);
            ctx.lineTo(screenX + house.width + 30, screenY);
            ctx.closePath();
            ctx.fill();

            // Windows
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(screenX + 40, screenY + 50, 50, 50);
            ctx.fillRect(screenX + 160, screenY + 50, 50, 50);

            // Window crosses (purple)
            ctx.strokeStyle = '#8B00FF';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(screenX + 65, screenY + 50);
            ctx.lineTo(screenX + 65, screenY + 100);
            ctx.moveTo(screenX + 40, screenY + 75);
            ctx.lineTo(screenX + 90, screenY + 75);
            ctx.moveTo(screenX + 185, screenY + 50);
            ctx.lineTo(screenX + 185, screenY + 100);
            ctx.moveTo(screenX + 160, screenY + 75);
            ctx.lineTo(screenX + 210, screenY + 75);
            ctx.stroke();

            // Door (purple)
            ctx.fillStyle = '#8B00FF';
            ctx.fillRect(screenX + 95, screenY + 120, 60, 80);

            // Door knob (gold)
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(screenX + 135, screenY + 160, 5, 0, Math.PI * 2);
            ctx.fill();

            // ===== SLIDE behind the house =====
            const slideX = screenX + house.width + 80; // Right side of house, well separated
            const slideTopY = screenY + 20; // Top of slide platform
            const slideBottomY = groundY; // Bottom of slide
            const slideW = 100; // Horizontal length of slide
            const slideH = slideBottomY - slideTopY;
            const platformW = 35;
            const platformH = slideH;

            // Ladder (vertical, left side) - Violet with light blue dots
            ctx.strokeStyle = '#8B008B'; // Violet
            ctx.lineWidth = 4;
            // Left rail
            ctx.beginPath();
            ctx.moveTo(slideX, slideBottomY);
            ctx.lineTo(slideX, slideTopY);
            ctx.stroke();
            // Right rail
            ctx.beginPath();
            ctx.moveTo(slideX + 15, slideBottomY);
            ctx.lineTo(slideX + 15, slideTopY);
            ctx.stroke();
            // Rungs
            ctx.lineWidth = 3;
            const rungCount = 6;
            for (let r = 0; r < rungCount; r++) {
                const ry = slideTopY + (slideH / rungCount) * (r + 0.5);
                ctx.beginPath();
                ctx.moveTo(slideX, ry);
                ctx.lineTo(slideX + 15, ry);
                ctx.stroke();
            }
            // Light blue dots on ladder
            ctx.fillStyle = '#ADD8E6'; // Light blue
            for (let r = 0; r < rungCount; r++) {
                const ry = slideTopY + (slideH / rungCount) * (r + 0.5);
                // Dot on left rail
                ctx.beginPath();
                ctx.arc(slideX - 3, ry, 3, 0, Math.PI * 2);
                ctx.fill();
                // Dot on right rail
                ctx.beginPath();
                ctx.arc(slideX + 18, ry, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Platform at top - rainbow themed
            const platformGrad = ctx.createLinearGradient(slideX - 5, slideTopY - 5, slideX - 5, slideTopY + 3);
            platformGrad.addColorStop(0, '#FF6B6B');
            platformGrad.addColorStop(0.5, '#9370DB');
            platformGrad.addColorStop(1, '#8B008B');
            ctx.fillStyle = platformGrad;
            ctx.fillRect(slideX - 5, slideTopY - 5, platformW + 10, 8);
            ctx.fillStyle = '#4B0082';
            ctx.fillRect(slideX - 5, slideTopY - 5, platformW + 10, 3);

            // Slide surface (diagonal from platform to ground) - Rainbow!
            const slideStartX = slideX + platformW;
            const slideEndX = slideStartX + slideW;
            
            // Create rainbow gradient for slide
            const rainbowGradient = ctx.createLinearGradient(slideStartX, slideTopY, slideEndX + 15, slideBottomY);
            rainbowGradient.addColorStop(0, '#FF0000');    // Red
            rainbowGradient.addColorStop(0.17, '#FF7F00'); // Orange
            rainbowGradient.addColorStop(0.33, '#FFFF00'); // Yellow
            rainbowGradient.addColorStop(0.5, '#00FF00');  // Green
            rainbowGradient.addColorStop(0.67, '#0000FF'); // Blue
            rainbowGradient.addColorStop(0.84, '#4B0082'); // Indigo
            rainbowGradient.addColorStop(1, '#9400D3');    // Violet
            
            ctx.fillStyle = rainbowGradient;
            ctx.beginPath();
            ctx.moveTo(slideStartX, slideTopY);
            ctx.lineTo(slideEndX + 15, slideBottomY - 5);
            ctx.lineTo(slideEndX + 15, slideBottomY);
            ctx.lineTo(slideStartX, slideTopY + 5);
            ctx.closePath();
            ctx.fill();
            
            // Slide edge highlights (white for rainbow effect)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(slideStartX, slideTopY);
            ctx.lineTo(slideEndX + 15, slideBottomY - 5);
            ctx.stroke();
            
            // Slide rails
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(slideStartX - 2, slideTopY - 5);
            ctx.lineTo(slideEndX + 13, slideBottomY - 10);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(slideStartX, slideTopY + 8);
            ctx.lineTo(slideEndX + 17, slideBottomY + 3);
            ctx.stroke();

            // Bottom curve
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(slideEndX + 15, slideBottomY - 5);
            ctx.quadraticCurveTo(slideEndX + 25, slideBottomY + 5, slideEndX + 30, slideBottomY);
            ctx.stroke();

            // Draw player on slide if active for this house
            if (slideState.active && Math.abs(slideState.slideHouseX - house.x) < 10) {
                let playerSlideX, playerSlideY;
                if (!slideState.sliding) {
                    // Climbing ladder
                    const climbProgress = slideState.climbStep / 3;
                    playerSlideX = slideX + 7;
                    playerSlideY = slideBottomY - climbProgress * slideH - 40;
                } else {
                    // Sliding down
                    const t = slideState.slideProgress;
                    playerSlideX = slideStartX + t * slideW;
                    playerSlideY = slideTopY + t * (slideBottomY - slideTopY) - 40;
                }
                drawPlayer(playerSlideX - 30, playerSlideY);
            }

            // Slide hint
            const slideInteractX = house.x + house.width + 87; // World coords
            const slideDistance = Math.abs(player.x - slideInteractX);
            if (slideDistance < 60 && !slideState.active) {
                const hintText2 = 'SPACJA - Wejd≈∫ na zje≈ºd≈ºalniƒô!';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.font = 'bold 14px Comic Sans MS';
                ctx.textAlign = 'center';
                const hw2 = ctx.measureText(hintText2).width + 20;
                ctx.fillRect(slideX + platformW / 2 - hw2 / 2, slideTopY - 45, hw2, 28);
                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 2;
                ctx.strokeRect(slideX + platformW / 2 - hw2 / 2, slideTopY - 45, hw2, 28);
                ctx.fillStyle = '#FF4444';
                ctx.fillText(hintText2, slideX + platformW / 2, slideTopY - 26);
            }

            // Show climb progress if on ladder
            if (slideState.active && !slideState.sliding && Math.abs(slideState.slideHouseX - house.x) < 10) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.font = 'bold 14px Comic Sans MS';
                ctx.textAlign = 'center';
                const climbText = slideState.climbStep < 3 ? `SPACJA - Wspinaj siƒô! (${slideState.climbStep}/3)` : 'SPACJA - Zje≈ºd≈ºaj!';
                const hw3 = ctx.measureText(climbText).width + 20;
                ctx.fillRect(slideX + platformW / 2 - hw3 / 2, slideTopY - 45, hw3, 28);
                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 2;
                ctx.strokeRect(slideX + platformW / 2 - hw3 / 2, slideTopY - 45, hw3, 28);
                ctx.fillStyle = '#FF4444';
                ctx.fillText(climbText, slideX + platformW / 2, slideTopY - 26);
            }

            // Show hint when player is near house door
            const houseDoorX = house.x + 125; // Center of house
            const horizontalDistance = Math.abs(player.x - houseDoorX);

            if (horizontalDistance < 200 && !slideState.active) {
                let hintText = '';
                let hintColor = '';

                hintText = 'SPACJA - Wejd≈∫ do domku!';
                hintColor = '#00FF00';

                // Hint bubble
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.strokeStyle = hintColor;
                ctx.lineWidth = 3;
                const hintWidth = ctx.measureText(hintText).width + 40;
                ctx.fillRect(screenX + (house.width - hintWidth) / 2, screenY - 80, hintWidth, 40);
                ctx.strokeRect(screenX + (house.width - hintWidth) / 2, screenY - 80, hintWidth, 40);

                ctx.fillStyle = hintColor;
                ctx.font = 'bold 18px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText(hintText, screenX + house.width / 2, screenY - 55);
                }

                ctx.restore();
            });
        }

        let houseCooldown = 0; // Prevent instant exit after entering

        function enterHouse() {
            if (houseCooldown > 0) return;

            previousState = gameState;
            gameState = 'interior';
            houseCooldown = 30;

            // Reset interior player and camera
            interiorPlayer.x = 200;
            interiorPlayer.y = canvas.height - 200;
            interiorPlayer.action = 'none';
            interiorPlayer.actionTimer = 0;
            interiorPlayer.actionObject = null;
            interiorLightLevel = 1.0;
            interiorOffset = 0;

            // Generate procedural furniture if first time or empty
            if (interiorObjects.length === 0) {
                interiorObjects = [];

                // Exit door at start (x=100)
                interiorObjects.push({ type: 'door', x: 100 });

                // Generate furniture proceduralnie co ~300-500px
                let furnitureX = 300;
                const furnitureTypes = ['bed', 'toilet', 'sink', 'food', 'toy_ball', 'toy_mouse', 'toy_yarn'];

                for (let i = 0; i < 50; i++) { // Generate 50 furniture items
                    const randType = furnitureTypes[Math.floor(Math.random() * furnitureTypes.length)];
                    interiorObjects.push({
                        type: randType,
                        x: furnitureX,
                        variant: Math.floor(Math.random() * 3) // For variety in toys
                    });
                    furnitureX += 250 + Math.random() * 300;
                }
            }

            // Add current following friends to interior (they stay there!)
            followingFriends.forEach(f => {
                // Don't duplicate if already in interior
                const alreadyInside = interiorFriends.some(
                    inf => inf.type.emoji === f.type.emoji
                );
                if (!alreadyInside) {
                    interiorFriends.push({
                        type: f.type,
                        x: 100 + Math.random() * (canvas.width - 200),
                        y: canvas.height - 200,
                        velX: (Math.random() - 0.5) * 3,
                        velY: 0,
                        activity: 'walking',
                        activityTimer: 100 + Math.floor(Math.random() * 100),
                        jumpPower: 0,
                        animFrame: 0,
                        furnitureTarget: null,
                        targetActivity: null,
                        walkTargetX: 0
                    });
                }
            });

            // Friends stay in the house - remove from parade
            followingFriends = [];
            updateFriendsList();

            // Transfer P2 control to interior if active
            if (player2.active && p2ControlledFriendEmoji) {
                const interiorFriend = interiorFriends.find(f => f.type.emoji === p2ControlledFriendEmoji);
                if (interiorFriend) {
                    interiorFriend.activity = 'p2_controlled';
                    interiorFriend.furnitureTarget = null;
                    player2.interiorX = interiorFriend.x;
                    player2.interiorY = interiorFriend.y;
                    player2.interiorAction = 'none';
                    player2.interiorActionTimer = 0;
                } else {
                    // Friend not found in interior ‚Äî deactivate P2
                    player2.active = false;
                    player2.selectedIndex = -1;
                    player2.selectedType = null;
                    p2ControlledFriendEmoji = null;
                }
            }

            interiorAnimationFrame = 0;
        }

        function exitHouse() {
            if (houseCooldown > 0) return;
            gameState = 'world';
            houseCooldown = 30;
            // Reset bathtub water
            interiorPlayer.bathtubWaterLevel = 0;
            interiorPlayer.bathDone = false;
            // interiorFriends stay! They live here now.

            // Release P2-controlled interior friend back to AI, deactivate P2
            if (player2.active && p2ControlledFriendEmoji) {
                for (const f of interiorFriends) {
                    if (f.type.emoji === p2ControlledFriendEmoji) {
                        f.activity = 'walking';
                        f.activityTimer = 50 + Math.floor(Math.random() * 50);
                        f.velX = (Math.random() - 0.5) * 3;
                        break;
                    }
                }
            }
            player2.active = false;
            player2.selectedIndex = -1;
            player2.selectedType = null;
            p2ControlledFriendEmoji = null;
            player2.interiorAction = 'none';
        }

        // ========== KINDERGARTEN ==========

        function drawKindergartens() {
            const groundY = canvas.height - 100;
            kindergartens.forEach(kg => {
                const screenX = kg.x - worldOffset;
                if (screenX < -400 || screenX > canvas.width + 200) return;
                const screenY = groundY - kg.height;

                ctx.save();

                // Building body (warm yellow)
                ctx.fillStyle = '#FFF4B8';
                ctx.fillRect(screenX, screenY, kg.width, kg.height);

                // Outline
                ctx.strokeStyle = '#E8A030';
                ctx.lineWidth = 3;
                ctx.strokeRect(screenX, screenY, kg.width, kg.height);

                // Roof (green)
                ctx.fillStyle = '#66BB6A';
                ctx.beginPath();
                ctx.moveTo(screenX - 20, screenY);
                ctx.lineTo(screenX + kg.width / 2, screenY - 60);
                ctx.lineTo(screenX + kg.width + 20, screenY);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#388E3C';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Sign "PRZEDSZKOLE"
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.roundRect(screenX + 50, screenY + 10, 200, 30, 8);
                ctx.fill();
                ctx.strokeStyle = '#E8A030';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(screenX + 50, screenY + 10, 200, 30, 8);
                ctx.stroke();
                ctx.fillStyle = '#D84315';
                ctx.font = 'bold 16px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('PRZEDSZKOLE üè´', screenX + 150, screenY + 31);

                // Windows (colorful)
                const windowColors = ['#FFCDD2', '#C8E6C9', '#BBDEFB', '#FFF9C4'];
                for (let w = 0; w < 4; w++) {
                    const wx = screenX + 25 + w * 65;
                    const wy = screenY + 60;
                    ctx.fillStyle = windowColors[w];
                    ctx.fillRect(wx, wy, 45, 45);
                    ctx.strokeStyle = '#E8A030';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(wx, wy, 45, 45);
                    // Cross
                    ctx.beginPath();
                    ctx.moveTo(wx + 22, wy);
                    ctx.lineTo(wx + 22, wy + 45);
                    ctx.moveTo(wx, wy + 22);
                    ctx.lineTo(wx + 45, wy + 22);
                    ctx.stroke();
                }

                // Door (red)
                ctx.fillStyle = '#E53935';
                ctx.fillRect(screenX + 115, screenY + 130, 70, 90);
                // Door knob
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(screenX + 165, screenY + 175, 5, 0, Math.PI * 2);
                ctx.fill();

                // Toys outside (decorative)
                ctx.font = '22px serif';
                ctx.fillText('üß∏', screenX + 20, groundY - 5);
                ctx.fillText('ü™Ä', screenX + kg.width - 30, groundY - 5);
                ctx.fillText('üéà', screenX + kg.width + 5, screenY + 40);

                // Interaction hint
                const kgDoorScreenX = screenX + 150;
                const playerScreenX = player.x - worldOffset;
                if (Math.abs(playerScreenX - kgDoorScreenX) < 150) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.roundRect(kgDoorScreenX - 75, screenY + 110, 150, 22, 8);
                    ctx.fill();
                    ctx.strokeStyle = '#66BB6A';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.roundRect(kgDoorScreenX - 75, screenY + 110, 150, 22, 8);
                    ctx.stroke();
                    ctx.fillStyle = '#2E7D32';
                    ctx.font = 'bold 12px Comic Sans MS';
                    ctx.textAlign = 'center';
                    ctx.fillText('SPACJA - Wejd≈∫! üè´', kgDoorScreenX, screenY + 125);
                }

                ctx.restore();
            });
        }

        function enterKindergarten() {
            if (houseCooldown > 0) return;
            previousState = gameState;
            gameState = 'kindergarten';
            houseCooldown = 30;
            kindergartenState.active = true;
            kindergartenState.playerX = 200;
            kindergartenState.playerY = 0;
            kindergartenState.mathBoard.active = false;
            kindergartenState.wordBoard.active = false;
        }

        function exitKindergarten() {
            if (houseCooldown > 0) return;
            gameState = 'world';
            houseCooldown = 30;
            kindergartenState.active = false;
            kindergartenState.mathBoard.active = false;
            kindergartenState.wordBoard.active = false;
        }

        function generateMathProblem() {
            const ops = ['+', '-'];
            const op = ops[Math.floor(Math.random() * ops.length)];
            let a, b, answer;
            if (op === '+') {
                a = Math.floor(Math.random() * 15) + 1;
                b = Math.floor(Math.random() * 15) + 1;
                answer = a + b;
            } else {
                a = Math.floor(Math.random() * 15) + 5;
                b = Math.floor(Math.random() * a);
                answer = a - b;
            }
            // Generate 4 options including the correct one
            const options = [answer];
            while (options.length < 4) {
                const wrong = answer + (Math.floor(Math.random() * 7) - 3);
                if (wrong !== answer && wrong >= 0 && !options.includes(wrong)) {
                    options.push(wrong);
                }
            }
            // Shuffle
            for (let i = options.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [options[i], options[j]] = [options[j], options[i]];
            }
            return { text: `${a} ${op} ${b} = ?`, answer, options };
        }

        function generateWordProblem() {
            const word = kindergartenWords[Math.floor(Math.random() * kindergartenWords.length)];
            const options = [word.emoji];
            const available = allAnimalEmojis.filter(e => e !== word.emoji);
            while (options.length < 4) {
                const pick = available[Math.floor(Math.random() * available.length)];
                if (!options.includes(pick)) options.push(pick);
            }
            // Shuffle
            for (let i = options.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [options[i], options[j]] = [options[j], options[i]];
            }
            return { text: word.text, correctEmoji: word.emoji, options };
        }

        function drawKindergarten() {
            const floorY = canvas.height - 130;
            const wallColor = '#FFF8E1';
            const floorColor = '#A5D6A7';

            // Background wall
            ctx.fillStyle = wallColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Floor
            ctx.fillStyle = floorColor;
            ctx.fillRect(0, floorY, canvas.width, canvas.height - floorY);
            // Floor pattern
            ctx.strokeStyle = '#81C784';
            ctx.lineWidth = 1;
            for (let fx = 0; fx < canvas.width; fx += 60) {
                ctx.beginPath();
                ctx.moveTo(fx, floorY);
                ctx.lineTo(fx, canvas.height);
                ctx.stroke();
            }

            // Exit door (left)
            ctx.fillStyle = '#E53935';
            ctx.fillRect(30, floorY - 110, 60, 110);
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(75, floorY - 55, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 11px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('WYJ≈öCIE', 60, floorY - 80);

            // Toys on the floor (decorative)
            ctx.font = '28px serif';
            ctx.fillText('üß∏', 150, floorY - 5);
            ctx.fillText('ü™Ä', 250, floorY - 5);
            ctx.fillText('üöÇ', 350, floorY - 5);
            ctx.fillText('üé™', 450, floorY - 5);
            ctx.fillText('ü™Å', 550, floorY - 5);
            ctx.fillText('üé†', 650, floorY - 5);

            // ===== MATH BOARD (left side) =====
            const mathBoardX = 200;
            const mathBoardY = floorY - 260;
            const boardW = 280;
            const boardH = 180;

            // Board frame
            ctx.fillStyle = '#4E342E';
            ctx.fillRect(mathBoardX - 8, mathBoardY - 8, boardW + 16, boardH + 16);
            // Green board
            ctx.fillStyle = '#2E7D32';
            ctx.fillRect(mathBoardX, mathBoardY, boardW, boardH);
            // Label
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 14px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('MATEMATYKA üî¢', mathBoardX + boardW / 2, mathBoardY + 22);
            // Chalk line
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(mathBoardX + 10, mathBoardY + 30);
            ctx.lineTo(mathBoardX + boardW - 10, mathBoardY + 30);
            ctx.stroke();

            if (kindergartenState.mathBoard.active && kindergartenState.mathBoard.problem) {
                const mb = kindergartenState.mathBoard;
                // Problem text
                ctx.fillStyle = '#FFFF00';
                ctx.font = 'bold 22px Comic Sans MS';
                ctx.fillText(mb.problem.text, mathBoardX + boardW / 2, mathBoardY + 60);
                // Options
                mb.problem.options.forEach((opt, i) => {
                    const ox = mathBoardX + 20 + i * 65;
                    const oy = mathBoardY + 95;
                    const isSelected = mb.selectedOption === i;
                    // Option box
                    ctx.fillStyle = isSelected ? '#FFD700' : 'rgba(255,255,255,0.2)';
                    ctx.beginPath();
                    ctx.roundRect(ox, oy, 50, 40, 6);
                    ctx.fill();
                    if (isSelected) {
                        ctx.strokeStyle = '#FFF';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.roundRect(ox, oy, 50, 40, 6);
                        ctx.stroke();
                    }
                    ctx.fillStyle = isSelected ? '#000' : '#FFF';
                    ctx.font = 'bold 20px Comic Sans MS';
                    ctx.fillText(opt.toString(), ox + 25, oy + 28);
                });
                // Result feedback
                if (mb.result) {
                    ctx.fillStyle = mb.result === 'correct' ? '#76FF03' : '#FF5252';
                    ctx.font = 'bold 20px Comic Sans MS';
                    ctx.fillText(mb.result === 'correct' ? 'BRAWO! ‚≠ê ü™ô+1' : 'SPR√ìBUJ JESZCZE! ‚ùå', mathBoardX + boardW / 2, mathBoardY + 165);
                }
            } else {
                // Inactive ‚Äî show "press SPACE"
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.font = '13px Comic Sans MS';
                ctx.fillText('SPACJA aby graƒá', mathBoardX + boardW / 2, mathBoardY + 80);
                // Decorative equation
                ctx.fillStyle = '#FFFF00';
                ctx.font = 'bold 18px Comic Sans MS';
                ctx.fillText('2 + 3 = 5 ‚úì', mathBoardX + boardW / 2, mathBoardY + 115);
            }

            // Score
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 12px Comic Sans MS';
            ctx.fillText('‚≠ê ' + kindergartenState.mathBoard.score, mathBoardX + boardW / 2, mathBoardY + boardH + 20);

            // ===== WORD-PICTURE BOARD (right side) =====
            const wordBoardX = 600;
            const wordBoardY = floorY - 260;

            // Board frame
            ctx.fillStyle = '#4E342E';
            ctx.fillRect(wordBoardX - 8, wordBoardY - 8, boardW + 16, boardH + 16);
            // Blue board
            ctx.fillStyle = '#1565C0';
            ctx.fillRect(wordBoardX, wordBoardY, boardW, boardH);
            // Label
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 14px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('OBRAZKI üñºÔ∏è', wordBoardX + boardW / 2, wordBoardY + 22);
            // Line
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(wordBoardX + 10, wordBoardY + 30);
            ctx.lineTo(wordBoardX + boardW - 10, wordBoardY + 30);
            ctx.stroke();

            if (kindergartenState.wordBoard.active && kindergartenState.wordBoard.word) {
                const wb = kindergartenState.wordBoard;
                // Word
                ctx.fillStyle = '#FFFF00';
                ctx.font = 'bold 24px Comic Sans MS';
                ctx.fillText('"' + wb.word.text + '"', wordBoardX + boardW / 2, wordBoardY + 62);
                // Emoji options
                wb.word.options.forEach((opt, i) => {
                    const ox = wordBoardX + 15 + i * 65;
                    const oy = wordBoardY + 85;
                    const isSelected = wb.selectedOption === i;
                    ctx.fillStyle = isSelected ? '#FFD700' : 'rgba(255,255,255,0.2)';
                    ctx.beginPath();
                    ctx.roundRect(ox, oy, 52, 50, 6);
                    ctx.fill();
                    if (isSelected) {
                        ctx.strokeStyle = '#FFF';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.roundRect(ox, oy, 52, 50, 6);
                        ctx.stroke();
                    }
                    ctx.font = '30px serif';
                    ctx.fillText(opt, ox + 26, oy + 38);
                });
                // Result
                if (wb.result) {
                    ctx.fillStyle = wb.result === 'correct' ? '#76FF03' : '#FF5252';
                    ctx.font = 'bold 20px Comic Sans MS';
                    ctx.fillText(wb.result === 'correct' ? 'BRAWO! ‚≠ê ü™ô+1' : 'SPR√ìBUJ JESZCZE! ‚ùå', wordBoardX + boardW / 2, wordBoardY + 165);
                }
            } else {
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.font = '13px Comic Sans MS';
                ctx.fillText('SPACJA aby graƒá', wordBoardX + boardW / 2, wordBoardY + 80);
                // Decorative
                ctx.font = '30px serif';
                ctx.fillText('üê± = kot ‚úì', wordBoardX + boardW / 2, wordBoardY + 120);
            }

            // Score
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 12px Comic Sans MS';
            ctx.fillText('‚≠ê ' + kindergartenState.wordBoard.score, wordBoardX + boardW / 2, wordBoardY + boardH + 20);

            // ===== PLAYER =====
            kindergartenState.playerY = floorY - 40;
            const px = kindergartenState.playerX;
            const py = kindergartenState.playerY;

            // No boards active ‚Äî movement
            if (!kindergartenState.mathBoard.active && !kindergartenState.wordBoard.active) {
                const speed = 4;
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                    kindergartenState.playerX -= speed;
                    player.facingRight = false;
                }
                if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                    kindergartenState.playerX += speed;
                    player.facingRight = true;
                }
                kindergartenState.playerX = Math.max(30, Math.min(canvas.width - 30, kindergartenState.playerX));
            }

            // Draw player
            drawPlayer(px, py);

            // Interaction hints
            ctx.textAlign = 'center';
            if (!kindergartenState.mathBoard.active && !kindergartenState.wordBoard.active) {
                // Near exit door
                if (px < 100) {
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.beginPath();
                    ctx.roundRect(25, floorY - 135, 70, 20, 6);
                    ctx.fill();
                    ctx.fillStyle = '#E53935';
                    ctx.font = 'bold 11px Comic Sans MS';
                    ctx.fillText('SPACJA', 60, floorY - 120);
                }
                // Near math board
                if (Math.abs(px - (mathBoardX + boardW / 2)) < 100) {
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.beginPath();
                    ctx.roundRect(mathBoardX + boardW / 2 - 60, floorY - 55, 120, 20, 6);
                    ctx.fill();
                    ctx.fillStyle = '#2E7D32';
                    ctx.font = 'bold 11px Comic Sans MS';
                    ctx.fillText('SPACJA - Zagraj!', mathBoardX + boardW / 2, floorY - 40);
                }
                // Near word board
                if (Math.abs(px - (wordBoardX + boardW / 2)) < 100) {
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.beginPath();
                    ctx.roundRect(wordBoardX + boardW / 2 - 60, floorY - 55, 120, 20, 6);
                    ctx.fill();
                    ctx.fillStyle = '#1565C0';
                    ctx.font = 'bold 11px Comic Sans MS';
                    ctx.fillText('SPACJA - Zagraj!', wordBoardX + boardW / 2, floorY - 40);
                }
            }

            // Board active ‚Äî show controls
            if (kindergartenState.mathBoard.active || kindergartenState.wordBoard.active) {
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath();
                ctx.roundRect(canvas.width / 2 - 150, canvas.height - 45, 300, 35, 10);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('‚Üê ‚Üí Wybierz   SPACJA Zatwierd≈∫   ESC Wyjd≈∫', canvas.width / 2, canvas.height - 22);
            }
        }

        function handleKindergartenSpace() {
            if (gameState !== 'kindergarten') return;

            const px = kindergartenState.playerX;
            const mathBoardCenterX = 340; // mathBoardX(200) + boardW(280)/2
            const wordBoardCenterX = 740; // wordBoardX(600) + boardW(280)/2

            // If math board is active
            if (kindergartenState.mathBoard.active) {
                const mb = kindergartenState.mathBoard;
                if (mb.result) return; // Wait for result to clear
                const selected = mb.problem.options[mb.selectedOption];
                if (selected === mb.problem.answer) {
                    mb.result = 'correct';
                    mb.score++;
                    addCoins(1);
                } else {
                    mb.result = 'wrong';
                }
                mb.resultTimer = 60;
                return;
            }

            // If word board is active
            if (kindergartenState.wordBoard.active) {
                const wb = kindergartenState.wordBoard;
                if (wb.result) return;
                const selected = wb.word.options[wb.selectedOption];
                if (selected === wb.word.correctEmoji) {
                    wb.result = 'correct';
                    wb.score++;
                    addCoins(1);
                } else {
                    wb.result = 'wrong';
                }
                wb.resultTimer = 60;
                return;
            }

            // Near exit
            if (px < 100) {
                exitKindergarten();
                return;
            }

            // Near math board
            if (Math.abs(px - mathBoardCenterX) < 80) {
                kindergartenState.mathBoard.active = true;
                kindergartenState.mathBoard.problem = generateMathProblem();
                kindergartenState.mathBoard.selectedOption = 0;
                kindergartenState.mathBoard.result = null;
                return;
            }

            // Near word board
            if (Math.abs(px - wordBoardCenterX) < 80) {
                kindergartenState.wordBoard.active = true;
                kindergartenState.wordBoard.word = generateWordProblem();
                kindergartenState.wordBoard.selectedOption = 0;
                kindergartenState.wordBoard.result = null;
                return;
            }
        }

        function updateKindergartenBoards() {
            // Handle result timers
            if (kindergartenState.mathBoard.result && kindergartenState.mathBoard.resultTimer > 0) {
                kindergartenState.mathBoard.resultTimer--;
                if (kindergartenState.mathBoard.resultTimer <= 0) {
                    if (kindergartenState.mathBoard.result === 'correct') {
                        // New problem
                        kindergartenState.mathBoard.problem = generateMathProblem();
                        kindergartenState.mathBoard.selectedOption = 0;
                    }
                    kindergartenState.mathBoard.result = null;
                }
            }
            if (kindergartenState.wordBoard.result && kindergartenState.wordBoard.resultTimer > 0) {
                kindergartenState.wordBoard.resultTimer--;
                if (kindergartenState.wordBoard.resultTimer <= 0) {
                    if (kindergartenState.wordBoard.result === 'correct') {
                        kindergartenState.wordBoard.word = generateWordProblem();
                        kindergartenState.wordBoard.selectedOption = 0;
                    }
                    kindergartenState.wordBoard.result = null;
                }
            }
        }

        // ========== OFFICE (PRACA) ==========

        function drawOffices() {
            const groundY = canvas.height - 100;
            offices.forEach(ofc => {
                const screenX = ofc.x - worldOffset;
                if (screenX < -400 || screenX > canvas.width + 200) return;
                const screenY = groundY - ofc.height;

                ctx.save();

                // Building body (light gray-blue, modern)
                ctx.fillStyle = '#B0BEC5';
                ctx.fillRect(screenX, screenY, ofc.width, ofc.height);

                // Outline
                ctx.strokeStyle = '#546E7A';
                ctx.lineWidth = 3;
                ctx.strokeRect(screenX, screenY, ofc.width, ofc.height);

                // Roof (flat, dark)
                ctx.fillStyle = '#37474F';
                ctx.fillRect(screenX - 10, screenY - 15, ofc.width + 20, 20);

                // Sign "PRACA"
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.roundRect(screenX + 60, screenY + 8, 160, 28, 8);
                ctx.fill();
                ctx.strokeStyle = '#1565C0';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(screenX + 60, screenY + 8, 160, 28, 8);
                ctx.stroke();
                ctx.fillStyle = '#1565C0';
                ctx.font = 'bold 15px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('PRACA üíº', screenX + 140, screenY + 27);

                // Windows (office style - big glass)
                for (let w = 0; w < 3; w++) {
                    const wx = screenX + 20 + w * 85;
                    const wy = screenY + 55;
                    // Glass
                    ctx.fillStyle = '#E3F2FD';
                    ctx.fillRect(wx, wy, 60, 50);
                    // Frame
                    ctx.strokeStyle = '#546E7A';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(wx, wy, 60, 50);
                    // Blind lines
                    ctx.strokeStyle = 'rgba(84, 110, 122, 0.3)';
                    ctx.lineWidth = 1;
                    for (let bl = 0; bl < 4; bl++) {
                        ctx.beginPath();
                        ctx.moveTo(wx + 2, wy + 12 + bl * 12);
                        ctx.lineTo(wx + 58, wy + 12 + bl * 12);
                        ctx.stroke();
                    }
                }

                // Door (blue-gray)
                ctx.fillStyle = '#455A64';
                ctx.fillRect(screenX + 110, screenY + 130, 60, 100);
                // Door handle
                ctx.fillStyle = '#B0BEC5';
                ctx.beginPath();
                ctx.arc(screenX + 155, screenY + 180, 4, 0, Math.PI * 2);
                ctx.fill();
                // Door sign
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 9px Comic Sans MS';
                ctx.fillText('WEJ≈öCIE', screenX + 140, screenY + 152);

                // Decorations
                ctx.font = '18px serif';
                ctx.fillText('üíª', screenX + 10, groundY - 5);
                ctx.fillText('üìä', screenX + ofc.width - 25, groundY - 5);

                // Interaction hint
                const ofcDoorScreenX = screenX + 140;
                const playerScreenX = player.x - worldOffset;
                if (Math.abs(playerScreenX - ofcDoorScreenX) < 150) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.roundRect(ofcDoorScreenX - 70, screenY + 112, 140, 22, 8);
                    ctx.fill();
                    ctx.strokeStyle = '#1565C0';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.roundRect(ofcDoorScreenX - 70, screenY + 112, 140, 22, 8);
                    ctx.stroke();
                    ctx.fillStyle = '#1565C0';
                    ctx.font = 'bold 12px Comic Sans MS';
                    ctx.textAlign = 'center';
                    ctx.fillText('SPACJA - Wejd≈∫! üíº', ofcDoorScreenX, screenY + 127);
                }

                ctx.restore();
            });
        }

        function enterOffice() {
            if (houseCooldown > 0) return;
            previousState = gameState;
            gameState = 'office';
            houseCooldown = 30;
            officeState.active = true;
            officeState.playerX = 200;
            officeState.playerY = 0;
            officeState.computer.active = false;
        }

        function exitOffice() {
            if (houseCooldown > 0) return;
            gameState = 'world';
            houseCooldown = 30;
            officeState.active = false;
            officeState.computer.active = false;
        }

        function generateComputerTask() {
            // Alternate between pattern and debug tasks
            const type = Math.random() < 0.5 ? 'pattern' : 'debug';
            if (type === 'pattern') {
                const pat = patternSets[Math.floor(Math.random() * patternSets.length)];
                const options = [pat.answer, ...pat.distractors];
                // Shuffle
                for (let i = options.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [options[i], options[j]] = [options[j], options[i]];
                }
                return { type: 'pattern', sequence: pat.seq, answer: pat.answer, options };
            } else {
                const dbg = debugTasks[Math.floor(Math.random() * debugTasks.length)];
                const options = [...dbg.fixOptions];
                for (let i = options.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [options[i], options[j]] = [options[j], options[i]];
                }
                return { type: 'debug', code: dbg.code, bugLine: dbg.bugLine, answer: dbg.answer, options };
            }
        }

        function drawOffice() {
            const floorY = canvas.height - 130;

            // Background ‚Äî office wall
            ctx.fillStyle = '#ECEFF1';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Wallpaper pattern (subtle grid)
            ctx.strokeStyle = 'rgba(176, 190, 197, 0.3)';
            ctx.lineWidth = 1;
            for (let gx = 0; gx < canvas.width; gx += 40) {
                ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, floorY); ctx.stroke();
            }
            for (let gy = 0; gy < floorY; gy += 40) {
                ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(canvas.width, gy); ctx.stroke();
            }

            // Floor (wood-ish)
            ctx.fillStyle = '#8D6E63';
            ctx.fillRect(0, floorY, canvas.width, canvas.height - floorY);
            ctx.strokeStyle = '#6D4C41';
            ctx.lineWidth = 1;
            for (let fx = 0; fx < canvas.width; fx += 80) {
                ctx.beginPath(); ctx.moveTo(fx, floorY); ctx.lineTo(fx, canvas.height); ctx.stroke();
            }

            // Exit door (left)
            ctx.fillStyle = '#455A64';
            ctx.fillRect(30, floorY - 110, 55, 110);
            ctx.fillStyle = '#B0BEC5';
            ctx.beginPath();
            ctx.arc(72, floorY - 55, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 10px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('WYJ≈öCIE', 57, floorY - 80);

            // ===== DESK WITH COMPUTER (center) =====
            const deskX = 400;
            const deskY = floorY;
            const deskW = 200;
            const deskH = 70;

            // Desk
            ctx.fillStyle = '#795548';
            ctx.fillRect(deskX, deskY - deskH, deskW, deskH);
            ctx.strokeStyle = '#5D4037';
            ctx.lineWidth = 2;
            ctx.strokeRect(deskX, deskY - deskH, deskW, deskH);
            // Desk legs
            ctx.fillStyle = '#5D4037';
            ctx.fillRect(deskX + 10, deskY, 8, 20);
            ctx.fillRect(deskX + deskW - 18, deskY, 8, 20);

            // Monitor
            const monW = 140;
            const monH = 100;
            const monX = deskX + (deskW - monW) / 2;
            const monY = deskY - deskH - monH - 10;
            // Monitor body
            ctx.fillStyle = '#263238';
            ctx.beginPath();
            ctx.roundRect(monX, monY, monW, monH, 6);
            ctx.fill();
            // Screen
            const scrPad = 8;
            ctx.fillStyle = officeState.computer.active ? '#1B5E20' : '#0D47A1';
            ctx.fillRect(monX + scrPad, monY + scrPad, monW - scrPad * 2, monH - scrPad * 2 - 5);
            // Monitor stand
            ctx.fillStyle = '#37474F';
            ctx.fillRect(monX + monW / 2 - 10, monY + monH, 20, 12);
            ctx.fillRect(monX + monW / 2 - 20, monY + monH + 10, 40, 5);

            // Keyboard
            ctx.fillStyle = '#455A64';
            ctx.beginPath();
            ctx.roundRect(deskX + 30, deskY - 25, 80, 18, 3);
            ctx.fill();
            // Key dots
            ctx.fillStyle = '#78909C';
            for (let kr = 0; kr < 2; kr++) {
                for (let kc = 0; kc < 8; kc++) {
                    ctx.fillRect(deskX + 35 + kc * 9, deskY - 22 + kr * 8, 6, 5);
                }
            }

            // Coffee mug
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.roundRect(deskX + deskW - 35, deskY - deskH + 5, 22, 25, 3);
            ctx.fill();
            ctx.fillStyle = '#6D4C41';
            ctx.beginPath();
            ctx.ellipse(deskX + deskW - 24, deskY - deskH + 8, 9, 5, 0, 0, Math.PI);
            ctx.fill();
            // Steam
            ctx.strokeStyle = 'rgba(200,200,200,0.5)';
            ctx.lineWidth = 1;
            const steamOff = Math.sin(animationFrame * 0.05) * 3;
            ctx.beginPath();
            ctx.moveTo(deskX + deskW - 28, deskY - deskH - 2);
            ctx.quadraticCurveTo(deskX + deskW - 32 + steamOff, deskY - deskH - 15, deskX + deskW - 26, deskY - deskH - 25);
            ctx.stroke();

            // ===== SECOND DESK (right, filing) =====
            const desk2X = 700;
            ctx.fillStyle = '#795548';
            ctx.fillRect(desk2X, deskY - 55, 120, 55);
            ctx.strokeStyle = '#5D4037';
            ctx.lineWidth = 2;
            ctx.strokeRect(desk2X, deskY - 55, 120, 55);
            // Papers on desk
            ctx.fillStyle = '#FFF';
            ctx.save();
            ctx.translate(desk2X + 30, deskY - 80);
            ctx.rotate(-0.1);
            ctx.fillRect(0, 0, 40, 50);
            ctx.strokeStyle = '#CCC';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, 40, 50);
            ctx.fillStyle = '#90A4AE';
            for (let l = 0; l < 5; l++) {
                ctx.fillRect(5, 8 + l * 8, 30, 2);
            }
            ctx.restore();
            ctx.fillStyle = '#FFF';
            ctx.save();
            ctx.translate(desk2X + 60, deskY - 78);
            ctx.rotate(0.08);
            ctx.fillRect(0, 0, 40, 50);
            ctx.strokeStyle = '#CCC';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, 40, 50);
            ctx.fillStyle = '#90A4AE';
            for (let l = 0; l < 5; l++) {
                ctx.fillRect(5, 8 + l * 8, 30, 2);
            }
            ctx.restore();

            // Plant in corner
            ctx.font = '35px serif';
            ctx.textAlign = 'center';
            ctx.fillText('ü™¥', 900, floorY - 5);

            // Water cooler
            ctx.fillStyle = '#B3E5FC';
            ctx.beginPath();
            ctx.roundRect(155, floorY - 80, 30, 55, 5);
            ctx.fill();
            ctx.strokeStyle = '#0288D1';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(155, floorY - 80, 30, 55, 5);
            ctx.stroke();
            ctx.fillStyle = '#0288D1';
            ctx.beginPath();
            ctx.arc(170, floorY - 90, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#B3E5FC';
            ctx.beginPath();
            ctx.arc(170, floorY - 90, 8, 0, Math.PI * 2);
            ctx.fill();

            // ===== SCREEN CONTENT =====
            if (officeState.computer.active && officeState.computer.task) {
                const task = officeState.computer.task;
                const sX = monX + scrPad;
                const sY = monY + scrPad;
                const sW = monW - scrPad * 2;
                const sH = monH - scrPad * 2 - 5;

                if (task.type === 'pattern') {
                    // Title
                    ctx.fillStyle = '#76FF03';
                    ctx.font = 'bold 10px Comic Sans MS';
                    ctx.textAlign = 'center';
                    ctx.fillText('Co dalej w ciƒÖgu?', sX + sW / 2, sY + 14);
                    // Sequence
                    ctx.font = '16px serif';
                    const seqStr = task.sequence.join(' ') + ' ‚ùì';
                    ctx.fillText(seqStr, sX + sW / 2, sY + 34);
                    // Options
                    task.options.forEach((opt, i) => {
                        const ox = sX + 10 + i * 30;
                        const oy = sY + 48;
                        const sel = officeState.computer.selectedOption === i;
                        ctx.fillStyle = sel ? '#FFD700' : 'rgba(255,255,255,0.15)';
                        ctx.beginPath();
                        ctx.roundRect(ox, oy, 26, 26, 4);
                        ctx.fill();
                        if (sel) {
                            ctx.strokeStyle = '#FFF';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.roundRect(ox, oy, 26, 26, 4);
                            ctx.stroke();
                        }
                        ctx.font = '16px serif';
                        ctx.fillText(opt, ox + 13, oy + 20);
                    });
                } else if (task.type === 'debug') {
                    // Title
                    ctx.fillStyle = '#FF5252';
                    ctx.font = 'bold 9px Comic Sans MS';
                    ctx.textAlign = 'center';
                    ctx.fillText('Znajd≈∫ b≈ÇƒÖd! üêõ', sX + sW / 2, sY + 12);
                    // Code lines
                    const lines = task.code.split('\n');
                    ctx.font = '11px monospace';
                    ctx.textAlign = 'left';
                    lines.forEach((line, i) => {
                        const isBug = i === task.bugLine;
                        ctx.fillStyle = isBug ? '#FF8A80' : '#B2FF59';
                        if (isBug) {
                            ctx.fillStyle = 'rgba(255,82,82,0.2)';
                            ctx.fillRect(sX + 2, sY + 16 + i * 14, sW - 4, 13);
                            ctx.fillStyle = '#FF8A80';
                        }
                        ctx.fillText(line, sX + 5, sY + 27 + i * 14);
                    });
                    // Fix options
                    ctx.textAlign = 'center';
                    ctx.font = 'bold 10px Comic Sans MS';
                    ctx.fillStyle = '#FFF';
                    ctx.fillText('Poprawna warto≈õƒá:', sX + sW / 2, sY + 65);
                    task.options.forEach((opt, i) => {
                        const ox = sX + 5 + i * 30;
                        const oy = sY + 69;
                        const sel = officeState.computer.selectedOption === i;
                        ctx.fillStyle = sel ? '#FFD700' : 'rgba(255,255,255,0.15)';
                        ctx.beginPath();
                        ctx.roundRect(ox, oy, 28, 16, 3);
                        ctx.fill();
                        if (sel) {
                            ctx.strokeStyle = '#FFF';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.roundRect(ox, oy, 28, 16, 3);
                            ctx.stroke();
                        }
                        ctx.fillStyle = sel ? '#000' : '#FFF';
                        ctx.font = 'bold 9px monospace';
                        ctx.fillText(opt, ox + 14, oy + 12);
                    });
                }
                // Result feedback
                if (officeState.computer.result) {
                    ctx.fillStyle = officeState.computer.result === 'correct' ? 'rgba(27,94,32,0.9)' : 'rgba(198,40,40,0.9)';
                    ctx.beginPath();
                    ctx.roundRect(sX + 10, sY + sH - 18, sW - 20, 16, 4);
                    ctx.fill();
                    ctx.fillStyle = '#FFF';
                    ctx.font = 'bold 10px Comic Sans MS';
                    ctx.textAlign = 'center';
                    ctx.fillText(officeState.computer.result === 'correct' ? 'DOBRZE! ‚≠ê+1 ü™ô+2' : 'SPR√ìBUJ JESZCZE!', sX + sW / 2, sY + sH - 7);
                }
            } else {
                // Idle screen
                const sX = monX + scrPad;
                const sY = monY + scrPad;
                const sW = monW - scrPad * 2;
                ctx.fillStyle = '#64B5F6';
                ctx.font = '22px serif';
                ctx.textAlign = 'center';
                ctx.fillText('üíª', sX + sW / 2, sY + 35);
                ctx.fillStyle = '#FFF';
                ctx.font = '9px Comic Sans MS';
                ctx.fillText('Podejd≈∫ i naci≈õnij SPACJƒò', sX + sW / 2, sY + 55);
            }

            // ===== PLAYER =====
            officeState.playerY = floorY - 40;
            const px = officeState.playerX;
            const py = officeState.playerY;

            if (!officeState.computer.active) {
                const speed = 4;
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                    officeState.playerX -= speed;
                    player.facingRight = false;
                }
                if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                    officeState.playerX += speed;
                    player.facingRight = true;
                }
                officeState.playerX = Math.max(30, Math.min(canvas.width - 30, officeState.playerX));
            }

            drawPlayer(px, py);

            // Interaction hints
            ctx.textAlign = 'center';
            if (!officeState.computer.active) {
                if (px < 100) {
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.beginPath();
                    ctx.roundRect(25, floorY - 135, 65, 20, 6);
                    ctx.fill();
                    ctx.fillStyle = '#455A64';
                    ctx.font = 'bold 11px Comic Sans MS';
                    ctx.fillText('SPACJA', 57, floorY - 120);
                }
                const computerCenterX = deskX + deskW / 2;
                if (Math.abs(px - computerCenterX) < 80) {
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.beginPath();
                    ctx.roundRect(computerCenterX - 65, floorY - 55, 130, 20, 6);
                    ctx.fill();
                    ctx.fillStyle = '#1565C0';
                    ctx.font = 'bold 11px Comic Sans MS';
                    ctx.fillText('SPACJA - Komputer üíª', computerCenterX, floorY - 40);
                }
            }

            // Controls hint when at computer
            if (officeState.computer.active) {
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath();
                ctx.roundRect(canvas.width / 2 - 150, canvas.height - 45, 300, 35, 10);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('‚Üê ‚Üí Wybierz   SPACJA Zatwierd≈∫   ESC Wyjd≈∫', canvas.width / 2, canvas.height - 22);
            }

            // Score display
            ctx.fillStyle = 'rgba(21,101,192,0.85)';
            ctx.beginPath();
            ctx.roundRect(canvas.width - 120, 10, 110, 30, 8);
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 13px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('‚≠ê Punkty: ' + officeState.computer.score, canvas.width - 65, 30);
        }

        function handleOfficeSpace() {
            if (gameState !== 'office') return;

            const px = officeState.playerX;
            const computerCenterX = 500; // deskX + deskW/2

            if (officeState.computer.active) {
                const comp = officeState.computer;
                if (comp.result) return;
                const selected = comp.task.options[comp.selectedOption];
                if (selected === comp.task.answer) {
                    comp.result = 'correct';
                    comp.score++;
                    addCoins(2);
                } else {
                    comp.result = 'wrong';
                }
                comp.resultTimer = 60;
                return;
            }

            // Near exit
            if (px < 100) {
                exitOffice();
                return;
            }

            // Near computer
            if (Math.abs(px - computerCenterX) < 80) {
                officeState.computer.active = true;
                officeState.computer.task = generateComputerTask();
                officeState.computer.selectedOption = 0;
                officeState.computer.result = null;
                return;
            }
        }

        function updateOfficeComputer() {
            if (officeState.computer.result && officeState.computer.resultTimer > 0) {
                officeState.computer.resultTimer--;
                if (officeState.computer.resultTimer <= 0) {
                    if (officeState.computer.result === 'correct') {
                        officeState.computer.task = generateComputerTask();
                        officeState.computer.selectedOption = 0;
                    }
                    officeState.computer.result = null;
                }
            }
        }

        // ========== SHOP (SKLEP) ==========

        function drawShops() {
            const groundY = canvas.height - 100;
            shops.forEach(shop => {
                const screenX = shop.x - worldOffset;
                if (screenX < -400 || screenX > canvas.width + 200) return;
                const screenY = groundY - shop.height;

                ctx.save();

                // Building body (warm pink-peach)
                ctx.fillStyle = '#FFE0CC';
                ctx.fillRect(screenX, screenY, shop.width, shop.height);

                // Outline
                ctx.strokeStyle = '#E8967A';
                ctx.lineWidth = 3;
                ctx.strokeRect(screenX, screenY, shop.width, shop.height);

                // Roof (cute awning stripes)
                const awningH = 25;
                for (let i = 0; i < shop.width + 20; i += 20) {
                    ctx.fillStyle = i % 40 === 0 ? '#FF6B9D' : '#FFF';
                    ctx.fillRect(screenX - 10 + i, screenY - awningH, 20, awningH);
                }
                ctx.strokeStyle = '#E8967A';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX - 10, screenY - awningH, shop.width + 20, awningH);

                // Sign "SKLEP"
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.roundRect(screenX + 55, screenY + 8, 160, 28, 8);
                ctx.fill();
                ctx.strokeStyle = '#FF6B9D';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(screenX + 55, screenY + 8, 160, 28, 8);
                ctx.stroke();
                ctx.fillStyle = '#FF6B9D';
                ctx.font = 'bold 15px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('SKLEP üõçÔ∏è', screenX + 135, screenY + 27);

                // Display window (left)
                ctx.fillStyle = '#FFF8E7';
                ctx.fillRect(screenX + 15, screenY + 50, 80, 60);
                ctx.strokeStyle = '#E8967A';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX + 15, screenY + 50, 80, 60);
                // Items in display
                ctx.font = '20px serif';
                ctx.fillText('üëó', screenX + 35, screenY + 80);
                ctx.fillText('üëë', screenX + 65, screenY + 80);
                ctx.fillText('üß£', screenX + 50, screenY + 100);

                // Display window (right)
                ctx.fillStyle = '#FFF8E7';
                ctx.fillRect(screenX + 175, screenY + 50, 80, 60);
                ctx.strokeStyle = '#E8967A';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX + 175, screenY + 50, 80, 60);
                ctx.font = '20px serif';
                ctx.fillText('üé©', screenX + 195, screenY + 80);
                ctx.fillText('üåà', screenX + 225, screenY + 80);
                ctx.fillText('üéÄ', screenX + 210, screenY + 100);

                // Door (pink)
                ctx.fillStyle = '#FF6B9D';
                ctx.fillRect(screenX + 105, screenY + 120, 60, 90);
                // Door handle
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(screenX + 150, screenY + 165, 4, 0, Math.PI * 2);
                ctx.fill();
                // Door sign
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 9px Comic Sans MS';
                ctx.fillText('WEJ≈öCIE', screenX + 135, screenY + 142);

                // Decorations
                ctx.font = '18px serif';
                ctx.fillText('üõí', screenX + 5, groundY - 5);
                ctx.fillText('üéÅ', screenX + shop.width - 20, groundY - 5);

                // Interaction hint
                const shopDoorScreenX = screenX + 135;
                const playerScreenX = player.x - worldOffset;
                if (Math.abs(playerScreenX - shopDoorScreenX) < 150) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.roundRect(shopDoorScreenX - 75, screenY + 102, 150, 22, 8);
                    ctx.fill();
                    ctx.strokeStyle = '#FF6B9D';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.roundRect(shopDoorScreenX - 75, screenY + 102, 150, 22, 8);
                    ctx.stroke();
                    ctx.fillStyle = '#FF6B9D';
                    ctx.font = 'bold 12px Comic Sans MS';
                    ctx.textAlign = 'center';
                    ctx.fillText('SPACJA - Wejd≈∫! üõçÔ∏è', shopDoorScreenX, screenY + 117);
                }

                ctx.restore();
            });
        }

        function enterShop() {
            if (houseCooldown > 0) return;
            previousState = gameState;
            gameState = 'shop';
            houseCooldown = 30;
            shopState.active = true;
            shopState.playerX = 200;
            shopState.playerY = 0;
            shopState.selectedItem = 0;
            shopState.category = 0;
            shopState.scrollY = 0;
            shopState.message = null;
            shopState.messageTimer = 0;
            // Hide overlays so they don't cover the shop
            document.querySelector('.hud').style.display = 'none';
            document.querySelector('.friends-parade').style.display = 'none';
            document.querySelector('.wardrobe').style.display = 'none';
        }

        function exitShop() {
            if (houseCooldown > 0) return;
            gameState = 'world';
            houseCooldown = 30;
            shopState.active = false;
            // Show overlays again
            document.querySelector('.hud').style.display = '';
            document.querySelector('.friends-parade').style.display = '';
            document.querySelector('.wardrobe').style.display = '';
        }

        function getAllShopItems() {
            // Returns flat list of all unbought items across all categories, with category info and price
            const allItems = [];
            for (let c = 0; c < shopCategories.length; c++) {
                const cat = shopCategories[c];
                const owned = collectedItems[cat];
                const available = itemDefinitions[cat].filter(item => !owned.includes(item.id));
                available.forEach(item => {
                    allItems.push({ ...item, category: cat, categoryIndex: c, categoryName: shopCategoryNames[c], price: ITEM_PRICES[cat] });
                });
            }
            return allItems;
        }

        function drawShopkeeper(x, y) {
            ctx.save();
            // Body
            ctx.fillStyle = '#FFB74D';
            ctx.beginPath();
            ctx.ellipse(x, y + 30, 25, 30, 0, 0, Math.PI * 2);
            ctx.fill();
            // Head
            ctx.beginPath();
            ctx.arc(x, y - 5, 22, 0, Math.PI * 2);
            ctx.fill();
            // Ears
            ctx.beginPath();
            ctx.moveTo(x - 17, y - 20);
            ctx.lineTo(x - 25, y - 40);
            ctx.lineTo(x - 7, y - 25);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x + 17, y - 20);
            ctx.lineTo(x + 25, y - 40);
            ctx.lineTo(x + 7, y - 25);
            ctx.closePath();
            ctx.fill();
            // Inner ears
            ctx.fillStyle = '#FF8A65';
            ctx.beginPath();
            ctx.moveTo(x - 15, y - 20);
            ctx.lineTo(x - 20, y - 33);
            ctx.lineTo(x - 8, y - 23);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x + 15, y - 20);
            ctx.lineTo(x + 20, y - 33);
            ctx.lineTo(x + 8, y - 23);
            ctx.closePath();
            ctx.fill();
            // Eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(x - 9, y - 5, 3, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + 9, y - 5, 3, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            // Eye sparkles
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 8, y - 7, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 10, y - 7, 1.5, 0, Math.PI * 2);
            ctx.fill();
            // Nose
            ctx.fillStyle = '#FF6B9D';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - 3, y + 4);
            ctx.lineTo(x + 3, y + 4);
            ctx.closePath();
            ctx.fill();
            // Mouth
            ctx.strokeStyle = '#FF6B9D';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(x - 4, y + 6, 5, 0, Math.PI * 0.7);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(x + 4, y + 6, 5, Math.PI * 0.3, Math.PI);
            ctx.stroke();
            // Apron
            ctx.fillStyle = '#FF6B9D';
            ctx.beginPath();
            ctx.roundRect(x - 20, y + 15, 40, 35, 5);
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.font = '14px serif';
            ctx.textAlign = 'center';
            ctx.fillText('üõçÔ∏è', x, y + 38);
            ctx.restore();
        }

        function drawShop() {
            const floorY = canvas.height - 100;
            const shopAreaBottom = floorY - 10; // items area bottom
            const headerH = 55; // header with coins + title

            // ===== BACKGROUND =====
            // Walls
            const wallGrad = ctx.createLinearGradient(0, 0, 0, floorY);
            wallGrad.addColorStop(0, '#FFF0E6');
            wallGrad.addColorStop(1, '#FFE0CC');
            ctx.fillStyle = wallGrad;
            ctx.fillRect(0, 0, canvas.width, floorY);

            // Subtle wallpaper
            ctx.globalAlpha = 0.04;
            ctx.fillStyle = '#FF6B9D';
            for (let x = 0; x < canvas.width; x += 30) {
                for (let y = 0; y < floorY; y += 30) {
                    ctx.beginPath();
                    ctx.moveTo(x + 15, y);
                    ctx.lineTo(x + 30, y + 15);
                    ctx.lineTo(x + 15, y + 30);
                    ctx.lineTo(x, y + 15);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;

            // Baseboard
            ctx.fillStyle = '#E8967A';
            ctx.fillRect(0, floorY - 5, canvas.width, 5);

            // Floor
            for (let x = 0; x < canvas.width; x += 40) {
                for (let y = floorY; y < canvas.height; y += 40) {
                    ctx.fillStyle = (Math.floor(x / 40) + Math.floor(y / 40)) % 2 === 0 ? '#FFD4BC' : '#FFC4A8';
                    ctx.fillRect(x, y, 40, 40);
                }
            }

            // ===== HEADER BAR =====
            ctx.fillStyle = 'rgba(255, 107, 157, 0.9)';
            ctx.beginPath();
            ctx.roundRect(10, 8, canvas.width - 20, 42, 12);
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 18px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('SKLEP üõçÔ∏è', canvas.width / 2, 36);
            // Coins in header
            ctx.textAlign = 'left';
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.fillText('ü™ô ' + coins, 25, 36);
            // ESC hint
            ctx.textAlign = 'right';
            ctx.font = 'bold 12px Comic Sans MS';
            ctx.fillText('ESC - Wyjd≈∫', canvas.width - 25, 36);

            // ===== SHOPKEEPER (bottom-right, behind counter) =====
            const skX = canvas.width - 100;
            const skY = floorY - 80;

            // Counter
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.roundRect(skX - 60, floorY - 45, 130, 45, [8, 8, 0, 0]);
            ctx.fill();
            ctx.fillStyle = '#A0522D';
            ctx.fillRect(skX - 55, floorY - 40, 120, 5);

            drawShopkeeper(skX, skY);

            // Speech bubble
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.beginPath();
            ctx.roundRect(skX - 120, skY - 75, 175, 35, 10);
            ctx.fill();
            ctx.strokeStyle = '#FF6B9D';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(skX - 120, skY - 75, 175, 35, 10);
            ctx.stroke();
            // Tail
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.beginPath();
            ctx.moveTo(skX - 10, skY - 40);
            ctx.lineTo(skX, skY - 30);
            ctx.lineTo(skX + 10, skY - 40);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#FF6B9D';
            ctx.font = 'bold 12px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('Wybierz i kup! Witaj! üò∫', skX - 33, skY - 53);

            // ===== EXIT DOOR (bottom-left) =====
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(10, floorY - 85, 45, 85);
            ctx.fillStyle = '#A0522D';
            ctx.fillRect(14, floorY - 80, 37, 75);
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(42, floorY - 42, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 9px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('WYJ≈öCIE', 32, floorY - 90);

            // ===== ALL ITEMS - scrollable area =====
            const allItems = getAllShopItems();
            const shelfX = 70;
            const shelfW = canvas.width - 200; // leave room for shopkeeper
            const shelfTop = headerH + 5;
            const shelfBottom = shopAreaBottom;
            const shelfH = shelfBottom - shelfTop;

            // Clip to shelf area
            ctx.save();
            ctx.beginPath();
            ctx.rect(shelfX - 5, shelfTop, shelfW + 10, shelfH);
            ctx.clip();

            // Build sections: draw each category as a section with header + item rows
            let currentY = shelfTop - shopState.scrollY;
            let globalIdx = 0;
            let totalContentH = 0;

            for (let c = 0; c < shopCategories.length; c++) {
                const cat = shopCategories[c];
                const catName = shopCategoryNames[c];
                const owned = collectedItems[cat];
                const catItems = itemDefinitions[cat].filter(item => !owned.includes(item.id));

                if (catItems.length === 0) {
                    // Section header even if empty
                    // Category header
                    ctx.fillStyle = 'rgba(255, 107, 157, 0.15)';
                    ctx.beginPath();
                    ctx.roundRect(shelfX, currentY, shelfW, 24, 6);
                    ctx.fill();
                    ctx.fillStyle = '#FF6B9D';
                    ctx.font = 'bold 13px Comic Sans MS';
                    ctx.textAlign = 'left';
                    ctx.fillText(catName + ' - Wszystko kupione! ‚ú®', shelfX + 10, currentY + 17);
                    currentY += 30;
                    totalContentH += 30;
                    continue;
                }

                // Category header
                ctx.fillStyle = 'rgba(255, 107, 157, 0.15)';
                ctx.beginPath();
                ctx.roundRect(shelfX, currentY, shelfW, 24, 6);
                ctx.fill();
                ctx.fillStyle = '#FF6B9D';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.textAlign = 'left';
                ctx.fillText(catName, shelfX + 10, currentY + 17);
                currentY += 28;
                totalContentH += 28;

                // Items in this category
                const cols = Math.max(1, Math.floor(shelfW / 140));
                const colW = shelfW / cols;
                const rowH = 44;

                catItems.forEach((item, i) => {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const ix = shelfX + col * colW;
                    const iy = currentY + row * rowH;

                    const selected = shopState.selectedItem === globalIdx;

                    // Item box
                    ctx.fillStyle = selected ? 'rgba(255, 107, 157, 0.25)' : 'rgba(255, 250, 250, 0.6)';
                    ctx.beginPath();
                    ctx.roundRect(ix + 2, iy, colW - 6, rowH - 4, 6);
                    ctx.fill();
                    if (selected) {
                        ctx.strokeStyle = '#FF6B9D';
                        ctx.lineWidth = 2.5;
                        ctx.beginPath();
                        ctx.roundRect(ix + 2, iy, colW - 6, rowH - 4, 6);
                        ctx.stroke();
                    }

                    // Item preview icon
                    drawItemPreview(ix + 20, iy + 20, cat, item.id, 22);

                    // Name
                    ctx.fillStyle = '#333';
                    ctx.font = 'bold 10px Comic Sans MS';
                    ctx.textAlign = 'left';
                    const maxNameW = colW - 80;
                    ctx.fillText(item.name.length > 14 ? item.name.substring(0, 13) + '..' : item.name, ix + 35, iy + 18);

                    // Price
                    const itemPrice = ITEM_PRICES[cat];
                    ctx.fillStyle = coins >= itemPrice ? '#4CAF50' : '#E53935';
                    ctx.font = 'bold 10px Comic Sans MS';
                    ctx.fillText('ü™ô' + itemPrice, ix + 35, iy + 33);

                    globalIdx++;
                });

                const rows = Math.ceil(catItems.length / cols);
                currentY += rows * rowH + 6;
                totalContentH += rows * rowH + 6;
            }

            shopState._totalItems = globalIdx;
            shopState._contentH = totalContentH;

            ctx.restore(); // end clip

            // Scroll indicators
            if (shopState.scrollY > 0) {
                ctx.fillStyle = 'rgba(255, 107, 157, 0.7)';
                ctx.font = 'bold 14px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('‚ñ≤ Przewi≈Ñ w g√≥rƒô', shelfX + shelfW / 2, shelfTop + 14);
            }
            if (totalContentH - shopState.scrollY > shelfH + 10) {
                ctx.fillStyle = 'rgba(255, 107, 157, 0.7)';
                ctx.font = 'bold 14px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('‚ñº Przewi≈Ñ w d√≥≈Ç', shelfX + shelfW / 2, shelfBottom - 4);
            }

            // ===== PLAYER on floor =====
            shopState.playerY = floorY - 40;
            const px = shopState.playerX;
            const py = shopState.playerY;
            const speed = 4;
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                shopState.playerX -= speed;
                player.facingRight = false;
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                shopState.playerX += speed;
                player.facingRight = true;
            }
            shopState.playerX = Math.max(30, Math.min(canvas.width - 30, shopState.playerX));

            // Live preview: temporarily equip selected item on player
            const _shopPrevHorn = player.equippedHorn;
            const _shopPrevOutfit = player.equippedOutfit;
            const _shopPrevAccessory = player.equippedAccessory;
            const _shopPrevColor = player.equippedColor;
            if (allItems.length > 0) {
                const previewItem = allItems[shopState.selectedItem] || allItems[0];
                if (previewItem) {
                    if (previewItem.category === 'horns') player.equippedHorn = previewItem.id;
                    else if (previewItem.category === 'outfits') player.equippedOutfit = previewItem.id;
                    else if (previewItem.category === 'accessories') player.equippedAccessory = previewItem.id;
                    else if (previewItem.category === 'colors') player.equippedColor = previewItem.id;
                }
            }
            drawPlayer(px, py);
            player.equippedHorn = _shopPrevHorn;
            player.equippedOutfit = _shopPrevOutfit;
            player.equippedAccessory = _shopPrevAccessory;
            player.equippedColor = _shopPrevColor;

            // Exit hint
            ctx.textAlign = 'center';
            if (px < 90) {
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.beginPath();
                ctx.roundRect(15, floorY - 98, 65, 18, 6);
                ctx.fill();
                ctx.fillStyle = '#8B4513';
                ctx.font = 'bold 10px Comic Sans MS';
                ctx.fillText('SPACJA', 47, floorY - 85);
            }

            // ===== BUY BUTTON BAR (bottom) =====
            const barY = canvas.height - 40;
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.beginPath();
            ctx.roundRect(canvas.width / 2 - 220, barY, 440, 32, 10);
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 12px Comic Sans MS';
            ctx.textAlign = 'center';
            if (allItems.length > 0) {
                const selectedItem = allItems[shopState.selectedItem] || allItems[0];
                const selectedPrice = selectedItem ? selectedItem.price : 1;
                const canBuy = selectedItem && coins >= selectedPrice;
                ctx.fillText(
                    (canBuy ? '‚Üê ‚Üí Wybierz   SPACJA Kup ü™ô' + selectedPrice : '‚Üê ‚Üí Wybierz   Za ma≈Ço monet!') + '   ‚Üë‚Üì Przewi≈Ñ   ESC Wyjd≈∫',
                    canvas.width / 2, barY + 22
                );
            } else {
                ctx.fillText('Wszystko kupione! ESC Wyjd≈∫', canvas.width / 2, barY + 22);
            }

            // ===== PURCHASE MESSAGE =====
            if (shopState.message && shopState.messageTimer > 0) {
                ctx.fillStyle = 'rgba(0,0,0,0.75)';
                ctx.beginPath();
                ctx.roundRect(canvas.width / 2 - 150, canvas.height / 2 - 30, 300, 60, 12);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 18px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText(shopState.message, canvas.width / 2, canvas.height / 2 + 8);
            }
        }

        function handleShopSpace() {
            if (gameState !== 'shop') return;

            const px = shopState.playerX;

            // Near exit
            if (px < 100) {
                exitShop();
                return;
            }

            // Try to buy
            const allItems = getAllShopItems();
            if (allItems.length === 0) return;
            if (shopState.selectedItem >= allItems.length) shopState.selectedItem = allItems.length - 1;

            const item = allItems[shopState.selectedItem];
            if (coins < item.price) {
                shopState.message = 'Za ma≈Ço monet! üòø';
                shopState.messageTimer = 60;
                return;
            }

            // Buy the item
            addCoins(-item.price);
            collectedItems[item.category].push(item.id);
            updateWardrobe();

            shopState.message = 'Kupiono: ' + item.name + '! ‚ú®';
            shopState.messageTimer = 60;

            // Adjust selection
            const newItems = getAllShopItems();
            if (shopState.selectedItem >= newItems.length && newItems.length > 0) {
                shopState.selectedItem = newItems.length - 1;
            }
        }

        function updateShop() {
            if (shopState.messageTimer > 0) {
                shopState.messageTimer--;
            }
        }

        // ========== HAIRDRESSER (FRYZJER) ==========

        function drawHairdressers() {
            const groundY = canvas.height - 100;
            hairdressers.forEach(hd => {
                const screenX = hd.x - worldOffset;
                if (screenX < -400 || screenX > canvas.width + 200) return;
                const screenY = groundY - hd.height;

                ctx.save();

                // Building body (pastel lavender)
                ctx.fillStyle = '#E8D5F5';
                ctx.fillRect(screenX, screenY, hd.width, hd.height);
                ctx.strokeStyle = '#B388D9';
                ctx.lineWidth = 3;
                ctx.strokeRect(screenX, screenY, hd.width, hd.height);

                // Roof (rounded purple)
                ctx.fillStyle = '#9C6ADE';
                ctx.beginPath();
                ctx.roundRect(screenX - 10, screenY - 18, hd.width + 20, 22, [10, 10, 0, 0]);
                ctx.fill();

                // Barber pole (left side)
                const poleX = screenX + 8;
                const poleY = screenY + 30;
                ctx.fillStyle = '#FFF';
                ctx.fillRect(poleX, poleY, 10, 80);
                for (let s = 0; s < 8; s++) {
                    ctx.fillStyle = s % 2 === 0 ? '#FF1493' : '#9C6ADE';
                    ctx.beginPath();
                    ctx.moveTo(poleX, poleY + s * 10);
                    ctx.lineTo(poleX + 10, poleY + s * 10 + 5);
                    ctx.lineTo(poleX + 10, poleY + s * 10 + 10);
                    ctx.lineTo(poleX, poleY + s * 10 + 5);
                    ctx.closePath();
                    ctx.fill();
                }
                // Pole caps
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(poleX + 5, poleY, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(poleX + 5, poleY + 80, 6, 0, Math.PI * 2);
                ctx.fill();

                // Sign "FRYZJER"
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.roundRect(screenX + 50, screenY + 8, 170, 28, 8);
                ctx.fill();
                ctx.strokeStyle = '#9C6ADE';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(screenX + 50, screenY + 8, 170, 28, 8);
                ctx.stroke();
                ctx.fillStyle = '#9C6ADE';
                ctx.font = 'bold 15px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('FRYZJER ‚úÇÔ∏è', screenX + 135, screenY + 27);

                // Window (big, showing salon inside)
                ctx.fillStyle = '#FFF8F0';
                ctx.fillRect(screenX + 30, screenY + 50, 90, 55);
                ctx.strokeStyle = '#B388D9';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX + 30, screenY + 50, 90, 55);
                // Mirror reflection
                ctx.fillStyle = 'rgba(200, 200, 255, 0.3)';
                ctx.fillRect(screenX + 35, screenY + 55, 25, 40);
                // Scissors and comb in window
                ctx.font = '16px serif';
                ctx.fillText('‚úÇÔ∏è', screenX + 55, screenY + 78);
                ctx.fillText('üíá', screenX + 85, screenY + 78);

                // Window right
                ctx.fillStyle = '#FFF8F0';
                ctx.fillRect(screenX + 160, screenY + 50, 90, 55);
                ctx.strokeStyle = '#B388D9';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX + 160, screenY + 50, 90, 55);
                ctx.font = '16px serif';
                ctx.fillText('üíà', screenX + 185, screenY + 78);
                ctx.fillText('üíÖ', screenX + 215, screenY + 78);

                // Door (purple)
                ctx.fillStyle = '#9C6ADE';
                ctx.fillRect(screenX + 110, screenY + 125, 60, 95);
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(screenX + 155, screenY + 175, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 9px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('WEJ≈öCIE', screenX + 140, screenY + 147);

                // Decorations
                ctx.font = '18px serif';
                ctx.fillText('üíà', screenX + hd.width - 20, groundY - 5);

                // Interaction hint
                const doorScreenX = screenX + 140;
                const playerScreenX = player.x - worldOffset;
                if (Math.abs(playerScreenX - doorScreenX) < 150) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.roundRect(doorScreenX - 75, screenY + 107, 150, 22, 8);
                    ctx.fill();
                    ctx.strokeStyle = '#9C6ADE';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.roundRect(doorScreenX - 75, screenY + 107, 150, 22, 8);
                    ctx.stroke();
                    ctx.fillStyle = '#9C6ADE';
                    ctx.font = 'bold 12px Comic Sans MS';
                    ctx.textAlign = 'center';
                    ctx.fillText('SPACJA - Wejd≈∫! ‚úÇÔ∏è', doorScreenX, screenY + 122);
                }

                ctx.restore();
            });
        }

        function enterHairdresser() {
            if (houseCooldown > 0) return;
            previousState = gameState;
            gameState = 'hairdresser';
            houseCooldown = 30;
            hairdresserState.active = true;
            hairdresserState.playerX = 200;
            hairdresserState.playerY = 0;
            hairdresserState.selectedItem = 0;
            hairdresserState.scrollY = 0;
            hairdresserState.message = null;
            hairdresserState.messageTimer = 0;
            document.querySelector('.hud').style.display = 'none';
            document.querySelector('.friends-parade').style.display = 'none';
            document.querySelector('.wardrobe').style.display = 'none';
        }

        function exitHairdresser() {
            if (houseCooldown > 0) return;
            gameState = 'world';
            houseCooldown = 30;
            hairdresserState.active = false;
            document.querySelector('.hud').style.display = '';
            document.querySelector('.friends-parade').style.display = '';
            document.querySelector('.wardrobe').style.display = '';
        }

        function getAllHairItems() {
            const allItems = [];
            const cats = ['hairstyles', 'hairColors', 'hairClips'];
            const catNames = ['Fryzury', 'Kolory w≈Ços√≥w', 'Spinki'];
            for (let c = 0; c < cats.length; c++) {
                const cat = cats[c];
                const owned = collectedItems[cat];
                const available = itemDefinitions[cat].filter(item => !owned.includes(item.id));
                available.forEach(item => {
                    allItems.push({ ...item, category: cat, categoryName: catNames[c], price: HAIR_PRICES[cat] });
                });
            }
            return allItems;
        }

        function drawHairdresser() {
            const floorY = canvas.height - 100;
            const headerH = 55;
            const time = Date.now() / 1000;

            // ===== BACKGROUND - SALON INTERIOR =====
            // Walls (soft lavender)
            const wallGrad = ctx.createLinearGradient(0, 0, 0, floorY);
            wallGrad.addColorStop(0, '#F3E5F5');
            wallGrad.addColorStop(1, '#E8D5F5');
            ctx.fillStyle = wallGrad;
            ctx.fillRect(0, 0, canvas.width, floorY);

            // Wallpaper - subtle swirls
            ctx.globalAlpha = 0.04;
            ctx.strokeStyle = '#9C6ADE';
            ctx.lineWidth = 1;
            for (let wx = 20; wx < canvas.width; wx += 50) {
                for (let wy = 20; wy < floorY; wy += 50) {
                    ctx.beginPath();
                    ctx.arc(wx, wy, 12, 0, Math.PI * 1.5);
                    ctx.stroke();
                }
            }
            ctx.globalAlpha = 1;

            // Baseboard
            ctx.fillStyle = '#B388D9';
            ctx.fillRect(0, floorY - 5, canvas.width, 5);

            // Floor (black and white tiles)
            for (let fx = 0; fx < canvas.width; fx += 35) {
                for (let fy = floorY; fy < canvas.height; fy += 35) {
                    ctx.fillStyle = (Math.floor(fx / 35) + Math.floor(fy / 35)) % 2 === 0 ? '#F0F0F0' : '#333';
                    ctx.fillRect(fx, fy, 35, 35);
                }
            }

            // ===== SALON STATIONS (background, behind items panel) =====
            const stationCount = 3;
            const stationSpacing = (canvas.width - 100) / stationCount;

            for (let s = 0; s < stationCount; s++) {
                const sx = 50 + s * stationSpacing;
                const sy = floorY - 8;

                // Mirror on wall (above chair)
                const mirrorY = sy - 140;
                ctx.fillStyle = '#C0C0C0';
                ctx.beginPath();
                ctx.roundRect(sx + 10, mirrorY, 50, 65, 5);
                ctx.fill();
                // Mirror glass
                ctx.fillStyle = 'rgba(200, 220, 255, 0.6)';
                ctx.beginPath();
                ctx.roundRect(sx + 14, mirrorY + 4, 42, 57, 3);
                ctx.fill();
                // Mirror reflection shine
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fillRect(sx + 18, mirrorY + 8, 8, 30);
                // Mirror frame top decoration
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(sx + 35, mirrorY, 5, 0, Math.PI * 2);
                ctx.fill();

                // Shelf under mirror (with products)
                const shelfMY = mirrorY + 68;
                ctx.fillStyle = '#9C6ADE';
                ctx.fillRect(sx + 5, shelfMY, 60, 6);
                ctx.font = '10px serif';
                ctx.fillText('üß¥', sx + 12, shelfMY - 1);
                ctx.fillText('üíá', sx + 30, shelfMY - 1);
                ctx.fillText('‚úÇÔ∏è', sx + 48, shelfMY - 1);

                // Salon chair
                ctx.fillStyle = '#FF69B4';
                ctx.beginPath();
                ctx.roundRect(sx + 15, sy - 45, 40, 30, 5);
                ctx.fill();
                // Chair back
                ctx.fillStyle = '#E91E78';
                ctx.beginPath();
                ctx.roundRect(sx + 18, sy - 65, 34, 25, [5, 5, 0, 0]);
                ctx.fill();
                // Chair base
                ctx.fillStyle = '#888';
                ctx.fillRect(sx + 30, sy - 15, 10, 15);
                ctx.fillStyle = '#666';
                ctx.beginPath();
                ctx.ellipse(sx + 35, sy, 18, 5, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // ===== ANIMATED HAIRDRESSER at station 2 =====
            const animSx = 50 + 1 * stationSpacing;
            const animSy = floorY - 8;

            // Customer in chair (static cute cat)
            const custX = animSx + 35;
            const custY = animSy - 55;
            ctx.fillStyle = '#DDA0DD';
            ctx.beginPath();
            ctx.arc(custX, custY, 12, 0, Math.PI * 2);
            ctx.fill();
            // Ears
            ctx.beginPath();
            ctx.moveTo(custX - 8, custY - 8);
            ctx.lineTo(custX - 12, custY - 18);
            ctx.lineTo(custX - 3, custY - 10);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(custX + 8, custY - 8);
            ctx.lineTo(custX + 12, custY - 18);
            ctx.lineTo(custX + 3, custY - 10);
            ctx.closePath();
            ctx.fill();
            // Eyes (closed, happy)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(custX - 4, custY - 2, 3, 0, Math.PI);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(custX + 4, custY - 2, 3, 0, Math.PI);
            ctx.stroke();
            // Customer body
            ctx.fillStyle = '#DDA0DD';
            ctx.beginPath();
            ctx.ellipse(custX, custY + 18, 10, 14, 0, 0, Math.PI * 2);
            ctx.fill();
            // Cape on customer
            ctx.fillStyle = '#9C6ADE';
            ctx.beginPath();
            ctx.moveTo(custX - 12, custY + 8);
            ctx.lineTo(custX + 12, custY + 8);
            ctx.lineTo(custX + 15, custY + 30);
            ctx.lineTo(custX - 15, custY + 30);
            ctx.closePath();
            ctx.fill();

            // Hairdresser NPC (animated)
            const hdX = custX + 25;
            const hdY = custY - 5;
            // Body
            ctx.fillStyle = '#FFB74D';
            ctx.beginPath();
            ctx.ellipse(hdX, hdY + 22, 12, 16, 0, 0, Math.PI * 2);
            ctx.fill();
            // Head
            ctx.beginPath();
            ctx.arc(hdX, hdY, 13, 0, Math.PI * 2);
            ctx.fill();
            // Ears
            ctx.beginPath();
            ctx.moveTo(hdX - 10, hdY - 8);
            ctx.lineTo(hdX - 14, hdY - 18);
            ctx.lineTo(hdX - 5, hdY - 10);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(hdX + 10, hdY - 8);
            ctx.lineTo(hdX + 14, hdY - 18);
            ctx.lineTo(hdX + 5, hdY - 10);
            ctx.closePath();
            ctx.fill();
            // Fancy hair on hairdresser
            ctx.fillStyle = '#FF1493';
            ctx.beginPath();
            ctx.arc(hdX, hdY - 10, 10, Math.PI, 0);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(hdX - 6, hdY - 8, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(hdX + 6, hdY - 8, 5, 0, Math.PI * 2);
            ctx.fill();
            // Eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(hdX - 4, hdY - 1, 2, 0, Math.PI * 2);
            ctx.arc(hdX + 4, hdY - 1, 2, 0, Math.PI * 2);
            ctx.fill();
            // Smile
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(hdX, hdY + 3, 4, 0.1, Math.PI - 0.1);
            ctx.stroke();
            // Apron
            ctx.fillStyle = '#9C6ADE';
            ctx.beginPath();
            ctx.roundRect(hdX - 10, hdY + 12, 20, 20, 3);
            ctx.fill();

            // Animated arm with tool (scissors or dryer alternating)
            const armAngle = Math.sin(time * 3) * 0.4;
            const toolSwitch = Math.floor(time) % 4; // 0-1: scissors, 2-3: dryer
            ctx.save();
            ctx.translate(hdX - 12, hdY + 10);
            ctx.rotate(armAngle - 0.5);
            // Arm
            ctx.strokeStyle = '#FFB74D';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-15, -15);
            ctx.stroke();
            // Tool
            ctx.font = '14px serif';
            ctx.textAlign = 'center';
            if (toolSwitch < 2) {
                ctx.fillText('‚úÇÔ∏è', -18, -18);
            } else {
                ctx.fillText('üí®', -18, -18);
                // Hair blowing particles
                for (let p = 0; p < 3; p++) {
                    const px = custX - 5 + Math.sin(time * 5 + p * 2) * 8;
                    const py = custY - 15 + Math.cos(time * 4 + p * 1.5) * 5 - p * 4;
                    ctx.fillStyle = 'rgba(200, 150, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(px, py, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.restore();

            // Floating hair snippets animation
            for (let h = 0; h < 5; h++) {
                const hx = custX - 20 + Math.sin(time * 2 + h * 1.3) * 25;
                const hy = custY - 25 + ((time * 20 + h * 40) % 60);
                ctx.fillStyle = 'rgba(180, 100, 220, 0.4)';
                ctx.beginPath();
                ctx.ellipse(hx, hy, 3, 1.5, Math.sin(time + h) * 0.5, 0, Math.PI * 2);
                ctx.fill();
            }

            // ===== HEADER BAR =====
            ctx.fillStyle = 'rgba(156, 106, 222, 0.9)';
            ctx.beginPath();
            ctx.roundRect(10, 8, canvas.width - 20, 42, 12);
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 18px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('FRYZJER ‚úÇÔ∏èüíá', canvas.width / 2, 36);
            ctx.textAlign = 'left';
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.fillText('ü™ô ' + coins, 25, 36);
            ctx.textAlign = 'right';
            ctx.font = 'bold 12px Comic Sans MS';
            ctx.fillText('ESC - Wyjd≈∫', canvas.width - 25, 36);

            // ===== EXIT DOOR =====
            ctx.fillStyle = '#6A3D9A';
            ctx.fillRect(10, floorY - 85, 45, 85);
            ctx.fillStyle = '#7B52AB';
            ctx.fillRect(14, floorY - 80, 37, 75);
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(42, floorY - 42, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 9px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('WYJ≈öCIE', 32, floorY - 90);

            // ===== ITEMS PANEL (left side, overlapping stations) =====
            const allItems = getAllHairItems();
            const panelX = 70;
            const panelW = canvas.width - 200;
            const panelTop = headerH + 5;
            const panelBottom = floorY - 10;
            const panelH = panelBottom - panelTop;

            ctx.save();
            ctx.beginPath();
            ctx.rect(panelX - 5, panelTop, panelW + 10, panelH);
            ctx.clip();

            let currentY = panelTop - hairdresserState.scrollY;
            let globalIdx = 0;
            let totalContentH = 0;
            const hairCats = ['hairstyles', 'hairColors', 'hairClips'];
            const hairCatNames = ['Fryzury ‚úÇÔ∏è', 'Kolory w≈Ços√≥w üé®', 'Spinki üíé'];

            for (let c = 0; c < hairCats.length; c++) {
                const cat = hairCats[c];
                const catName = hairCatNames[c];
                const owned = collectedItems[cat];
                const catItems = itemDefinitions[cat].filter(item => !owned.includes(item.id));

                // Category header
                ctx.fillStyle = 'rgba(156, 106, 222, 0.15)';
                ctx.beginPath();
                ctx.roundRect(panelX, currentY, panelW, 24, 6);
                ctx.fill();
                ctx.fillStyle = '#9C6ADE';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.textAlign = 'left';
                if (catItems.length === 0) {
                    ctx.fillText(catName + ' - Wszystko kupione! ‚ú®', panelX + 10, currentY + 17);
                } else {
                    ctx.fillText(catName, panelX + 10, currentY + 17);
                }
                currentY += 28;
                totalContentH += 28;

                if (catItems.length === 0) continue;

                const cols = Math.max(1, Math.floor(panelW / 140));
                const colW = panelW / cols;
                const rowH = 44;

                catItems.forEach((item, i) => {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const ix = panelX + col * colW;
                    const iy = currentY + row * rowH;
                    const selected = hairdresserState.selectedItem === globalIdx;
                    const itemPrice = HAIR_PRICES[cat];

                    ctx.fillStyle = selected ? 'rgba(156, 106, 222, 0.25)' : 'rgba(255, 250, 255, 0.6)';
                    ctx.beginPath();
                    ctx.roundRect(ix + 2, iy, colW - 6, rowH - 4, 6);
                    ctx.fill();
                    if (selected) {
                        ctx.strokeStyle = '#9C6ADE';
                        ctx.lineWidth = 2.5;
                        ctx.beginPath();
                        ctx.roundRect(ix + 2, iy, colW - 6, rowH - 4, 6);
                        ctx.stroke();
                    }

                    // Item preview icon
                    drawItemPreview(ix + 20, iy + 20, cat, item.id, 22);

                    ctx.fillStyle = '#333';
                    ctx.font = 'bold 10px Comic Sans MS';
                    ctx.textAlign = 'left';
                    ctx.fillText(item.name.length > 14 ? item.name.substring(0, 13) + '..' : item.name, ix + 35, iy + 18);

                    ctx.fillStyle = coins >= itemPrice ? '#4CAF50' : '#E53935';
                    ctx.font = 'bold 10px Comic Sans MS';
                    ctx.fillText('ü™ô' + itemPrice, ix + 35, iy + 33);

                    globalIdx++;
                });

                const rows = Math.ceil(catItems.length / cols);
                currentY += rows * rowH + 6;
                totalContentH += rows * rowH + 6;
            }

            hairdresserState._totalItems = globalIdx;
            hairdresserState._contentH = totalContentH;
            ctx.restore();

            // Scroll indicators
            if (hairdresserState.scrollY > 0) {
                ctx.fillStyle = 'rgba(156, 106, 222, 0.7)';
                ctx.font = 'bold 14px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('‚ñ≤', panelX + panelW / 2, panelTop + 14);
            }
            if (totalContentH - hairdresserState.scrollY > panelH + 10) {
                ctx.fillStyle = 'rgba(156, 106, 222, 0.7)';
                ctx.font = 'bold 14px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('‚ñº', panelX + panelW / 2, panelBottom - 4);
            }

            // ===== PLAYER =====
            hairdresserState.playerY = floorY - 40;
            const px = hairdresserState.playerX;
            const py = hairdresserState.playerY;
            const speed = 4;
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                hairdresserState.playerX -= speed;
                player.facingRight = false;
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                hairdresserState.playerX += speed;
                player.facingRight = true;
            }
            hairdresserState.playerX = Math.max(30, Math.min(canvas.width - 30, hairdresserState.playerX));

            // Live preview: temporarily equip selected hair item on player
            const _hdPrevHairstyle = player.equippedHairstyle;
            const _hdPrevHairColor = player.equippedHairColor;
            const _hdPrevHairClip = player.equippedHairClip;
            if (allItems.length > 0) {
                const previewItem = allItems[hairdresserState.selectedItem] || allItems[0];
                if (previewItem) {
                    if (previewItem.category === 'hairstyles') player.equippedHairstyle = previewItem.id;
                    else if (previewItem.category === 'hairColors') player.equippedHairColor = previewItem.id;
                    else if (previewItem.category === 'hairClips') player.equippedHairClip = previewItem.id;
                }
            }
            drawPlayer(px, py);
            player.equippedHairstyle = _hdPrevHairstyle;
            player.equippedHairColor = _hdPrevHairColor;
            player.equippedHairClip = _hdPrevHairClip;

            // Exit hint
            ctx.textAlign = 'center';
            if (px < 90) {
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.beginPath();
                ctx.roundRect(15, floorY - 98, 65, 18, 6);
                ctx.fill();
                ctx.fillStyle = '#6A3D9A';
                ctx.font = 'bold 10px Comic Sans MS';
                ctx.fillText('SPACJA', 47, floorY - 85);
            }

            // Bottom bar
            const barY = canvas.height - 40;
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.beginPath();
            ctx.roundRect(canvas.width / 2 - 220, barY, 440, 32, 10);
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 12px Comic Sans MS';
            ctx.textAlign = 'center';
            if (allItems.length > 0) {
                const sel = allItems[hairdresserState.selectedItem];
                const canBuy = sel && coins >= sel.price;
                ctx.fillText(
                    (canBuy ? '‚Üê ‚Üí Wybierz   SPACJA Kup ü™ô' + sel.price : '‚Üê ‚Üí Wybierz   Za ma≈Ço monet!') + '   ‚Üë‚Üì Przewi≈Ñ   ESC Wyjd≈∫',
                    canvas.width / 2, barY + 22
                );
            } else {
                ctx.fillText('Wszystko kupione! ESC Wyjd≈∫', canvas.width / 2, barY + 22);
            }

            // Purchase message
            if (hairdresserState.message && hairdresserState.messageTimer > 0) {
                ctx.fillStyle = 'rgba(0,0,0,0.75)';
                ctx.beginPath();
                ctx.roundRect(canvas.width / 2 - 150, canvas.height / 2 - 30, 300, 60, 12);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 18px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText(hairdresserState.message, canvas.width / 2, canvas.height / 2 + 8);
            }
        }

        function handleHairdresserSpace() {
            if (gameState !== 'hairdresser') return;

            if (hairdresserState.playerX < 100) {
                exitHairdresser();
                return;
            }

            const allItems = getAllHairItems();
            if (allItems.length === 0) return;
            if (hairdresserState.selectedItem >= allItems.length) hairdresserState.selectedItem = allItems.length - 1;

            const item = allItems[hairdresserState.selectedItem];
            if (coins < item.price) {
                hairdresserState.message = 'Za ma≈Ço monet! üòø';
                hairdresserState.messageTimer = 60;
                return;
            }

            addCoins(-item.price);
            collectedItems[item.category].push(item.id);

            // Auto-equip the bought item
            if (item.category === 'hairstyles') player.equippedHairstyle = item.id;
            else if (item.category === 'hairColors') player.equippedHairColor = item.id;
            else if (item.category === 'hairClips') player.equippedHairClip = item.id;

            updateWardrobe();
            hairdresserState.message = 'Nowy look: ' + item.name + '! ‚ú®';
            hairdresserState.messageTimer = 60;

            const newItems = getAllHairItems();
            if (hairdresserState.selectedItem >= newItems.length && newItems.length > 0) {
                hairdresserState.selectedItem = newItems.length - 1;
            }
        }

        function updateHairdresser() {
            if (hairdresserState.messageTimer > 0) {
                hairdresserState.messageTimer--;
            }
        }

        // ===== HOSPITAL (Szpital) System =====
        let hospitals = [];
        let hospitalState = {
            active: false,
            playerX: 200,
            playerY: 0,
            currentGame: null, // null = lobby, 'thermometer', 'bandage', 'xray'
            patient: null,
            message: null,
            messageTimer: 0,
            gameData: {},
            gamesCompleted: 0
        };

        const hospitalPatients = [
            { name: 'Kotek Mruczek', emoji: 'üê±', color: '#FFB74D', problem: 'Boli go brzuszek', game: 'thermometer' },
            { name: 'Piesek Burek', emoji: 'üê∂', color: '#A0522D', problem: 'Z≈Çama≈Ç ≈Çapkƒô', game: 'bandage' },
            { name: 'Kr√≥liczek Uszatek', emoji: 'üê∞', color: '#FFF0E6', problem: 'BolƒÖ go uszka', game: 'xray' },
            { name: 'Mama', emoji: 'üë©', color: '#FFD1A4', problem: 'Ma katar', game: 'thermometer' },
            { name: 'Mi≈õ Puchatek', emoji: 'üêª', color: '#CD853F', problem: 'Boli go gard≈Ço', game: 'bandage' },
            { name: 'Papuga Koko', emoji: 'ü¶ú', color: '#4CAF50', problem: 'Z≈Çama≈Ç skrzyde≈Çko', game: 'xray' },
            { name: '≈ª√≥≈Çwik Tola', emoji: 'üê¢', color: '#6B8E23', problem: 'Boli jƒÖ skorupka', game: 'bandage' },
            { name: 'Chomik Puszek', emoji: 'üêπ', color: '#F5DEB3', problem: 'Ma gorƒÖczkƒô', game: 'thermometer' },
            { name: 'Pingwinek Piko', emoji: 'üêß', color: '#333333', problem: 'Boli go brzuszek', game: 'xray' },
            { name: 'S√≥wka MƒÖdra', emoji: 'ü¶â', color: '#8B6914', problem: 'Z≈Çama≈Ça skrzyd≈Ço', game: 'bandage' },
            { name: 'Konik ≈Åatek', emoji: 'üê¥', color: '#C4A882', problem: 'Boli go kopytko', game: 'thermometer' },
            { name: 'Rybka Nemo', emoji: 'üêü', color: '#FF8C00', problem: 'Boli jƒÖ p≈Çetwa', game: 'xray' },
            { name: 'Tata', emoji: 'üë®', color: '#D2A679', problem: 'Boli go g≈Çowa', game: 'thermometer' },
            { name: 'Je≈ºyk Kolczatek', emoji: 'ü¶î', color: '#A0826D', problem: 'Straci≈Ç kolce', game: 'bandage' },
            { name: 'Lisek Rudzik', emoji: 'ü¶ä', color: '#D2691E', problem: 'Boli go ogon', game: 'xray' }
        ];

        function enterHospital() {
            if (houseCooldown > 0) return;
            gameState = 'hospital';
            houseCooldown = 30;
            hospitalState.active = true;
            hospitalState.playerX = 200;
            hospitalState.playerY = 0;
            hospitalState.currentGame = null;
            hospitalState.message = null;
            hospitalState.messageTimer = 0;
            hospitalState.gamesCompleted = 0;
            // Pick a random patient
            hospitalState.patient = hospitalPatients[Math.floor(Math.random() * hospitalPatients.length)];
            hospitalState.gameData = {};
            document.querySelector('.hud').style.display = 'none';
            document.querySelector('.friends-parade').style.display = 'none';
            document.querySelector('.wardrobe').style.display = 'none';
        }

        function exitHospital() {
            if (houseCooldown > 0) return;
            gameState = 'world';
            houseCooldown = 30;
            hospitalState.active = false;
            hospitalState.currentGame = null;
            document.querySelector('.hud').style.display = '';
            document.querySelector('.friends-parade').style.display = '';
            document.querySelector('.wardrobe').style.display = '';
        }

        function startHospitalGame() {
            const pat = hospitalState.patient;
            hospitalState.currentGame = pat.game;
            if (pat.game === 'thermometer') {
                // Termometr - trzeba nacisnƒÖƒá spacjƒô gdy wska≈∫nik jest w zielonym polu
                hospitalState.gameData = {
                    indicatorPos: 0,
                    indicatorDir: 1,
                    speed: 1.2,
                    targetMin: 0.3,
                    targetMax: 0.6,
                    attempts: 0,
                    maxAttempts: 5,
                    success: false,
                    done: false
                };
            } else if (pat.game === 'bandage') {
                // Banda≈ºowanie - klikaj strza≈Çki w odpowiedniej kolejno≈õci
                const dirs = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
                const seq = [];
                for (let i = 0; i < 4; i++) seq.push(dirs[Math.floor(Math.random() * dirs.length)]);
                hospitalState.gameData = {
                    sequence: seq,
                    currentStep: 0,
                    mistakes: 0,
                    maxMistakes: 5,
                    showSequence: true,
                    showTimer: 180,
                    success: false,
                    done: false,
                    bandageProgress: 0
                };
            } else if (pat.game === 'xray') {
                // Rentgen - znajd≈∫ bolƒÖce miejsce: klikaj strza≈Çkami by przesunƒÖƒá lupƒô
                const targetX = 0.2 + Math.random() * 0.6;
                const targetY = 0.2 + Math.random() * 0.6;
                hospitalState.gameData = {
                    targetX: targetX,
                    targetY: targetY,
                    cursorX: 0.5,
                    cursorY: 0.5,
                    found: false,
                    success: false,
                    done: false,
                    scanLines: 0
                };
            }
        }

        function drawHospitals() {
            const groundY = canvas.height - 100;
            hospitals.forEach(hosp => {
                const screenX = hosp.x - worldOffset;
                if (screenX < -400 || screenX > canvas.width + 200) return;
                const screenY = groundY - hosp.height;

                ctx.save();

                // Building body (white with light blue tint)
                ctx.fillStyle = '#F0F8FF';
                ctx.fillRect(screenX, screenY, hosp.width, hosp.height);
                ctx.strokeStyle = '#87CEEB';
                ctx.lineWidth = 3;
                ctx.strokeRect(screenX, screenY, hosp.width, hosp.height);

                // Roof
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(screenX - 10, screenY - 15, hosp.width + 20, 15);
                ctx.strokeStyle = '#5DADE2';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX - 10, screenY - 15, hosp.width + 20, 15);

                // Red cross on roof
                ctx.fillStyle = '#E74C3C';
                const crossCX = screenX + hosp.width / 2;
                const crossCY = screenY - 7;
                ctx.fillRect(crossCX - 12, crossCY - 3, 24, 6);
                ctx.fillRect(crossCX - 3, crossCY - 12, 6, 24);

                // Sign
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.roundRect(screenX + 45, screenY + 8, 190, 28, 8);
                ctx.fill();
                ctx.strokeStyle = '#E74C3C';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(screenX + 45, screenY + 8, 190, 28, 8);
                ctx.stroke();
                ctx.fillStyle = '#E74C3C';
                ctx.font = 'bold 14px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('SZPITAL ZWIERZƒÑTEK üè•', screenX + 140, screenY + 27);

                // Windows
                for (let w = 0; w < 3; w++) {
                    const wx = screenX + 20 + w * 95;
                    ctx.fillStyle = '#E8F6FF';
                    ctx.fillRect(wx, screenY + 50, 55, 50);
                    ctx.strokeStyle = '#87CEEB';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(wx, screenY + 50, 55, 50);
                    // Cross pattern in window
                    ctx.strokeStyle = '#B0D4E8';
                    ctx.beginPath();
                    ctx.moveTo(wx + 27, screenY + 50);
                    ctx.lineTo(wx + 27, screenY + 100);
                    ctx.moveTo(wx, screenY + 75);
                    ctx.lineTo(wx + 55, screenY + 75);
                    ctx.stroke();
                }

                // Door
                ctx.fillStyle = '#5DADE2';
                ctx.fillRect(screenX + 110, screenY + 120, 60, 100);
                ctx.fillStyle = '#3498DB';
                ctx.fillRect(screenX + 114, screenY + 125, 52, 90);
                // Red cross on door
                ctx.fillStyle = '#E74C3C';
                ctx.fillRect(screenX + 132, screenY + 140, 16, 4);
                ctx.fillRect(screenX + 138, screenY + 134, 4, 16);
                // Door handle
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(screenX + 155, screenY + 170, 4, 0, Math.PI * 2);
                ctx.fill();

                // Ambulance parked nearby
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.roundRect(screenX + hosp.width - 80, groundY - 40, 70, 35, 5);
                ctx.fill();
                ctx.fillStyle = '#E74C3C';
                ctx.fillRect(screenX + hosp.width - 55, groundY - 35, 16, 4);
                ctx.fillRect(screenX + hosp.width - 49, groundY - 41, 4, 16);
                // Wheels
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(screenX + hosp.width - 65, groundY - 5, 6, 0, Math.PI * 2);
                ctx.arc(screenX + hosp.width - 25, groundY - 5, 6, 0, Math.PI * 2);
                ctx.fill();
                // Siren
                ctx.fillStyle = '#E74C3C';
                ctx.beginPath();
                ctx.arc(screenX + hosp.width - 50, groundY - 42, 5, 0, Math.PI * 2);
                ctx.fill();

                // Interaction hint
                const hospDoorScreenX = screenX + 140;
                const playerScreenX = player.x - worldOffset;
                if (Math.abs(playerScreenX - hospDoorScreenX) < 150) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.roundRect(hospDoorScreenX - 80, screenY + 102, 160, 22, 8);
                    ctx.fill();
                    ctx.strokeStyle = '#5DADE2';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.roundRect(hospDoorScreenX - 80, screenY + 102, 160, 22, 8);
                    ctx.stroke();
                    ctx.fillStyle = '#5DADE2';
                    ctx.font = 'bold 12px Comic Sans MS';
                    ctx.textAlign = 'center';
                    ctx.fillText('SPACJA - Wejd≈∫ üè•', hospDoorScreenX, screenY + 118);
                }

                ctx.restore();
            });
        }

        function drawHospitalPatient(x, y, pat) {
            // Draw a cute patient on a hospital bed
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.roundRect(x - 30, y, 60, 25, 5);
            ctx.fill();
            ctx.strokeStyle = '#87CEEB';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(x - 30, y, 60, 25, 5);
            ctx.stroke();
            // Pillow
            ctx.fillStyle = '#E8F6FF';
            ctx.beginPath();
            ctx.ellipse(x - 15, y + 5, 12, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            // Patient body
            ctx.fillStyle = pat.color;
            ctx.beginPath();
            ctx.arc(x - 10, y - 5, 12, 0, Math.PI * 2);
            ctx.fill();
            // Eyes (sad)
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(x - 14, y - 7, 2, 0, Math.PI * 2);
            ctx.arc(x - 6, y - 7, 2, 0, Math.PI * 2);
            ctx.fill();
            // Sad mouth
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(x - 10, y + 2, 4, Math.PI + 0.3, -0.3);
            ctx.stroke();
            // Blanket
            ctx.fillStyle = '#87CEEB';
            ctx.globalAlpha = 0.6;
            ctx.fillRect(x - 25, y + 8, 50, 15);
            ctx.globalAlpha = 1;
        }

        function drawHospital() {
            const floorY = canvas.height - 100;
            const time = Date.now() / 1000;
            const pat = hospitalState.patient;

            // ===== BACKGROUND - HOSPITAL INTERIOR =====
            const wallGrad = ctx.createLinearGradient(0, 0, 0, floorY);
            wallGrad.addColorStop(0, '#F0F8FF');
            wallGrad.addColorStop(1, '#E0F0FF');
            ctx.fillStyle = wallGrad;
            ctx.fillRect(0, 0, canvas.width, floorY);

            // Tiles pattern on walls
            ctx.globalAlpha = 0.06;
            ctx.fillStyle = '#87CEEB';
            for (let x = 0; x < canvas.width; x += 40) {
                for (let y = 0; y < floorY; y += 40) {
                    ctx.strokeStyle = '#87CEEB';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, 40, 40);
                }
            }
            ctx.globalAlpha = 1;

            // Floor
            for (let fx = 0; fx < canvas.width; fx += 40) {
                ctx.fillStyle = Math.floor(fx / 40) % 2 === 0 ? '#E8F6FF' : '#D4EDF7';
                ctx.fillRect(fx, floorY, 40, canvas.height - floorY);
            }

            // Baseboard
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, floorY - 3, canvas.width, 3);

            // ===== HEADER BAR =====
            ctx.fillStyle = 'rgba(92, 173, 226, 0.9)';
            ctx.beginPath();
            ctx.roundRect(10, 8, canvas.width - 20, 42, 12);
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 18px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('SZPITAL ZWIERZƒÑTEK üè•', canvas.width / 2, 36);
            ctx.textAlign = 'left';
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.fillText('ü™ô ' + coins, 25, 36);
            ctx.textAlign = 'right';
            ctx.font = 'bold 12px Comic Sans MS';
            ctx.fillText('ESC - Wyjd≈∫', canvas.width - 25, 36);

            // ===== EXIT DOOR =====
            ctx.fillStyle = '#5DADE2';
            ctx.fillRect(10, floorY - 85, 45, 85);
            ctx.fillStyle = '#3498DB';
            ctx.fillRect(14, floorY - 80, 37, 75);
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(42, floorY - 42, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 9px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('WYJ≈öCIE', 32, floorY - 90);

            // ===== HOSPITAL FURNITURE =====
            // Medicine cabinet (right wall)
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.roundRect(canvas.width - 90, 70, 70, 120, 5);
            ctx.fill();
            ctx.strokeStyle = '#87CEEB';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(canvas.width - 90, 70, 70, 120, 5);
            ctx.stroke();
            // Cabinet shelves
            ctx.strokeStyle = '#B0D4E8';
            ctx.beginPath();
            ctx.moveTo(canvas.width - 85, 110);
            ctx.lineTo(canvas.width - 25, 110);
            ctx.moveTo(canvas.width - 85, 150);
            ctx.lineTo(canvas.width - 25, 150);
            ctx.stroke();
            // Medicine bottles
            ctx.font = '14px serif';
            ctx.fillText('üíä', canvas.width - 75, 100);
            ctx.fillText('ü©π', canvas.width - 50, 100);
            ctx.fillText('üíâ', canvas.width - 75, 140);
            ctx.fillText('üå°Ô∏è', canvas.width - 50, 140);
            ctx.fillText('üß¥', canvas.width - 75, 180);
            ctx.fillText('üíä', canvas.width - 50, 180);

            // Heart monitor
            const monitorX = canvas.width - 130;
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.roundRect(monitorX, 90, 30, 25, 3);
            ctx.fill();
            ctx.fillStyle = '#111';
            ctx.beginPath();
            ctx.roundRect(monitorX + 2, 92, 26, 21, 2);
            ctx.fill();
            // Heartbeat line
            ctx.strokeStyle = '#0F0';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            for (let i = 0; i < 24; i++) {
                const hx = monitorX + 3 + i;
                const hy = 103 + (i === 10 ? -6 : i === 12 ? 6 : i === 14 ? -8 : Math.sin(time * 3 + i * 0.5) * 2);
                if (i === 0) ctx.moveTo(hx, hy);
                else ctx.lineTo(hx, hy);
            }
            ctx.stroke();
            // Stand
            ctx.fillStyle = '#666';
            ctx.fillRect(monitorX + 12, 115, 6, 20);

            // ===== IV DRIP (Kropl√≥wka) =====
            const ivX = 80;
            const ivY = 80;
            // Stand pole
            ctx.fillStyle = '#AAA';
            ctx.fillRect(ivX - 1.5, ivY, 3, floorY - ivY);
            // Stand base (tripod)
            ctx.strokeStyle = '#AAA';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(ivX, floorY);
            ctx.lineTo(ivX - 15, floorY + 5);
            ctx.moveTo(ivX, floorY);
            ctx.lineTo(ivX + 15, floorY + 5);
            ctx.moveTo(ivX, floorY);
            ctx.lineTo(ivX, floorY + 6);
            ctx.stroke();
            // Hook at top
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(ivX, ivY, 5, Math.PI, 0);
            ctx.stroke();
            // IV bag
            ctx.fillStyle = 'rgba(173, 216, 230, 0.7)';
            ctx.beginPath();
            ctx.roundRect(ivX - 10, ivY + 5, 20, 30, 4);
            ctx.fill();
            ctx.strokeStyle = '#87CEEB';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(ivX - 10, ivY + 5, 20, 30, 4);
            ctx.stroke();
            // Fluid level
            ctx.fillStyle = 'rgba(135, 206, 235, 0.5)';
            ctx.fillRect(ivX - 8, ivY + 15, 16, 18);
            // Tube from bag
            ctx.strokeStyle = 'rgba(135, 206, 235, 0.8)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(ivX, ivY + 35);
            ctx.quadraticCurveTo(ivX + 5, ivY + 50, ivX + 15, ivY + 60);
            ctx.stroke();
            // Drip animation
            const dripY = ivY + 37 + ((time * 40) % 15);
            ctx.fillStyle = 'rgba(135, 206, 235, 0.8)';
            ctx.beginPath();
            ctx.ellipse(ivX, dripY, 2, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // ===== RED CROSS on wall =====
            const crossX = canvas.width / 2;
            const crossY = 75;
            // White circle background
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(crossX, crossY, 22, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(crossX, crossY, 22, 0, Math.PI * 2);
            ctx.stroke();
            // Red cross
            ctx.fillStyle = '#E74C3C';
            ctx.fillRect(crossX - 14, crossY - 5, 28, 10);
            ctx.fillRect(crossX - 5, crossY - 14, 10, 28);

            // ===== HAND SANITIZER on wall =====
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.roundRect(135, 75, 22, 30, 4);
            ctx.fill();
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(138, 95, 16, 8);
            ctx.fillStyle = '#5DADE2';
            ctx.fillRect(142, 70, 8, 8);
            ctx.font = 'bold 6px Comic Sans MS';
            ctx.fillStyle = '#5DADE2';
            ctx.textAlign = 'center';
            ctx.fillText('MYD≈ÅO', 146, 90);

            // ===== POSTER on wall (wash hands) =====
            ctx.fillStyle = '#FFF8DC';
            ctx.beginPath();
            ctx.roundRect(170, 70, 50, 40, 3);
            ctx.fill();
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(170, 70, 50, 40, 3);
            ctx.stroke();
            ctx.font = '16px serif';
            ctx.textAlign = 'center';
            ctx.fillText('üßºü§≤', 195, 93);
            ctx.font = 'bold 6px Comic Sans MS';
            ctx.fillStyle = '#5DADE2';
            ctx.fillText('Myj rƒôce!', 195, 106);

            // ===== WHEELCHAIR (near wall) =====
            const wcX = canvas.width - 170;
            const wcY = floorY - 10;
            // Wheel
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(wcX, wcY, 12, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(wcX + 25, wcY, 8, 0, Math.PI * 2);
            ctx.stroke();
            // Spokes
            ctx.lineWidth = 0.5;
            for (let sp = 0; sp < 6; sp++) {
                const sa = (sp / 6) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(wcX, wcY);
                ctx.lineTo(wcX + Math.cos(sa) * 12, wcY + Math.sin(sa) * 12);
                ctx.stroke();
            }
            // Seat
            ctx.fillStyle = '#5DADE2';
            ctx.fillRect(wcX - 5, wcY - 22, 22, 4);
            // Backrest
            ctx.fillRect(wcX - 5, wcY - 35, 4, 17);
            // Handle
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(wcX - 3, wcY - 35);
            ctx.lineTo(wcX - 10, wcY - 40);
            ctx.stroke();

            // ===== CLOCK on wall =====
            const clkX = canvas.width / 2 + 80;
            const clkY = 80;
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(clkX, clkY, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(clkX, clkY, 15, 0, Math.PI * 2);
            ctx.stroke();
            // Hour marks
            for (let h = 0; h < 12; h++) {
                const ha = (h / 12) * Math.PI * 2 - Math.PI / 2;
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(clkX + Math.cos(ha) * 12, clkY + Math.sin(ha) * 12, 1, 0, Math.PI * 2);
                ctx.fill();
            }
            // Hands
            const hourAngle = (time / 60 % 12) / 12 * Math.PI * 2 - Math.PI / 2;
            const minAngle = (time % 60) / 60 * Math.PI * 2 - Math.PI / 2;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(clkX, clkY);
            ctx.lineTo(clkX + Math.cos(hourAngle) * 7, clkY + Math.sin(hourAngle) * 7);
            ctx.stroke();
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(clkX, clkY);
            ctx.lineTo(clkX + Math.cos(minAngle) * 10, clkY + Math.sin(minAngle) * 10);
            ctx.stroke();
            // Center dot
            ctx.fillStyle = '#E74C3C';
            ctx.beginPath();
            ctx.arc(clkX, clkY, 2, 0, Math.PI * 2);
            ctx.fill();

            if (hospitalState.currentGame === null) {
                // ===== LOBBY - show patient and prompt =====
                // Hospital beds
                for (let b = 0; b < 3; b++) {
                    const bx = 120 + b * 150;
                    const by = floorY - 30;
                    // Bed frame
                    ctx.fillStyle = '#DDD';
                    ctx.beginPath();
                    ctx.roundRect(bx - 35, by - 5, 70, 35, 4);
                    ctx.fill();
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.roundRect(bx - 35, by - 5, 70, 35, 4);
                    ctx.stroke();
                    // Bed legs
                    ctx.fillStyle = '#888';
                    ctx.fillRect(bx - 30, by + 25, 4, 8);
                    ctx.fillRect(bx + 26, by + 25, 4, 8);
                    // Blanket
                    ctx.fillStyle = '#87CEEB';
                    ctx.globalAlpha = 0.5;
                    ctx.fillRect(bx - 30, by + 5, 60, 20);
                    ctx.globalAlpha = 1;
                    // Pillow
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.ellipse(bx - 18, by + 2, 12, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Main patient on center bed
                if (pat) {
                    const patX = 270;
                    const patY = floorY - 55;
                    // Patient
                    ctx.fillStyle = pat.color;
                    ctx.beginPath();
                    ctx.arc(patX, patY, 18, 0, Math.PI * 2);
                    ctx.fill();
                    // Ears (animal)
                    if (pat.emoji !== 'üë©') {
                        ctx.beginPath();
                        ctx.moveTo(patX - 12, patY - 12);
                        ctx.lineTo(patX - 16, patY - 25);
                        ctx.lineTo(patX - 5, patY - 15);
                        ctx.closePath();
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(patX + 12, patY - 12);
                        ctx.lineTo(patX + 16, patY - 25);
                        ctx.lineTo(patX + 5, patY - 15);
                        ctx.closePath();
                        ctx.fill();
                    }
                    // Sad eyes
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(patX - 6, patY - 4, 2.5, 0, Math.PI * 2);
                    ctx.arc(patX + 6, patY - 4, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                    // Sad mouth
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(patX, patY + 8, 5, Math.PI + 0.3, -0.3);
                    ctx.stroke();
                    // Thermometer or bandage indicator
                    if (pat.game === 'thermometer') {
                        ctx.font = '16px serif';
                        ctx.fillText('üå°Ô∏è', patX + 20, patY - 5);
                    } else if (pat.game === 'bandage') {
                        ctx.font = '16px serif';
                        ctx.fillText('ü©π', patX + 20, patY - 5);
                    } else {
                        ctx.font = '16px serif';
                        ctx.fillText('üîç', patX + 20, patY - 5);
                    }

                    // Speech bubble from patient
                    ctx.fillStyle = 'rgba(255,255,255,0.95)';
                    ctx.beginPath();
                    ctx.roundRect(patX - 80, patY - 75, 160, 40, 10);
                    ctx.fill();
                    ctx.strokeStyle = '#5DADE2';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.roundRect(patX - 80, patY - 75, 160, 40, 10);
                    ctx.stroke();
                    // Tail
                    ctx.fillStyle = 'rgba(255,255,255,0.95)';
                    ctx.beginPath();
                    ctx.moveTo(patX - 5, patY - 35);
                    ctx.lineTo(patX, patY - 25);
                    ctx.lineTo(patX + 5, patY - 35);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#333';
                    ctx.font = 'bold 12px Comic Sans MS';
                    ctx.textAlign = 'center';
                    ctx.fillText(pat.problem + '... üò¢', patX, patY - 50);
                    ctx.fillText('Pom√≥≈º mi, doktorku!', patX, patY - 38);
                }

                // Doctor NPC (right side)
                const docX = canvas.width - 160;
                const docY = floorY - 50;
                // Body
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.ellipse(docX, docY + 15, 14, 18, 0, 0, Math.PI * 2);
                ctx.fill();
                // Head
                ctx.fillStyle = '#FFB74D';
                ctx.beginPath();
                ctx.arc(docX, docY - 10, 14, 0, Math.PI * 2);
                ctx.fill();
                // Stethoscope
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(docX, docY + 5, 8, 0.3, Math.PI - 0.3);
                ctx.stroke();
                ctx.fillStyle = '#87CEEB';
                ctx.beginPath();
                ctx.arc(docX, docY + 13, 4, 0, Math.PI * 2);
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(docX - 5, docY - 12, 2, 0, Math.PI * 2);
                ctx.arc(docX + 5, docY - 12, 2, 0, Math.PI * 2);
                ctx.fill();
                // Smile
                ctx.strokeStyle = '#FF69B4';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(docX, docY - 6, 5, 0.1, Math.PI - 0.1);
                ctx.stroke();
                // Doctor hat
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.roundRect(docX - 12, docY - 25, 24, 14, 3);
                ctx.fill();
                ctx.fillStyle = '#E74C3C';
                ctx.fillRect(docX - 4, docY - 22, 8, 2);
                ctx.fillRect(docX - 1, docY - 25, 2, 8);

                // Action prompt
                const barY = canvas.height - 40;
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath();
                ctx.roundRect(canvas.width / 2 - 200, barY, 400, 32, 10);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('SPACJA - Zbadaj pacjenta! ü©∫     ESC - Wyjd≈∫', canvas.width / 2, barY + 22);

            } else if (hospitalState.currentGame === 'thermometer') {
                drawThermometerGame();
            } else if (hospitalState.currentGame === 'bandage') {
                drawBandageGame();
            } else if (hospitalState.currentGame === 'xray') {
                drawXrayGame();
            }

            // ===== PLAYER on floor =====
            if (hospitalState.currentGame === null) {
                hospitalState.playerY = floorY - 40;
                const px = hospitalState.playerX;
                const py = hospitalState.playerY;
                const speed = 4;
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                    hospitalState.playerX -= speed;
                    player.facingRight = false;
                }
                if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                    hospitalState.playerX += speed;
                    player.facingRight = true;
                }
                hospitalState.playerX = Math.max(30, Math.min(canvas.width - 30, hospitalState.playerX));
                drawPlayer(px, py);

                // Exit hint
                ctx.textAlign = 'center';
                if (px < 90) {
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.beginPath();
                    ctx.roundRect(15, floorY - 98, 65, 18, 6);
                    ctx.fill();
                    ctx.fillStyle = '#5DADE2';
                    ctx.font = 'bold 10px Comic Sans MS';
                    ctx.fillText('SPACJA', 47, floorY - 85);
                }
            }

            // ===== MESSAGE =====
            if (hospitalState.message && hospitalState.messageTimer > 0) {
                ctx.fillStyle = 'rgba(0,0,0,0.75)';
                ctx.beginPath();
                ctx.roundRect(canvas.width / 2 - 180, canvas.height / 2 - 35, 360, 70, 12);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 18px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText(hospitalState.message, canvas.width / 2, canvas.height / 2 + 8);
            }
        }

        function drawThermometerGame() {
            const gd = hospitalState.gameData;
            const pat = hospitalState.patient;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            // Instructions
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('Zmierz temperaturƒô ' + pat.name + '! üå°Ô∏è', cx, 80);
            ctx.font = 'bold 13px Comic Sans MS';
            ctx.fillText('Naci≈õnij SPACJƒò gdy wska≈∫nik jest w ZIELONYM polu!', cx, 105);
            ctx.fillText('Pr√≥ba: ' + (gd.attempts + 1) + '/' + gd.maxAttempts, cx, 125);

            // Patient
            ctx.fillStyle = pat.color;
            ctx.beginPath();
            ctx.arc(cx - 120, cy, 25, 0, Math.PI * 2);
            ctx.fill();
            if (pat.emoji !== 'üë©') {
                ctx.beginPath();
                ctx.moveTo(cx - 132, cy - 18);
                ctx.lineTo(cx - 138, cy - 35);
                ctx.lineTo(cx - 125, cy - 22);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(cx - 108, cy - 18);
                ctx.lineTo(cx - 102, cy - 35);
                ctx.lineTo(cx - 115, cy - 22);
                ctx.closePath();
                ctx.fill();
            }
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(cx - 126, cy - 5, 3, 0, Math.PI * 2);
            ctx.arc(cx - 114, cy - 5, 3, 0, Math.PI * 2);
            ctx.fill();

            // Thermometer bar
            const barX = cx - 30;
            const barW = 200;
            const barH = 40;
            const barYPos = cy - 20;

            // Background
            ctx.fillStyle = '#DDD';
            ctx.beginPath();
            ctx.roundRect(barX, barYPos, barW, barH, 8);
            ctx.fill();

            // Red zone (left)
            ctx.fillStyle = 'rgba(231, 76, 60, 0.4)';
            ctx.fillRect(barX + 4, barYPos + 4, barW * gd.targetMin - 4, barH - 8);

            // Green zone (target)
            ctx.fillStyle = 'rgba(46, 204, 113, 0.5)';
            ctx.fillRect(barX + barW * gd.targetMin, barYPos + 4, barW * (gd.targetMax - gd.targetMin), barH - 8);

            // Red zone (right)
            ctx.fillStyle = 'rgba(231, 76, 60, 0.4)';
            ctx.fillRect(barX + barW * gd.targetMax, barYPos + 4, barW * (1 - gd.targetMax) - 4, barH - 8);

            // Labels
            ctx.font = 'bold 10px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#E74C3C';
            ctx.fillText('‚ùå', barX + barW * gd.targetMin / 2, barYPos + barH / 2 + 4);
            ctx.fillStyle = '#2ECC71';
            ctx.fillText('‚úÖ OK', barX + barW * (gd.targetMin + gd.targetMax) / 2, barYPos + barH / 2 + 4);
            ctx.fillStyle = '#E74C3C';
            ctx.fillText('‚ùå', barX + barW * (1 + gd.targetMax) / 2, barYPos + barH / 2 + 4);

            if (!gd.done) {
                // Moving indicator
                const indX = barX + gd.indicatorPos * barW;
                ctx.fillStyle = '#E74C3C';
                ctx.beginPath();
                ctx.moveTo(indX, barYPos - 5);
                ctx.lineTo(indX - 6, barYPos - 15);
                ctx.lineTo(indX + 6, barYPos - 15);
                ctx.closePath();
                ctx.fill();
                ctx.fillRect(indX - 1.5, barYPos, 3, barH);
            }

            // Result
            if (gd.done) {
                ctx.font = 'bold 22px Comic Sans MS';
                ctx.textAlign = 'center';
                if (gd.success) {
                    ctx.fillStyle = '#2ECC71';
                    ctx.fillText('Temperatura zmierzona! 36.6¬∞C üéâ', cx, cy + 70);
                    ctx.font = 'bold 14px Comic Sans MS';
                    ctx.fillText('Pacjent wyzdrowieje! ü™ô+2', cx, cy + 95);
                } else {
                    ctx.fillStyle = '#E74C3C';
                    ctx.fillText('Nie uda≈Ço siƒô... üòø', cx, cy + 70);
                    ctx.font = 'bold 14px Comic Sans MS';
                    ctx.fillText('Spr√≥buj jeszcze raz! SPACJA', cx, cy + 95);
                }
            }

            // Bottom bar
            if (!gd.done) {
                const barY = canvas.height - 40;
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath();
                ctx.roundRect(cx - 150, barY, 300, 32, 10);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('SPACJA - Zmierz! üå°Ô∏è', cx, barY + 22);
            }
        }

        function drawBandageGame() {
            const gd = hospitalState.gameData;
            const pat = hospitalState.patient;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('Zabanda≈ºuj ' + pat.name + '! ü©π', cx, 80);

            // Patient
            ctx.fillStyle = pat.color;
            ctx.beginPath();
            ctx.arc(cx, cy - 40, 30, 0, Math.PI * 2);
            ctx.fill();
            if (pat.emoji !== 'üë©') {
                ctx.beginPath();
                ctx.moveTo(cx - 18, cy - 60);
                ctx.lineTo(cx - 25, cy - 80);
                ctx.lineTo(cx - 10, cy - 65);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(cx + 18, cy - 60);
                ctx.lineTo(cx + 25, cy - 80);
                ctx.lineTo(cx + 10, cy - 65);
                ctx.closePath();
                ctx.fill();
            }
            // Eyes
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(cx - 8, cy - 45, 3, 0, Math.PI * 2);
            ctx.arc(cx + 8, cy - 45, 3, 0, Math.PI * 2);
            ctx.fill();

            // Bandage progress visualization
            if (gd.bandageProgress > 0) {
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 4;
                for (let bp = 0; bp < gd.bandageProgress; bp++) {
                    const angle = bp * 0.7;
                    const bpY = cy - 40 + Math.sin(angle) * 2;
                    ctx.beginPath();
                    ctx.moveTo(cx - 25 + bp * 3, bpY - 8);
                    ctx.lineTo(cx - 25 + bp * 3, bpY + 8);
                    ctx.stroke();
                }
            }

            if (gd.showSequence && gd.showTimer > 0) {
                // Show the sequence to memorize
                ctx.font = 'bold 14px Comic Sans MS';
                ctx.fillStyle = '#5DADE2';
                ctx.fillText('Zapamiƒôtaj kolejno≈õƒá ruch√≥w:', cx, cy + 30);

                const arrowSymbols = { 'ArrowUp': '‚¨ÜÔ∏è', 'ArrowDown': '‚¨áÔ∏è', 'ArrowLeft': '‚¨ÖÔ∏è', 'ArrowRight': '‚û°Ô∏è' };
                ctx.font = '28px serif';
                for (let i = 0; i < gd.sequence.length; i++) {
                    ctx.fillText(arrowSymbols[gd.sequence[i]], cx - 80 + i * 40, cy + 70);
                }

                ctx.font = 'bold 12px Comic Sans MS';
                ctx.fillStyle = '#999';
                ctx.fillText('Zaraz zniknie... ' + Math.ceil(gd.showTimer / 60), cx, cy + 100);
            } else if (!gd.done) {
                // Input phase
                ctx.font = 'bold 14px Comic Sans MS';
                ctx.fillStyle = '#333';
                ctx.fillText('Naci≈õnij strza≈Çki w odpowiedniej kolejno≈õci!', cx, cy + 30);

                const arrowSymbols = { 'ArrowUp': '‚¨ÜÔ∏è', 'ArrowDown': '‚¨áÔ∏è', 'ArrowLeft': '‚¨ÖÔ∏è', 'ArrowRight': '‚û°Ô∏è' };
                ctx.font = '28px serif';
                for (let i = 0; i < gd.sequence.length; i++) {
                    if (i < gd.currentStep) {
                        ctx.globalAlpha = 1;
                        ctx.fillStyle = '#2ECC71';
                        ctx.font = 'bold 24px Comic Sans MS';
                        ctx.fillText('‚úì', cx - 80 + i * 40, cy + 68);
                        ctx.font = '28px serif';
                    } else if (i === gd.currentStep) {
                        ctx.globalAlpha = 1;
                        ctx.fillText('‚ùì', cx - 80 + i * 40, cy + 68);
                    } else {
                        ctx.globalAlpha = 0.3;
                        ctx.fillText('‚¨ú', cx - 80 + i * 40, cy + 68);
                    }
                }
                ctx.globalAlpha = 1;

                ctx.font = 'bold 12px Comic Sans MS';
                ctx.fillStyle = '#E74C3C';
                ctx.fillText('B≈Çƒôdy: ' + gd.mistakes + '/' + gd.maxMistakes, cx, cy + 100);
            }

            if (gd.done) {
                ctx.font = 'bold 22px Comic Sans MS';
                ctx.textAlign = 'center';
                if (gd.success) {
                    ctx.fillStyle = '#2ECC71';
                    ctx.fillText('Zabanda≈ºowano! ü©πüéâ', cx, cy + 50);
                    ctx.font = 'bold 14px Comic Sans MS';
                    ctx.fillText('Pacjent wyzdrowieje! ü™ô+2', cx, cy + 80);
                } else {
                    ctx.fillStyle = '#E74C3C';
                    ctx.fillText('Nie uda≈Ço siƒô... üòø', cx, cy + 50);
                    ctx.font = 'bold 14px Comic Sans MS';
                    ctx.fillText('Spr√≥buj jeszcze raz! SPACJA', cx, cy + 80);
                }
            }
        }

        function drawXrayGame() {
            const gd = hospitalState.gameData;
            const pat = hospitalState.patient;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('Zr√≥b rentgen ' + pat.name + '! üîç', cx, 80);
            if (!gd.done) {
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('Strza≈Çkami przesu≈Ñ lupƒô, SPACJA - skanuj!', cx, 105);
            }

            // X-ray screen
            const scrX = cx - 120;
            const scrY = cy - 90;
            const scrW = 240;
            const scrH = 200;

            ctx.fillStyle = '#111';
            ctx.beginPath();
            ctx.roundRect(scrX - 5, scrY - 5, scrW + 10, scrH + 10, 8);
            ctx.fill();
            ctx.fillStyle = '#0A1A2A';
            ctx.fillRect(scrX, scrY, scrW, scrH);

            // Skeleton/body outline (xray style)
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
            ctx.lineWidth = 2;
            // Body outline
            ctx.beginPath();
            ctx.ellipse(cx, cy - 20, 40, 60, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Head
            ctx.beginPath();
            ctx.arc(cx, cy - 70, 20, 0, Math.PI * 2);
            ctx.stroke();
            // Ribs
            for (let r = 0; r < 4; r++) {
                ctx.beginPath();
                ctx.ellipse(cx, cy - 35 + r * 15, 25 - r * 2, 5, 0, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Target (pain spot - red glow)
            const targetPxX = scrX + gd.targetX * scrW;
            const targetPxY = scrY + gd.targetY * scrH;
            if (gd.found) {
                // Show found spot
                ctx.fillStyle = 'rgba(231, 76, 60, 0.6)';
                ctx.beginPath();
                ctx.arc(targetPxX, targetPxY, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#E74C3C';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(targetPxX, targetPxY, 15, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = '#E74C3C';
                ctx.font = 'bold 10px Comic Sans MS';
                ctx.fillText('TUTAJ!', targetPxX, targetPxY + 4);
            }

            // Scan lines effect
            if (gd.scanLines > 0) {
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.2)';
                ctx.lineWidth = 1;
                for (let sl = 0; sl < gd.scanLines; sl++) {
                    const sly = scrY + (sl * 5) % scrH;
                    ctx.beginPath();
                    ctx.moveTo(scrX, sly);
                    ctx.lineTo(scrX + scrW, sly);
                    ctx.stroke();
                }
            }

            if (!gd.done) {
                // Magnifying glass cursor
                const curPxX = scrX + gd.cursorX * scrW;
                const curPxY = scrY + gd.cursorY * scrH;

                // Proximity hint (warmer/colder)
                const dist = Math.sqrt(Math.pow(gd.cursorX - gd.targetX, 2) + Math.pow(gd.cursorY - gd.targetY, 2));
                let hintColor, hintText;
                if (dist < 0.08) {
                    hintColor = '#E74C3C';
                    hintText = 'GORƒÑCO! üî•';
                } else if (dist < 0.18) {
                    hintColor = '#E67E22';
                    hintText = 'Ciep≈Ço! ‚òÄÔ∏è';
                } else if (dist < 0.35) {
                    hintColor = '#F1C40F';
                    hintText = 'Cieplej... üå§Ô∏è';
                } else {
                    hintColor = '#3498DB';
                    hintText = 'Zimno ‚ùÑÔ∏è';
                }

                ctx.fillStyle = hintColor;
                ctx.font = 'bold 14px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText(hintText, cx, scrY + scrH + 25);

                // Magnifying glass
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(curPxX, curPxY, 18, 0, Math.PI * 2);
                ctx.stroke();
                // Glass shine
                ctx.fillStyle = 'rgba(100, 200, 255, 0.15)';
                ctx.beginPath();
                ctx.arc(curPxX, curPxY, 16, 0, Math.PI * 2);
                ctx.fill();
                // Handle
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(curPxX + 12, curPxY + 12);
                ctx.lineTo(curPxX + 25, curPxY + 25);
                ctx.stroke();
                // Crosshair
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(curPxX - 8, curPxY);
                ctx.lineTo(curPxX + 8, curPxY);
                ctx.moveTo(curPxX, curPxY - 8);
                ctx.lineTo(curPxX, curPxY + 8);
                ctx.stroke();
            }

            if (gd.done) {
                ctx.font = 'bold 22px Comic Sans MS';
                ctx.textAlign = 'center';
                if (gd.success) {
                    ctx.fillStyle = '#2ECC71';
                    ctx.fillText('Znaleziono! Diagnoza gotowa! üéâ', cx, scrY + scrH + 50);
                    ctx.font = 'bold 14px Comic Sans MS';
                    ctx.fillText('Pacjent wyzdrowieje! ü™ô+2', cx, scrY + scrH + 75);
                } else {
                    ctx.fillStyle = '#E74C3C';
                    ctx.fillText('Nie znaleziono... üòø', cx, scrY + scrH + 50);
                    ctx.font = 'bold 14px Comic Sans MS';
                    ctx.fillText('Spr√≥buj jeszcze raz! SPACJA', cx, scrY + scrH + 75);
                }
            }
        }

        function updateHospital() {
            if (hospitalState.messageTimer > 0) {
                hospitalState.messageTimer--;
            }

            if (hospitalState.currentGame === 'thermometer') {
                const gd = hospitalState.gameData;
                if (!gd.done) {
                    gd.indicatorPos += gd.speed * 0.015 * gd.indicatorDir;
                    if (gd.indicatorPos >= 1) { gd.indicatorPos = 1; gd.indicatorDir = -1; }
                    if (gd.indicatorPos <= 0) { gd.indicatorPos = 0; gd.indicatorDir = 1; }
                }
            } else if (hospitalState.currentGame === 'bandage') {
                const gd = hospitalState.gameData;
                if (gd.showSequence && gd.showTimer > 0) {
                    gd.showTimer--;
                    if (gd.showTimer <= 0) {
                        gd.showSequence = false;
                    }
                }
            } else if (hospitalState.currentGame === 'xray') {
                const gd = hospitalState.gameData;
                if (!gd.done) {
                    if (keys['ArrowLeft']) gd.cursorX = Math.max(0.05, gd.cursorX - 0.015);
                    if (keys['ArrowRight']) gd.cursorX = Math.min(0.95, gd.cursorX + 0.015);
                    if (keys['ArrowUp']) gd.cursorY = Math.max(0.05, gd.cursorY - 0.015);
                    if (keys['ArrowDown']) gd.cursorY = Math.min(0.95, gd.cursorY + 0.015);
                    gd.scanLines = (gd.scanLines + 1) % 60;
                }
            }
        }

        function handleHospitalSpace() {
            if (gameState !== 'hospital') return;

            if (hospitalState.currentGame === null) {
                // In lobby
                if (hospitalState.playerX < 100) {
                    exitHospital();
                    return;
                }
                // Start the mini-game
                startHospitalGame();
                return;
            }

            const gd = hospitalState.gameData;

            if (hospitalState.currentGame === 'thermometer') {
                if (gd.done) {
                    // Reset for new patient or exit
                    hospitalState.patient = hospitalPatients[Math.floor(Math.random() * hospitalPatients.length)];
                    hospitalState.currentGame = null;
                    hospitalState.gameData = {};
                    return;
                }
                // Check if indicator is in green zone
                if (gd.indicatorPos >= gd.targetMin && gd.indicatorPos <= gd.targetMax) {
                    gd.success = true;
                    gd.done = true;
                    addCoins(2);
                } else {
                    gd.attempts++;
                    if (gd.attempts >= gd.maxAttempts) {
                        gd.success = false;
                        gd.done = true;
                    }
                    // Speed up slightly
                    gd.speed += 0.2;
                }
            } else if (hospitalState.currentGame === 'bandage') {
                if (gd.done) {
                    hospitalState.patient = hospitalPatients[Math.floor(Math.random() * hospitalPatients.length)];
                    hospitalState.currentGame = null;
                    hospitalState.gameData = {};
                    return;
                }
                // During show phase, do nothing
                if (gd.showSequence) return;
            } else if (hospitalState.currentGame === 'xray') {
                if (gd.done) {
                    hospitalState.patient = hospitalPatients[Math.floor(Math.random() * hospitalPatients.length)];
                    hospitalState.currentGame = null;
                    hospitalState.gameData = {};
                    return;
                }
                // Check if cursor is near target
                const dist = Math.sqrt(Math.pow(gd.cursorX - gd.targetX, 2) + Math.pow(gd.cursorY - gd.targetY, 2));
                if (dist < 0.08) {
                    gd.found = true;
                    gd.success = true;
                    gd.done = true;
                    addCoins(2);
                } else {
                    hospitalState.message = 'Nie tutaj, szukaj dalej! üîç';
                    hospitalState.messageTimer = 40;
                }
            }
        }

        function handleHospitalArrow(key) {
            if (hospitalState.currentGame !== 'bandage') return;
            const gd = hospitalState.gameData;
            if (gd.done || gd.showSequence) return;

            if (key === gd.sequence[gd.currentStep]) {
                gd.currentStep++;
                gd.bandageProgress += 3;
                if (gd.currentStep >= gd.sequence.length) {
                    gd.success = true;
                    gd.done = true;
                    addCoins(2);
                }
            } else {
                gd.mistakes++;
                if (gd.mistakes >= gd.maxMistakes) {
                    gd.success = false;
                    gd.done = true;
                }
            }
        }

        // ===== PLAYGROUND (Plac Zabaw) System =====
        let playgrounds = [];
        let playgroundState = {
            active: false,
            playerX: 200,
            playerY: 0,
            currentGame: null, // null = lobby, 'swing', 'sandbox', 'jumprope'
            message: null,
            messageTimer: 0,
            gameData: {}
        };

        function enterPlayground() {
            if (houseCooldown > 0) return;
            gameState = 'playground';
            houseCooldown = 30;
            playgroundState.active = true;
            playgroundState.playerX = 200;
            playgroundState.playerY = 0;
            playgroundState.currentGame = null;
            playgroundState.message = null;
            playgroundState.messageTimer = 0;
            playgroundState.gameData = {};
            document.querySelector('.hud').style.display = 'none';
            document.querySelector('.friends-parade').style.display = 'none';
            document.querySelector('.wardrobe').style.display = 'none';
        }

        function exitPlayground() {
            if (houseCooldown > 0) return;
            gameState = 'world';
            houseCooldown = 30;
            playgroundState.active = false;
            playgroundState.currentGame = null;
            document.querySelector('.hud').style.display = '';
            document.querySelector('.friends-parade').style.display = '';
            document.querySelector('.wardrobe').style.display = '';
        }

        function startPlaygroundGame(gameType) {
            playgroundState.currentGame = gameType;
            if (gameType === 'swing') {
                playgroundState.gameData = {
                    angle: 0,
                    velocity: 0,
                    score: 0,
                    targetScore: 10,
                    timer: 600,
                    done: false,
                    success: false,
                    lastPress: 0
                };
            } else if (gameType === 'carousel') {
                playgroundState.gameData = {
                    angle: 0,
                    speed: 0.02,
                    stars: [],
                    score: 0,
                    targetScore: 6,
                    timer: 720, // 12 seconds
                    done: false,
                    success: false,
                    catchAnim: 0
                };
                // Spawn stars at random angles
                for (let i = 0; i < 8; i++) {
                    playgroundState.gameData.stars.push({
                        angle: (i / 8) * Math.PI * 2,
                        active: true,
                        radius: 80 + Math.random() * 20,
                        emoji: ['‚≠ê', 'üåü', 'üí´', '‚ú®'][Math.floor(Math.random() * 4)]
                    });
                }
            } else if (gameType === 'slide') {
                playgroundState.gameData = {
                    slidePos: 0, // 0 = top, 1 = bottom
                    slideSpeed: 0,
                    balance: 0, // -1 to 1, 0 = centered
                    balanceDrift: 0.01,
                    score: 0,
                    rounds: 0,
                    targetRounds: 3,
                    done: false,
                    success: false,
                    phase: 'climb' // 'climb', 'slide', 'land'
                };
            } else if (gameType === 'balance') {
                playgroundState.gameData = {
                    position: 0.5, // 0-1 on the beam
                    tilt: 0, // -1 to 1
                    tiltSpeed: 0,
                    tiltAccel: 0.003,
                    windTimer: 0,
                    windDir: 0,
                    score: 0,
                    targetScore: 100,
                    lives: 3,
                    done: false,
                    success: false,
                    walkDir: 1,
                    walkSpeed: 0.003
                };
            } else if (gameType === 'sandbox') {
                // Budowanie zamku z piasku - naciskaj strza≈Çki w pokazanej kolejno≈õci
                const shapes = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
                const layers = [];
                for (let i = 0; i < 4; i++) {
                    const row = [];
                    for (let j = 0; j < 3; j++) row.push(shapes[Math.floor(Math.random() * shapes.length)]);
                    layers.push(row);
                }
                playgroundState.gameData = {
                    layers: layers,
                    currentLayer: 0,
                    currentStep: 0,
                    mistakes: 0,
                    maxMistakes: 5,
                    done: false,
                    success: false,
                    builtHeight: 0
                };
            } else if (gameType === 'jumprope') {
                playgroundState.gameData = {
                    ropeAngle: 0,
                    ropeSpeed: 0.06,
                    jumping: false,
                    jumpY: 0,
                    jumpVel: 0,
                    score: 0,
                    targetScore: 8,
                    lives: 3,
                    done: false,
                    success: false,
                    hitCooldown: 0
                };
            }
        }

        function drawPlaygrounds() {
            const groundY = canvas.height - 100;
            playgrounds.forEach(pg => {
                const screenX = pg.x - worldOffset;
                if (screenX < -400 || screenX > canvas.width + 200) return;
                const screenY = groundY - pg.height;

                ctx.save();

                // Fence
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(screenX - 10, groundY);
                ctx.lineTo(screenX - 10, screenY + 40);
                ctx.lineTo(screenX + pg.width + 10, screenY + 40);
                ctx.lineTo(screenX + pg.width + 10, groundY);
                ctx.stroke();
                // Fence posts
                for (let fp = 0; fp < 6; fp++) {
                    const fpx = screenX - 10 + fp * ((pg.width + 20) / 5);
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(fpx - 2, screenY + 38, 4, groundY - screenY - 38);
                    // Post top
                    ctx.fillStyle = '#A0522D';
                    ctx.beginPath();
                    ctx.arc(fpx, screenY + 38, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Fence rails
                ctx.strokeStyle = '#A0522D';
                ctx.lineWidth = 2;
                const railY1 = screenY + 60;
                const railY2 = screenY + 90;
                ctx.beginPath();
                ctx.moveTo(screenX - 10, railY1);
                ctx.lineTo(screenX + pg.width + 10, railY1);
                ctx.moveTo(screenX - 10, railY2);
                ctx.lineTo(screenX + pg.width + 10, railY2);
                ctx.stroke();

                // Ground surface (sand/rubber)
                ctx.fillStyle = '#F4E4B0';
                ctx.fillRect(screenX, groundY - 5, pg.width, 10);

                // Sign arch
                ctx.strokeStyle = '#FF6B9D';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(screenX + pg.width / 2, screenY + 40, 60, Math.PI, 0);
                ctx.stroke();
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.roundRect(screenX + pg.width / 2 - 65, screenY + 10, 130, 25, 8);
                ctx.fill();
                ctx.strokeStyle = '#FF6B9D';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(screenX + pg.width / 2 - 65, screenY + 10, 130, 25, 8);
                ctx.stroke();
                ctx.fillStyle = '#FF6B9D';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('PLAC ZABAW üé™', screenX + pg.width / 2, screenY + 27);

                // Swing set (left)
                const swX = screenX + 50;
                ctx.fillStyle = '#E74C3C';
                ctx.fillRect(swX - 2, screenY + 45, 4, groundY - screenY - 45);
                ctx.fillRect(swX + 48, screenY + 45, 4, groundY - screenY - 45);
                ctx.fillRect(swX - 4, screenY + 45, 56, 4);
                // Swing seat
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(swX + 25, screenY + 49);
                ctx.lineTo(swX + 20, groundY - 30);
                ctx.moveTo(swX + 25, screenY + 49);
                ctx.lineTo(swX + 30, groundY - 30);
                ctx.stroke();
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(swX + 16, groundY - 30, 18, 4);

                // Sandbox (center)
                ctx.fillStyle = '#D2B48C';
                ctx.fillRect(screenX + 110, groundY - 20, 70, 20);
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX + 110, groundY - 20, 70, 20);
                ctx.font = '12px serif';
                ctx.fillText('üè∞', screenX + 145, groundY - 5);

                // Jump rope area (right)
                ctx.strokeStyle = '#FF69B4';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(screenX + 230, groundY - 15, 20, Math.PI, 0);
                ctx.stroke();
                ctx.setLineDash([]);

                // Decorations
                ctx.font = '16px serif';
                ctx.fillText('üåª', screenX + 5, groundY - 2);
                ctx.fillText('üå∑', screenX + pg.width - 20, groundY - 2);

                // Interaction hint
                const pgDoorScreenX = screenX + pg.width / 2;
                const playerScreenX = player.x - worldOffset;
                if (Math.abs(playerScreenX - pgDoorScreenX) < 150) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.roundRect(pgDoorScreenX - 80, screenY - 5, 160, 22, 8);
                    ctx.fill();
                    ctx.strokeStyle = '#FF6B9D';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.roundRect(pgDoorScreenX - 80, screenY - 5, 160, 22, 8);
                    ctx.stroke();
                    ctx.fillStyle = '#FF6B9D';
                    ctx.font = 'bold 12px Comic Sans MS';
                    ctx.textAlign = 'center';
                    ctx.fillText('SPACJA - Baw siƒô! üé™', pgDoorScreenX, screenY + 11);
                }

                ctx.restore();
            });
        }

        function drawPlayground() {
            const floorY = canvas.height - 100;
            const time = Date.now() / 1000;

            // ===== BACKGROUND =====
            // Sky
            const skyGrad = ctx.createLinearGradient(0, 0, 0, floorY);
            skyGrad.addColorStop(0, '#87CEEB');
            skyGrad.addColorStop(1, '#B0E0FF');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, canvas.width, floorY);

            // Clouds
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            for (let c = 0; c < 4; c++) {
                const cloudX = ((time * 15 + c * 200) % (canvas.width + 100)) - 50;
                const cloudY = 30 + c * 25;
                ctx.beginPath();
                ctx.arc(cloudX, cloudY, 20, 0, Math.PI * 2);
                ctx.arc(cloudX + 20, cloudY - 5, 15, 0, Math.PI * 2);
                ctx.arc(cloudX + 35, cloudY, 18, 0, Math.PI * 2);
                ctx.fill();
            }

            // Sun
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(canvas.width - 60, 50, 25, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFF59D';
            ctx.beginPath();
            ctx.arc(canvas.width - 60, 50, 20, 0, Math.PI * 2);
            ctx.fill();
            // Sun rays
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            for (let r = 0; r < 8; r++) {
                const ra = (r / 8) * Math.PI * 2 + time * 0.3;
                ctx.beginPath();
                ctx.moveTo(canvas.width - 60 + Math.cos(ra) * 28, 50 + Math.sin(ra) * 28);
                ctx.lineTo(canvas.width - 60 + Math.cos(ra) * 36, 50 + Math.sin(ra) * 36);
                ctx.stroke();
            }

            // Ground (grass + sand)
            ctx.fillStyle = '#90EE90';
            ctx.fillRect(0, floorY, canvas.width, canvas.height - floorY);
            ctx.fillStyle = '#F4E4B0';
            ctx.fillRect(50, floorY, canvas.width - 100, canvas.height - floorY);

            // ===== HEADER BAR =====
            ctx.fillStyle = 'rgba(255, 107, 157, 0.9)';
            ctx.beginPath();
            ctx.roundRect(10, 8, canvas.width - 20, 42, 12);
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 18px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('PLAC ZABAW üé™üé†', canvas.width / 2, 36);
            ctx.textAlign = 'left';
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.fillText('ü™ô ' + coins, 25, 36);
            ctx.textAlign = 'right';
            ctx.font = 'bold 12px Comic Sans MS';
            ctx.fillText('ESC - Wyjd≈∫', canvas.width - 25, 36);

            // ===== EXIT (left) =====
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(5, floorY - 80, 35, 80);
            ctx.fillStyle = '#A0522D';
            ctx.fillRect(8, floorY - 75, 29, 70);
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 8px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('WYJ≈öCIE', 22, floorY - 83);

            if (playgroundState.currentGame === null) {
                // ===== LOBBY - 6 game stations in 2 rows =====
                const stations = [
                    { name: 'Hu≈õtawka', color: '#E74C3C', emoji: 'üé¢', game: 'swing' },
                    { name: 'Karuzela', color: '#FF6B9D', emoji: 'üé†', game: 'carousel' },
                    { name: 'Zje≈ºd≈ºalnia', color: '#FF8C00', emoji: 'üõù', game: 'slide' },
                    { name: 'Piaskownica', color: '#DAA520', emoji: 'üè∞', game: 'sandbox' },
                    { name: 'Skakanka', color: '#FF69B4', emoji: 'ü§∏', game: 'jumprope' },
                    { name: 'R√≥wnowa≈ºnia', color: '#9C6ADE', emoji: 'ü§π', game: 'balance' }
                ];
                const cols = 3;
                const stW = (canvas.width - 100) / cols;
                const row1Y = 75;
                const row2Y = floorY - 95;

                for (let si = 0; si < stations.length; si++) {
                    const st = stations[si];
                    const col = si % cols;
                    const row = Math.floor(si / cols);
                    const sx = 60 + col * stW + stW / 2;
                    const sy = row === 0 ? row1Y : row2Y;

                    // Station card
                    ctx.fillStyle = 'rgba(255,255,255,0.85)';
                    ctx.beginPath();
                    ctx.roundRect(sx - 45, sy, 90, 80, 10);
                    ctx.fill();
                    ctx.strokeStyle = st.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.roundRect(sx - 45, sy, 90, 80, 10);
                    ctx.stroke();

                    // Highlight if player is near
                    const px = playgroundState.playerX;
                    const isNear = (row === 0 && px >= 60 + col * stW && px < 60 + (col + 1) * stW) ||
                                   (row === 1 && px >= 60 + col * stW && px < 60 + (col + 1) * stW);
                    if (isNear) {
                        ctx.fillStyle = st.color + '30';
                        ctx.beginPath();
                        ctx.roundRect(sx - 45, sy, 90, 80, 10);
                        ctx.fill();
                    }

                    // Emoji
                    ctx.font = '32px serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(st.emoji, sx, sy + 40);

                    // Name
                    ctx.fillStyle = st.color;
                    ctx.font = 'bold 11px Comic Sans MS';
                    ctx.fillText(st.name, sx, sy + 65);
                }

                // Animated decorations between stations
                // Swing animation (top-left)
                const swX = 60 + stW / 2;
                const swAng = Math.sin(time * 2) * 0.2;
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(swX, row1Y + 15);
                ctx.lineTo(swX + Math.sin(swAng) * 15, row1Y + 45);
                ctx.stroke();

                // Carousel animation (top-center)
                const crX = 60 + stW + stW / 2;
                for (let h = 0; h < 4; h++) {
                    const ha = time * 1.5 + (h / 4) * Math.PI * 2;
                    const hx = crX + Math.cos(ha) * 18;
                    const hy = row1Y + 30 + Math.sin(ha) * 8;
                    ctx.fillStyle = ['#FF6B9D', '#87CEEB', '#FFD700', '#90EE90'][h];
                    ctx.beginPath();
                    ctx.arc(hx, hy, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Flowers and butterflies
                ctx.font = '14px serif';
                ctx.fillText('üåª', 50, floorY + 5);
                ctx.fillText('üå∑', canvas.width - 50, floorY + 5);
                const bfx = 80 + Math.sin(time * 1.5) * 30;
                const bfy = row2Y - 15 + Math.cos(time * 2) * 10;
                ctx.font = '12px serif';
                ctx.fillText('ü¶ã', bfx, bfy);
                const bfx2 = canvas.width - 80 + Math.sin(time * 1.8 + 2) * 25;
                const bfy2 = row1Y - 5 + Math.cos(time * 1.6 + 1) * 8;
                ctx.fillText('ü¶ã', bfx2, bfy2);

                // Action prompt
                const barY = canvas.height - 40;
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath();
                ctx.roundRect(canvas.width / 2 - 250, barY, 500, 32, 10);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 12px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('Id≈∫ do zabawy i naci≈õnij SPACJƒò! üéÆ     ‚Üê ‚Üí Spacer     ESC Wyjd≈∫', canvas.width / 2, barY + 22);

            } else if (playgroundState.currentGame === 'swing') {
                drawSwingGame();
            } else if (playgroundState.currentGame === 'carousel') {
                drawCarouselGame();
            } else if (playgroundState.currentGame === 'slide') {
                drawSlideGame();
            } else if (playgroundState.currentGame === 'sandbox') {
                drawSandboxGame();
            } else if (playgroundState.currentGame === 'jumprope') {
                drawJumpropeGame();
            } else if (playgroundState.currentGame === 'balance') {
                drawBalanceGame();
            }

            // ===== PLAYER on ground =====
            if (playgroundState.currentGame === null) {
                playgroundState.playerY = floorY - 40;
                const px = playgroundState.playerX;
                const py = playgroundState.playerY;
                const speed = 4;
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                    playgroundState.playerX -= speed;
                    player.facingRight = false;
                }
                if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                    playgroundState.playerX += speed;
                    player.facingRight = true;
                }
                playgroundState.playerX = Math.max(30, Math.min(canvas.width - 30, playgroundState.playerX));
                drawPlayer(px, py);

                // Exit hint
                ctx.textAlign = 'center';
                if (px < 70) {
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.beginPath();
                    ctx.roundRect(5, floorY - 93, 55, 18, 6);
                    ctx.fill();
                    ctx.fillStyle = '#8B4513';
                    ctx.font = 'bold 10px Comic Sans MS';
                    ctx.fillText('SPACJA', 32, floorY - 80);
                }
            }

            // ===== MESSAGE =====
            if (playgroundState.message && playgroundState.messageTimer > 0) {
                ctx.fillStyle = 'rgba(0,0,0,0.75)';
                ctx.beginPath();
                ctx.roundRect(canvas.width / 2 - 180, canvas.height / 2 - 35, 360, 70, 12);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 18px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText(playgroundState.message, canvas.width / 2, canvas.height / 2 + 8);
            }
        }

        function drawSwingGame() {
            const gd = playgroundState.gameData;
            const cx = canvas.width / 2;
            const floorY = canvas.height - 100;

            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('Hu≈õtaj siƒô jak najwy≈ºej! üé¢', cx, 80);
            ctx.font = 'bold 13px Comic Sans MS';
            ctx.fillText('Naciskaj SPACJƒò w rytm hu≈õtania!', cx, 105);

            // Score & timer
            ctx.fillStyle = '#FF6B9D';
            ctx.font = 'bold 14px Comic Sans MS';
            ctx.fillText('Punkty: ' + gd.score + '/' + gd.targetScore, cx - 100, 130);
            ctx.fillStyle = gd.timer < 180 ? '#E74C3C' : '#333';
            ctx.fillText('Czas: ' + Math.ceil(gd.timer / 60) + 's', cx + 100, 130);

            // Swing frame
            const frameX = cx - 40;
            const frameTopY = 140;
            ctx.fillStyle = '#E74C3C';
            ctx.fillRect(frameX - 2, frameTopY, 4, floorY - frameTopY);
            ctx.fillRect(frameX + 78, frameTopY, 4, floorY - frameTopY);
            ctx.fillRect(frameX - 4, frameTopY - 3, 86, 6);

            if (!gd.done) {
                // Swing with player
                const pivotX = cx;
                const pivotY = frameTopY + 3;
                const chainLen = floorY - frameTopY - 60;
                const seatX = pivotX + Math.sin(gd.angle) * chainLen;
                const seatY = pivotY + Math.cos(gd.angle) * chainLen;

                // Chains
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(pivotX - 8, pivotY);
                ctx.lineTo(seatX - 8, seatY);
                ctx.moveTo(pivotX + 8, pivotY);
                ctx.lineTo(seatX + 8, seatY);
                ctx.stroke();

                // Seat
                ctx.fillStyle = '#8B4513';
                ctx.save();
                ctx.translate(seatX, seatY);
                ctx.rotate(gd.angle * 0.3);
                ctx.fillRect(-12, -3, 24, 6);
                ctx.restore();

                // Player on swing
                drawPlayer(seatX, seatY - 30);

                // Height indicator (stars when high)
                const absAngle = Math.abs(gd.angle);
                if (absAngle > 0.5) {
                    ctx.font = '20px serif';
                    ctx.fillText('‚≠ê', seatX + 25, seatY - 20);
                }
                if (absAngle > 0.8) {
                    ctx.fillText('‚≠ê', seatX - 25, seatY - 30);
                    ctx.fillText('‚ú®', seatX + 35, seatY - 40);
                }
            }

            if (gd.done) {
                ctx.font = 'bold 22px Comic Sans MS';
                ctx.textAlign = 'center';
                if (gd.success) {
                    ctx.fillStyle = '#2ECC71';
                    ctx.fillText('Super hu≈õtanie! üé¢üéâ', cx, canvas.height / 2);
                    ctx.font = 'bold 14px Comic Sans MS';
                    ctx.fillText('≈öwietna zabawa! ü™ô+1', cx, canvas.height / 2 + 30);
                } else {
                    ctx.fillStyle = '#E74C3C';
                    ctx.fillText('Czas minƒÖ≈Ç! üòø', cx, canvas.height / 2);
                    ctx.font = 'bold 14px Comic Sans MS';
                    ctx.fillText('Spr√≥buj jeszcze raz! SPACJA', cx, canvas.height / 2 + 30);
                }
            }

            if (!gd.done) {
                const barY = canvas.height - 40;
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath();
                ctx.roundRect(cx - 120, barY, 240, 32, 10);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('SPACJA - Hu≈õtaj! üé¢', cx, barY + 22);
            }
        }

        function drawSandboxGame() {
            const gd = playgroundState.gameData;
            const cx = canvas.width / 2;
            const floorY = canvas.height - 100;

            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('Zbuduj zamek z piasku! üè∞', cx, 80);
            ctx.font = 'bold 13px Comic Sans MS';
            ctx.fillText('Naci≈õnij strza≈Çki w pokazanej kolejno≈õci!', cx, 105);
            ctx.fillStyle = '#E74C3C';
            ctx.fillText('B≈Çƒôdy: ' + gd.mistakes + '/' + gd.maxMistakes, cx, 125);

            // Sandbox area
            ctx.fillStyle = '#D2B48C';
            ctx.beginPath();
            ctx.roundRect(cx - 120, floorY - 20, 240, 25, 6);
            ctx.fill();
            ctx.strokeStyle = '#A0522D';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(cx - 120, floorY - 20, 240, 25, 6);
            ctx.stroke();

            // Built castle layers
            const arrowSymbols = { 'ArrowUp': '‚¨ÜÔ∏è', 'ArrowDown': '‚¨áÔ∏è', 'ArrowLeft': '‚¨ÖÔ∏è', 'ArrowRight': '‚û°Ô∏è' };
            for (let l = 0; l < gd.currentLayer; l++) {
                const layW = 100 - l * 15;
                const layH = 25;
                const layX = cx - layW / 2;
                const layY = floorY - 25 - (l + 1) * layH;
                ctx.fillStyle = l % 2 === 0 ? '#DAA520' : '#D4A010';
                ctx.fillRect(layX, layY, layW, layH);
                ctx.strokeStyle = '#B8860B';
                ctx.lineWidth = 1;
                ctx.strokeRect(layX, layY, layW, layH);
                // Bricks pattern
                for (let bx = 0; bx < layW; bx += 20) {
                    ctx.strokeStyle = 'rgba(139, 69, 19, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(layX + bx, layY);
                    ctx.lineTo(layX + bx, layY + layH);
                    ctx.stroke();
                }
            }

            // Current layer being built
            if (!gd.done && gd.currentLayer < gd.layers.length) {
                const layer = gd.layers[gd.currentLayer];
                // Show current sequence
                ctx.font = '32px serif';
                const seqY = 180;
                for (let s = 0; s < layer.length; s++) {
                    const sx = cx - (layer.length * 45) / 2 + s * 45 + 20;
                    if (s < gd.currentStep) {
                        ctx.fillStyle = '#2ECC71';
                        ctx.font = 'bold 24px Comic Sans MS';
                        ctx.fillText('‚úì', sx, seqY);
                        ctx.font = '32px serif';
                    } else if (s === gd.currentStep) {
                        ctx.fillStyle = 'rgba(255,215,0,0.3)';
                        ctx.beginPath();
                        ctx.roundRect(sx - 18, seqY - 28, 36, 36, 6);
                        ctx.fill();
                        ctx.fillText(arrowSymbols[layer[s]], sx - 12, seqY);
                    } else {
                        ctx.fillText(arrowSymbols[layer[s]], sx - 12, seqY);
                    }
                }

                ctx.fillStyle = '#DAA520';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('Warstwa ' + (gd.currentLayer + 1) + '/' + gd.layers.length, cx, 220);
            }

            // Flag on top when done
            if (gd.done && gd.success) {
                const topY = floorY - 25 - gd.layers.length * 25;
                ctx.fillStyle = '#FF6B9D';
                ctx.fillRect(cx - 1, topY - 30, 2, 30);
                ctx.beginPath();
                ctx.moveTo(cx + 1, topY - 30);
                ctx.lineTo(cx + 18, topY - 22);
                ctx.lineTo(cx + 1, topY - 14);
                ctx.closePath();
                ctx.fill();
            }

            if (gd.done) {
                ctx.font = 'bold 22px Comic Sans MS';
                ctx.textAlign = 'center';
                if (gd.success) {
                    ctx.fillStyle = '#2ECC71';
                    ctx.fillText('Zamek zbudowany! üè∞üéâ', cx, canvas.height / 2 - 40);
                    ctx.font = 'bold 14px Comic Sans MS';
                    ctx.fillText('Piƒôkny zamek z piasku! ü™ô+1', cx, canvas.height / 2 - 15);
                } else {
                    ctx.fillStyle = '#E74C3C';
                    ctx.fillText('Zamek siƒô rozsypa≈Ç... üòø', cx, canvas.height / 2 - 40);
                    ctx.font = 'bold 14px Comic Sans MS';
                    ctx.fillText('Spr√≥buj jeszcze raz! SPACJA', cx, canvas.height / 2 - 15);
                }
            }
        }

        function drawJumpropeGame() {
            const gd = playgroundState.gameData;
            const cx = canvas.width / 2;
            const floorY = canvas.height - 100;

            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('Skacz przez skakankƒô! ü§∏', cx, 80);
            ctx.font = 'bold 13px Comic Sans MS';
            ctx.fillText('Naci≈õnij SPACJƒò ≈ºeby skoczyƒá gdy linka jest nisko!', cx, 105);

            // Score & lives
            ctx.fillStyle = '#FF6B9D';
            ctx.font = 'bold 14px Comic Sans MS';
            ctx.fillText('Skoki: ' + gd.score + '/' + gd.targetScore, cx - 100, 130);
            ctx.fillStyle = '#E74C3C';
            let hearts = '';
            for (let h = 0; h < gd.lives; h++) hearts += '‚ù§Ô∏è';
            for (let h = gd.lives; h < 3; h++) hearts += 'üñ§';
            ctx.fillText(hearts, cx + 100, 130);

            if (!gd.done) {
                // Rope holders (NPCs)
                const holderLX = cx - 100;
                const holderRX = cx + 100;

                // Left holder
                ctx.fillStyle = '#FFB74D';
                ctx.beginPath();
                ctx.arc(holderLX, floorY - 45, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FF69B4';
                ctx.beginPath();
                ctx.ellipse(holderLX, floorY - 25, 10, 14, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(holderLX - 4, floorY - 48, 2, 0, Math.PI * 2);
                ctx.arc(holderLX + 4, floorY - 48, 2, 0, Math.PI * 2);
                ctx.fill();

                // Right holder
                ctx.fillStyle = '#FFB74D';
                ctx.beginPath();
                ctx.arc(holderRX, floorY - 45, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#87CEEB';
                ctx.beginPath();
                ctx.ellipse(holderRX, floorY - 25, 10, 14, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(holderRX - 4, floorY - 48, 2, 0, Math.PI * 2);
                ctx.arc(holderRX + 4, floorY - 48, 2, 0, Math.PI * 2);
                ctx.fill();

                // Arms holding rope
                ctx.strokeStyle = '#FFB74D';
                ctx.lineWidth = 4;
                const armEndY = floorY - 35;
                ctx.beginPath();
                ctx.moveTo(holderLX + 10, floorY - 30);
                ctx.lineTo(holderLX + 18, armEndY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(holderRX - 10, floorY - 30);
                ctx.lineTo(holderRX - 18, armEndY);
                ctx.stroke();

                // Rope
                const ropeSin = Math.sin(gd.ropeAngle);
                const ropeHeight = ropeSin * 70;
                ctx.strokeStyle = '#FF1493';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(holderLX + 18, armEndY);
                ctx.quadraticCurveTo(cx, floorY - 10 - ropeHeight, holderRX - 18, armEndY);
                ctx.stroke();

                // Player jumping
                const playerDrawY = floorY - 40 - gd.jumpY;
                drawPlayer(cx, playerDrawY);

                // Jump shadow
                if (gd.jumpY > 5) {
                    ctx.fillStyle = 'rgba(0,0,0,0.15)';
                    ctx.beginPath();
                    ctx.ellipse(cx, floorY - 5, 15 - gd.jumpY * 0.1, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Danger indicator
                const ropeBottom = floorY - 10 - ropeHeight;
                if (ropeHeight < 15 && gd.jumpY < 10) {
                    ctx.fillStyle = 'rgba(231, 76, 60, 0.3)';
                    ctx.beginPath();
                    ctx.roundRect(cx - 30, floorY - 50, 60, 15, 4);
                    ctx.fill();
                    ctx.fillStyle = '#E74C3C';
                    ctx.font = 'bold 10px Comic Sans MS';
                    ctx.fillText('SKACZ!', cx, floorY - 40);
                }
            }

            if (gd.done) {
                ctx.font = 'bold 22px Comic Sans MS';
                ctx.textAlign = 'center';
                if (gd.success) {
                    ctx.fillStyle = '#2ECC71';
                    ctx.fillText('Super skakanie! ü§∏üéâ', cx, canvas.height / 2);
                    ctx.font = 'bold 14px Comic Sans MS';
                    ctx.fillText('≈öwietna zabawa! ü™ô+1', cx, canvas.height / 2 + 30);
                } else {
                    ctx.fillStyle = '#E74C3C';
                    ctx.fillText('Potkniƒôcie! üòø', cx, canvas.height / 2);
                    ctx.font = 'bold 14px Comic Sans MS';
                    ctx.fillText('Spr√≥buj jeszcze raz! SPACJA', cx, canvas.height / 2 + 30);
                }
            }

            if (!gd.done) {
                const barY = canvas.height - 40;
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath();
                ctx.roundRect(cx - 120, barY, 240, 32, 10);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('SPACJA - Skacz! ü§∏', cx, barY + 22);
            }
        }

        function drawCarouselGame() {
            const gd = playgroundState.gameData;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2 - 20;
            const floorY = canvas.height - 100;

            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('Karuzela - ≈Åap gwiazdki! üé†', cx, 80);
            ctx.font = 'bold 13px Comic Sans MS';
            ctx.fillText('Naci≈õnij SPACJƒò gdy gwiazdka jest blisko Ciebie!', cx, 105);

            ctx.fillStyle = '#FF6B9D';
            ctx.font = 'bold 14px Comic Sans MS';
            ctx.fillText('‚≠ê ' + gd.score + '/' + gd.targetScore, cx - 100, 130);
            ctx.fillStyle = gd.timer < 180 ? '#E74C3C' : '#333';
            ctx.fillText('Czas: ' + Math.ceil(gd.timer / 60) + 's', cx + 100, 130);

            // Carousel base
            ctx.fillStyle = '#DDD';
            ctx.beginPath();
            ctx.ellipse(cx, cy + 50, 100, 25, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#BBB';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(cx, cy + 50, 100, 25, 0, 0, Math.PI * 2);
            ctx.stroke();

            // Center pole
            ctx.fillStyle = '#FF6B9D';
            ctx.fillRect(cx - 4, cy - 60, 8, 110);
            // Top canopy
            ctx.fillStyle = '#FF6B9D';
            ctx.beginPath();
            ctx.moveTo(cx - 80, cy - 30);
            ctx.lineTo(cx, cy - 70);
            ctx.lineTo(cx + 80, cy - 30);
            ctx.closePath();
            ctx.fill();
            // Canopy stripes
            for (let cs = 0; cs < 8; cs++) {
                ctx.strokeStyle = cs % 2 === 0 ? '#FFF' : '#FF6B9D';
                ctx.lineWidth = 2;
                const csa = -0.5 + (cs / 8) * 1.0;
                ctx.beginPath();
                ctx.moveTo(cx, cy - 70);
                ctx.lineTo(cx + Math.sin(csa) * 80, cy - 30);
                ctx.stroke();
            }
            // Top flag
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(cx, cy - 72);
            ctx.lineTo(cx + 10, cy - 78);
            ctx.lineTo(cx, cy - 84);
            ctx.closePath();
            ctx.fill();
            ctx.fillRect(cx - 1, cy - 84, 2, 15);

            if (!gd.done) {
                // Horses on carousel
                const horseColors = ['#E74C3C', '#3498DB', '#2ECC71', '#F39C12', '#9B59B6'];
                for (let h = 0; h < 5; h++) {
                    const ha = gd.angle + (h / 5) * Math.PI * 2;
                    const hx = cx + Math.cos(ha) * 70;
                    const hy = cy + 20 + Math.sin(ha) * 18;
                    const hscale = 0.6 + (Math.sin(ha) + 1) * 0.2;
                    // Pole
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(hx, hy - 20 * hscale);
                    ctx.lineTo(hx, cy - 30);
                    ctx.stroke();
                    // Horse body
                    ctx.fillStyle = horseColors[h];
                    ctx.beginPath();
                    ctx.ellipse(hx, hy, 12 * hscale, 8 * hscale, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Head
                    ctx.beginPath();
                    ctx.arc(hx + 10 * hscale * Math.cos(ha + 0.3), hy - 6 * hscale, 5 * hscale, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Stars orbiting
                gd.stars.forEach(star => {
                    if (!star.active) return;
                    const sa = star.angle + gd.angle;
                    const starX = cx + Math.cos(sa) * star.radius;
                    const starY = cy + 15 + Math.sin(sa) * (star.radius * 0.25);
                    ctx.font = '20px serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(star.emoji, starX, starY);
                });

                // Player position (bottom of carousel)
                const playerAngle = Math.PI / 2; // always at bottom
                const playerX = cx;
                const playerY = cy + 60;
                drawPlayer(playerX - 15, playerY - 20);

                // Catch zone indicator
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(playerX, playerY - 10, 30, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Catch animation
            if (gd.catchAnim > 0) {
                ctx.font = 'bold 20px Comic Sans MS';
                ctx.fillStyle = '#FFD700';
                ctx.textAlign = 'center';
                ctx.fillText('‚≠ê +1!', cx, cy + 90 - gd.catchAnim);
            }

            if (gd.done) {
                ctx.font = 'bold 22px Comic Sans MS';
                ctx.textAlign = 'center';
                if (gd.success) {
                    ctx.fillStyle = '#2ECC71';
                    ctx.fillText('Super karuzela! üé†üéâ', cx, canvas.height / 2 + 40);
                    ctx.font = 'bold 14px Comic Sans MS';
                    ctx.fillText('Z≈Çapano wszystkie gwiazdki! ü™ô+1', cx, canvas.height / 2 + 65);
                } else {
                    ctx.fillStyle = '#E74C3C';
                    ctx.fillText('Czas minƒÖ≈Ç! üòø', cx, canvas.height / 2 + 40);
                    ctx.font = 'bold 14px Comic Sans MS';
                    ctx.fillText('Spr√≥buj jeszcze raz! SPACJA', cx, canvas.height / 2 + 65);
                }
            }

            if (!gd.done) {
                const barY = canvas.height - 40;
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath();
                ctx.roundRect(cx - 130, barY, 260, 32, 10);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('SPACJA - ≈Åap gwiazdkƒô! ‚≠ê', cx, barY + 22);
            }
        }

        function drawSlideGame() {
            const gd = playgroundState.gameData;
            const cx = canvas.width / 2;
            const floorY = canvas.height - 100;

            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('Zje≈ºd≈ºalnia! üõù', cx, 80);
            ctx.font = 'bold 13px Comic Sans MS';
            if (gd.phase === 'climb') {
                ctx.fillText('Naci≈õnij SPACJƒò ≈ºeby wej≈õƒá na g√≥rkƒô!', cx, 105);
            } else if (gd.phase === 'slide') {
                ctx.fillText('‚Üê ‚Üí Utrzymaj r√≥wnowagƒô podczas zjazdu!', cx, 105);
            } else {
                ctx.fillText('Super lƒÖdowanie!', cx, 105);
            }
            ctx.fillStyle = '#FF8C00';
            ctx.font = 'bold 14px Comic Sans MS';
            ctx.fillText('Zjazd: ' + gd.rounds + '/' + gd.targetRounds, cx, 130);

            // Slide structure
            const slideTopX = cx - 80;
            const slideTopY = 160;
            const slideBotX = cx + 100;
            const slideBotY = floorY - 20;

            // Ladder
            ctx.fillStyle = '#E74C3C';
            ctx.fillRect(slideTopX - 25, slideTopY, 4, slideBotY - slideTopY);
            ctx.fillRect(slideTopX - 5, slideTopY, 4, slideBotY - slideTopY);
            // Rungs
            for (let r = 0; r < 6; r++) {
                const ry = slideTopY + 30 + r * 40;
                ctx.fillRect(slideTopX - 25, ry, 24, 3);
            }

            // Slide surface
            ctx.strokeStyle = '#FF8C00';
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(slideTopX + 10, slideTopY + 10);
            ctx.quadraticCurveTo(cx + 20, (slideTopY + slideBotY) / 2 + 30, slideBotX, slideBotY);
            ctx.stroke();
            // Slide surface fill
            ctx.strokeStyle = '#FFA500';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(slideTopX + 10, slideTopY + 10);
            ctx.quadraticCurveTo(cx + 20, (slideTopY + slideBotY) / 2 + 30, slideBotX, slideBotY);
            ctx.stroke();

            // Slide rails
            ctx.strokeStyle = '#E74C3C';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(slideTopX + 3, slideTopY + 5);
            ctx.quadraticCurveTo(cx + 13, (slideTopY + slideBotY) / 2 + 25, slideBotX - 7, slideBotY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(slideTopX + 17, slideTopY + 5);
            ctx.quadraticCurveTo(cx + 27, (slideTopY + slideBotY) / 2 + 25, slideBotX + 7, slideBotY);
            ctx.stroke();

            // Platform at top
            ctx.fillStyle = '#E74C3C';
            ctx.beginPath();
            ctx.roundRect(slideTopX - 30, slideTopY - 5, 50, 20, 3);
            ctx.fill();

            if (!gd.done) {
                // Player position on slide
                const t = gd.slidePos;
                // Bezier interpolation
                const pMidX = cx + 20;
                const pMidY = (slideTopY + slideBotY) / 2 + 30;
                const playerSX = (1 - t) * (1 - t) * (slideTopX + 10) + 2 * (1 - t) * t * pMidX + t * t * slideBotX;
                const playerSY = (1 - t) * (1 - t) * (slideTopY + 10) + 2 * (1 - t) * t * pMidY + t * t * slideBotY;

                if (gd.phase === 'climb') {
                    // Player at bottom of ladder
                    drawPlayer(slideTopX - 30, slideBotY - 60);
                } else if (gd.phase === 'slide') {
                    // Balance indicator
                    const balBarW = 120;
                    const balBarX = cx - balBarW / 2;
                    const balBarY = 150;
                    ctx.fillStyle = '#DDD';
                    ctx.beginPath();
                    ctx.roundRect(balBarX, balBarY, balBarW, 12, 4);
                    ctx.fill();
                    // Green center zone
                    ctx.fillStyle = 'rgba(46, 204, 113, 0.5)';
                    ctx.fillRect(balBarX + balBarW * 0.35, balBarY + 2, balBarW * 0.3, 8);
                    // Red edges
                    ctx.fillStyle = 'rgba(231, 76, 60, 0.3)';
                    ctx.fillRect(balBarX + 2, balBarY + 2, balBarW * 0.15, 8);
                    ctx.fillRect(balBarX + balBarW * 0.85, balBarY + 2, balBarW * 0.15 - 2, 8);
                    // Indicator
                    const indX = balBarX + (gd.balance + 1) / 2 * balBarW;
                    ctx.fillStyle = '#E74C3C';
                    ctx.beginPath();
                    ctx.arc(indX, balBarY + 6, 6, 0, Math.PI * 2);
                    ctx.fill();

                    // Player on slide with slight tilt
                    ctx.save();
                    ctx.translate(playerSX, playerSY - 20);
                    ctx.rotate(gd.balance * 0.3);
                    drawPlayer(-15, -20);
                    ctx.restore();

                    // Speed lines
                    if (gd.slideSpeed > 0.005) {
                        ctx.strokeStyle = 'rgba(255, 140, 0, 0.4)';
                        ctx.lineWidth = 2;
                        for (let sl = 0; sl < 3; sl++) {
                            const slx = playerSX - 20 - sl * 8;
                            const sly = playerSY - 15 + sl * 5;
                            ctx.beginPath();
                            ctx.moveTo(slx, sly);
                            ctx.lineTo(slx - 15, sly + 5);
                            ctx.stroke();
                        }
                    }
                } else if (gd.phase === 'land') {
                    drawPlayer(slideBotX - 15, slideBotY - 50);
                    ctx.font = 'bold 16px Comic Sans MS';
                    ctx.fillStyle = '#2ECC71';
                    ctx.fillText('Super! üåü', slideBotX, slideBotY - 60);
                }
            }

            if (gd.done) {
                ctx.font = 'bold 22px Comic Sans MS';
                ctx.textAlign = 'center';
                if (gd.success) {
                    ctx.fillStyle = '#2ECC71';
                    ctx.fillText('Mistrz zje≈ºd≈ºalni! üõùüéâ', cx, canvas.height / 2);
                    ctx.font = 'bold 14px Comic Sans MS';
                    ctx.fillText('Super zjazdy! ü™ô+1', cx, canvas.height / 2 + 30);
                } else {
                    ctx.fillStyle = '#E74C3C';
                    ctx.fillText('Spad≈Çe≈õ ze zje≈ºd≈ºalni! üòø', cx, canvas.height / 2);
                    ctx.font = 'bold 14px Comic Sans MS';
                    ctx.fillText('Spr√≥buj jeszcze raz! SPACJA', cx, canvas.height / 2 + 30);
                }
            }
        }

        function drawBalanceGame() {
            const gd = playgroundState.gameData;
            const cx = canvas.width / 2;
            const floorY = canvas.height - 100;

            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('R√≥wnowa≈ºnia - Utrzymaj r√≥wnowagƒô! ü§π', cx, 80);
            ctx.font = 'bold 13px Comic Sans MS';
            ctx.fillText('‚Üê ‚Üí Utrzymuj siƒô na belce!', cx, 105);

            ctx.fillStyle = '#9C6ADE';
            ctx.font = 'bold 14px Comic Sans MS';
            ctx.fillText('Punkty: ' + gd.score + '/' + gd.targetScore, cx - 100, 130);
            let hearts = '';
            for (let h = 0; h < gd.lives; h++) hearts += '‚ù§Ô∏è';
            for (let h = gd.lives; h < 3; h++) hearts += 'üñ§';
            ctx.fillStyle = '#E74C3C';
            ctx.fillText(hearts, cx + 100, 130);

            // Wind indicator
            if (gd.windDir !== 0) {
                ctx.fillStyle = 'rgba(100, 100, 255, 0.6)';
                ctx.font = 'bold 12px Comic Sans MS';
                const windText = gd.windDir > 0 ? 'Wiatr ‚Üí üí®' : 'üí® ‚Üê Wiatr';
                ctx.fillText(windText, cx, 150);
            }

            // Balance beam
            const beamX = cx - 120;
            const beamW = 240;
            const beamY = floorY - 40;
            // Support posts
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(beamX - 5, beamY, 10, floorY - beamY);
            ctx.fillRect(beamX + beamW - 5, beamY, 10, floorY - beamY);
            // Beam
            ctx.fillStyle = '#9C6ADE';
            ctx.beginPath();
            ctx.roundRect(beamX, beamY - 4, beamW, 8, 3);
            ctx.fill();
            ctx.strokeStyle = '#7B52AB';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(beamX, beamY - 4, beamW, 8, 3);
            ctx.stroke();

            // Beam markings
            for (let m = 0; m < 5; m++) {
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.fillRect(beamX + 20 + m * 50, beamY - 2, 2, 4);
            }

            if (!gd.done) {
                // Player on beam
                const playerBeamX = beamX + gd.position * beamW;

                // Tilt indicator above player
                const tiltBarW = 80;
                const tiltBarX = playerBeamX - tiltBarW / 2;
                const tiltBarY = beamY - 80;
                ctx.fillStyle = '#EEE';
                ctx.beginPath();
                ctx.roundRect(tiltBarX, tiltBarY, tiltBarW, 10, 3);
                ctx.fill();
                // Green safe zone
                ctx.fillStyle = 'rgba(46, 204, 113, 0.4)';
                ctx.fillRect(tiltBarX + tiltBarW * 0.3, tiltBarY + 1, tiltBarW * 0.4, 8);
                // Tilt dot
                const tiltDotX = tiltBarX + (gd.tilt + 1) / 2 * tiltBarW;
                const dotColor = Math.abs(gd.tilt) > 0.7 ? '#E74C3C' : Math.abs(gd.tilt) > 0.4 ? '#F39C12' : '#2ECC71';
                ctx.fillStyle = dotColor;
                ctx.beginPath();
                ctx.arc(tiltDotX, tiltBarY + 5, 5, 0, Math.PI * 2);
                ctx.fill();

                // Player tilted
                ctx.save();
                ctx.translate(playerBeamX, beamY - 5);
                ctx.rotate(gd.tilt * 0.2);
                drawPlayer(-15, -55);
                ctx.restore();

                // Wobble effect particles
                if (Math.abs(gd.tilt) > 0.5) {
                    ctx.font = '10px serif';
                    ctx.fillText('üí¶', playerBeamX + 20, beamY - 30);
                }
            }

            if (gd.done) {
                ctx.font = 'bold 22px Comic Sans MS';
                ctx.textAlign = 'center';
                if (gd.success) {
                    ctx.fillStyle = '#2ECC71';
                    ctx.fillText('≈öwietna r√≥wnowaga! ü§πüéâ', cx, canvas.height / 2);
                    ctx.font = 'bold 14px Comic Sans MS';
                    ctx.fillText('Akrobata! ü™ô+1', cx, canvas.height / 2 + 30);
                } else {
                    ctx.fillStyle = '#E74C3C';
                    ctx.fillText('Spad≈Çe≈õ z belki! üòø', cx, canvas.height / 2);
                    ctx.font = 'bold 14px Comic Sans MS';
                    ctx.fillText('Spr√≥buj jeszcze raz! SPACJA', cx, canvas.height / 2 + 30);
                }
            }

            if (!gd.done) {
                const barY = canvas.height - 40;
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath();
                ctx.roundRect(cx - 130, barY, 260, 32, 10);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('‚Üê ‚Üí Balansuj! ü§π', cx, barY + 22);
            }
        }

        function updatePlayground() {
            if (playgroundState.messageTimer > 0) {
                playgroundState.messageTimer--;
            }

            if (playgroundState.currentGame === 'swing') {
                const gd = playgroundState.gameData;
                if (!gd.done) {
                    // Physics: pendulum with damping
                    const gravity = 0.004;
                    gd.velocity -= gravity * Math.sin(gd.angle);
                    gd.velocity *= 0.998; // slight damping
                    gd.angle += gd.velocity;

                    // Score based on height
                    if (Math.abs(gd.angle) > 0.7 && gd.lastPress > 0) {
                        gd.lastPress--;
                    }

                    gd.timer--;
                    if (gd.timer <= 0) {
                        gd.done = true;
                        gd.success = gd.score >= gd.targetScore;
                        if (gd.success) addCoins(1);
                    }
                }
            } else if (playgroundState.currentGame === 'carousel') {
                const gd = playgroundState.gameData;
                if (!gd.done) {
                    gd.angle += gd.speed;
                    gd.timer--;
                    if (gd.catchAnim > 0) gd.catchAnim--;
                    // Speed up slowly
                    gd.speed = Math.min(0.05, gd.speed + 0.00005);
                    if (gd.timer <= 0) {
                        gd.done = true;
                        gd.success = gd.score >= gd.targetScore;
                        if (gd.success) addCoins(1);
                    }
                }
            } else if (playgroundState.currentGame === 'slide') {
                const gd = playgroundState.gameData;
                if (!gd.done && gd.phase === 'slide') {
                    gd.slideSpeed += 0.0005;
                    gd.slidePos += gd.slideSpeed;
                    // Balance drifts randomly
                    gd.balance += gd.balanceDrift;
                    gd.balanceDrift += (Math.random() - 0.5) * 0.004;
                    gd.balanceDrift = Math.max(-0.02, Math.min(0.02, gd.balanceDrift));
                    // Player correction via arrows
                    if (keys['ArrowLeft']) gd.balance -= 0.03;
                    if (keys['ArrowRight']) gd.balance += 0.03;
                    gd.balance = Math.max(-1, Math.min(1, gd.balance));

                    if (Math.abs(gd.balance) > 0.9) {
                        // Fell off!
                        gd.done = true;
                        gd.success = false;
                    }

                    if (gd.slidePos >= 1) {
                        gd.rounds++;
                        gd.phase = 'land';
                        gd.slidePos = 0;
                        gd.slideSpeed = 0;
                        gd.balance = 0;
                        gd.balanceDrift = 0.01;
                        if (gd.rounds >= gd.targetRounds) {
                            gd.done = true;
                            gd.success = true;
                            addCoins(1);
                        } else {
                            // Brief land phase
                            setTimeout(() => {
                                if (playgroundState.currentGame === 'slide' && !playgroundState.gameData.done) {
                                    playgroundState.gameData.phase = 'climb';
                                }
                            }, 500);
                        }
                    }
                }
            } else if (playgroundState.currentGame === 'balance') {
                const gd = playgroundState.gameData;
                if (!gd.done) {
                    // Walk forward
                    gd.position += gd.walkSpeed * gd.walkDir;
                    if (gd.position >= 1 || gd.position <= 0) {
                        gd.walkDir *= -1;
                        gd.position = Math.max(0, Math.min(1, gd.position));
                    }

                    // Tilt drifts
                    gd.tiltSpeed += gd.tiltAccel * (Math.random() - 0.5) * 2;
                    // Wind gusts
                    gd.windTimer--;
                    if (gd.windTimer <= 0) {
                        gd.windDir = (Math.random() - 0.5) * 0.006;
                        gd.windTimer = 120 + Math.random() * 180;
                    }
                    gd.tiltSpeed += gd.windDir;
                    gd.tiltSpeed *= 0.99; // damping
                    gd.tilt += gd.tiltSpeed;

                    // Player correction
                    if (keys['ArrowLeft']) gd.tilt -= 0.025;
                    if (keys['ArrowRight']) gd.tilt += 0.025;

                    gd.tilt = Math.max(-1, Math.min(1, gd.tilt));

                    // Score if balanced
                    if (Math.abs(gd.tilt) < 0.4) {
                        gd.score++;
                        if (gd.score >= gd.targetScore) {
                            gd.done = true;
                            gd.success = true;
                            addCoins(1);
                        }
                    }

                    // Fall if too tilted
                    if (Math.abs(gd.tilt) > 0.95) {
                        gd.lives--;
                        gd.tilt = 0;
                        gd.tiltSpeed = 0;
                        if (gd.lives <= 0) {
                            gd.done = true;
                            gd.success = false;
                        }
                    }

                    // Increase difficulty
                    gd.tiltAccel = 0.003 + (gd.score / gd.targetScore) * 0.003;
                }
            } else if (playgroundState.currentGame === 'jumprope') {
                const gd = playgroundState.gameData;
                if (!gd.done) {
                    gd.ropeAngle += gd.ropeSpeed;

                    // Jump physics
                    if (gd.jumping) {
                        gd.jumpVel -= 0.8;
                        gd.jumpY += gd.jumpVel;
                        if (gd.jumpY <= 0) {
                            gd.jumpY = 0;
                            gd.jumping = false;
                            gd.jumpVel = 0;
                        }
                    }

                    // Hit cooldown
                    if (gd.hitCooldown > 0) gd.hitCooldown--;

                    // Check rope collision
                    const ropeSin = Math.sin(gd.ropeAngle);
                    const ropeHeight = ropeSin * 70;
                    const prevSin = Math.sin(gd.ropeAngle - gd.ropeSpeed);
                    if (prevSin > 0 && ropeSin <= 0) {
                        if (gd.jumpY < 25) {
                            if (gd.hitCooldown <= 0) {
                                gd.lives--;
                                gd.hitCooldown = 30;
                                if (gd.lives <= 0) {
                                    gd.done = true;
                                    gd.success = false;
                                }
                            }
                        } else {
                            gd.score++;
                            if (gd.score >= gd.targetScore) {
                                gd.done = true;
                                gd.success = true;
                                addCoins(1);
                            }
                            gd.ropeSpeed = Math.min(0.12, gd.ropeSpeed + 0.005);
                        }
                    }
                }
            }
        }

        function handlePlaygroundSpace() {
            if (gameState !== 'playground') return;

            if (playgroundState.currentGame === null) {
                // In lobby - check position for which game (6 games, 3 columns)
                const px = playgroundState.playerX;
                if (px < 70) {
                    exitPlayground();
                    return;
                }
                const stW = (canvas.width - 100) / 3;
                const col = Math.floor((px - 60) / stW);
                const clampedCol = Math.max(0, Math.min(2, col));
                // Top row games: swing, carousel, slide
                // Bottom row games: sandbox, jumprope, balance
                // Pick based on column (top row by default, bottom if near bottom)
                const games = [
                    ['swing', 'carousel', 'slide'],
                    ['sandbox', 'jumprope', 'balance']
                ];
                // Simple: just pick top row for now, bottom row if player already played top
                const row = (playgroundState.playerY || 0) > canvas.height / 2 ? 1 : 0;
                startPlaygroundGame(games[row][clampedCol]);
                return;
            }

            const gd = playgroundState.gameData;

            if (playgroundState.currentGame === 'swing') {
                if (gd.done) {
                    playgroundState.currentGame = null;
                    playgroundState.gameData = {};
                    return;
                }
                // Push swing: add velocity in current direction
                const push = gd.angle >= 0 ? 0.04 : -0.04;
                gd.velocity += push;
                gd.lastPress = 10;
                // Score when at high angle
                if (Math.abs(gd.angle) > 0.5) {
                    gd.score++;
                }
            } else if (playgroundState.currentGame === 'carousel') {
                if (gd.done) {
                    playgroundState.currentGame = null;
                    playgroundState.gameData = {};
                    return;
                }
                // Try to catch nearest star
                const playerAngle = Math.PI / 2; // player at bottom
                let caught = false;
                gd.stars.forEach(star => {
                    if (!star.active || caught) return;
                    const sa = (star.angle + gd.angle) % (Math.PI * 2);
                    // Normalize angle difference
                    let diff = sa - playerAngle;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    if (Math.abs(diff) < 0.4) {
                        star.active = false;
                        gd.score++;
                        gd.catchAnim = 30;
                        caught = true;
                        if (gd.score >= gd.targetScore) {
                            gd.done = true;
                            gd.success = true;
                            addCoins(1);
                        }
                    }
                });
            } else if (playgroundState.currentGame === 'slide') {
                if (gd.done) {
                    playgroundState.currentGame = null;
                    playgroundState.gameData = {};
                    return;
                }
                if (gd.phase === 'climb') {
                    gd.phase = 'slide';
                    gd.slidePos = 0;
                    gd.slideSpeed = 0.003;
                    gd.balance = 0;
                }
            } else if (playgroundState.currentGame === 'balance') {
                if (gd.done) {
                    playgroundState.currentGame = null;
                    playgroundState.gameData = {};
                    return;
                }
            } else if (playgroundState.currentGame === 'sandbox') {
                if (gd.done) {
                    playgroundState.currentGame = null;
                    playgroundState.gameData = {};
                    return;
                }
            } else if (playgroundState.currentGame === 'jumprope') {
                if (gd.done) {
                    playgroundState.currentGame = null;
                    playgroundState.gameData = {};
                    return;
                }
                // Jump!
                if (!gd.jumping) {
                    gd.jumping = true;
                    gd.jumpVel = 12;
                }
            }
        }

        function handlePlaygroundArrow(key) {
            if (playgroundState.currentGame !== 'sandbox') return; // sandbox uses discrete arrow presses; balance/slide use continuous keys
            const gd = playgroundState.gameData;
            if (gd.done) return;
            if (gd.currentLayer >= gd.layers.length) return;

            const layer = gd.layers[gd.currentLayer];
            if (key === layer[gd.currentStep]) {
                gd.currentStep++;
                if (gd.currentStep >= layer.length) {
                    gd.currentLayer++;
                    gd.currentStep = 0;
                    if (gd.currentLayer >= gd.layers.length) {
                        gd.done = true;
                        gd.success = true;
                        addCoins(1);
                    }
                }
            } else {
                gd.mistakes++;
                if (gd.mistakes >= gd.maxMistakes) {
                    gd.done = true;
                    gd.success = false;
                }
            }
        }

        function drawInterior() {
            interiorAnimationFrame++;
            const floorY = canvas.height - 180;

            // ===== WALLS =====
            // Warm cream wall with subtle texture
            const wallGrad = ctx.createLinearGradient(0, 0, 0, floorY);
            wallGrad.addColorStop(0, '#FFF5E6');
            wallGrad.addColorStop(1, '#FFECD2');
            ctx.fillStyle = wallGrad;
            ctx.fillRect(0, 0, canvas.width, floorY);

            // Subtle wallpaper stripes
            ctx.globalAlpha = 0.06;
            ctx.fillStyle = '#D4A574';
            for (let x = 0; x < canvas.width; x += 40) {
                ctx.fillRect(x, 0, 18, floorY);
            }
            ctx.globalAlpha = 1;

            // Baseboard / skirting board
            ctx.fillStyle = '#F5F5F5';
            ctx.fillRect(0, floorY - 15, canvas.width, 15);
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, floorY - 15, canvas.width, 15);

            // ===== FLOOR =====
            // Warm wooden floor
            const floorGrad = ctx.createLinearGradient(0, floorY, 0, canvas.height);
            floorGrad.addColorStop(0, '#C4935A');
            floorGrad.addColorStop(0.5, '#B8864E');
            floorGrad.addColorStop(1, '#A67842');
            ctx.fillStyle = floorGrad;
            ctx.fillRect(0, floorY, canvas.width, canvas.height - floorY);

            // Floor plank lines
            ctx.strokeStyle = 'rgba(101, 67, 33, 0.3)';
            ctx.lineWidth = 1;
            for (let y = floorY; y < canvas.height; y += 25) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            // Vertical plank separators
            for (let x = 0; x < canvas.width; x += 80) {
                const offset = ((x / 80) % 2) * 12;
                for (let y = floorY + offset; y < canvas.height; y += 50) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, y + 25);
                    ctx.stroke();
                }
            }

            // Wood grain details (scrolling with camera)
            ctx.strokeStyle = 'rgba(101, 67, 33, 0.08)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 40; i++) {
                const gx = ((i * 73 + 20 - interiorOffset * 0.5) % (canvas.width + 100)) - 50;
                const gy = floorY + (i * 31 + 5) % (canvas.height - floorY);
                ctx.beginPath();
                ctx.ellipse(gx, gy, 15 + (i % 3) * 5, 2, 0, 0, Math.PI * 2);
                ctx.stroke();
            }

            // ===== COZY RUG (center) =====
            const rugCX = canvas.width / 2;
            const rugCY = floorY + (canvas.height - floorY) / 2;
            // Oval rug with fringe
            ctx.save();
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath();
            ctx.ellipse(rugCX + 3, rugCY + 3, 160, 80, 0, 0, Math.PI * 2);
            ctx.fill();
            // Main rug
            const rugGrad = ctx.createRadialGradient(rugCX, rugCY, 0, rugCX, rugCY, 160);
            rugGrad.addColorStop(0, '#FF85A2');
            rugGrad.addColorStop(0.6, '#FF6B8A');
            rugGrad.addColorStop(1, '#E8527A');
            ctx.fillStyle = rugGrad;
            ctx.beginPath();
            ctx.ellipse(rugCX, rugCY, 155, 75, 0, 0, Math.PI * 2);
            ctx.fill();
            // Inner pattern
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(rugCX, rugCY, 120, 55, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(rugCX, rugCY, 80, 35, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Fringe around edges
            ctx.strokeStyle = '#E8527A';
            ctx.lineWidth = 1;
            for (let a = 0; a < Math.PI * 2; a += 0.12) {
                const fx = rugCX + Math.cos(a) * 155;
                const fy = rugCY + Math.sin(a) * 75;
                const fdx = Math.cos(a) * 8;
                const fdy = Math.sin(a) * 4;
                ctx.beginPath();
                ctx.moveTo(fx, fy);
                ctx.lineTo(fx + fdx, fy + fdy);
                ctx.stroke();
            }
            ctx.restore();

            // ===== TV ON STAND (left wall) =====
            const tvX = 80;
            const tvY = floorY - 250;
            const tvW = 220;
            const tvH = 140;

            // TV stand / cabinet
            ctx.fillStyle = '#5C3D2E';
            ctx.fillRect(tvX - 10, floorY - 80, tvW + 20, 80);
            // Drawers on stand
            ctx.strokeStyle = '#4A2F22';
            ctx.lineWidth = 1;
            ctx.strokeRect(tvX - 10, floorY - 80, tvW + 20, 80);
            ctx.beginPath();
            ctx.moveTo(tvX + tvW / 2, floorY - 80);
            ctx.lineTo(tvX + tvW / 2, floorY);
            ctx.stroke();
            // Drawer knobs
            ctx.fillStyle = '#C0A080';
            ctx.beginPath();
            ctx.arc(tvX + tvW / 4, floorY - 40, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(tvX + tvW * 3 / 4, floorY - 40, 4, 0, Math.PI * 2);
            ctx.fill();

            // TV body (dark frame)
            ctx.fillStyle = '#1A1A2E';
            ctx.fillRect(tvX - 5, tvY - 5, tvW + 10, tvH + 10);
            // Rounded corners effect
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.strokeRect(tvX - 5, tvY - 5, tvW + 10, tvH + 10);

            // TV screen with channels
            ctx.save();
            ctx.beginPath();
            ctx.rect(tvX, tvY, tvW, tvH);
            ctx.clip();

            if (tvChannel === 0) {
                // ===== CHANNEL 1: BAJKA (cartoon) =====
                const skyGrad = ctx.createLinearGradient(tvX, tvY, tvX, tvY + tvH);
                skyGrad.addColorStop(0, '#87CEEB');
                skyGrad.addColorStop(0.7, '#B0E0FF');
                skyGrad.addColorStop(1, '#90EE90');
                ctx.fillStyle = skyGrad;
                ctx.fillRect(tvX, tvY, tvW, tvH);

                // Animated sun
                const sunX = tvX + 40;
                const sunY = tvY + 30;
                const sunPulse = 18 + Math.sin(interiorAnimationFrame * 0.05) * 3;
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                for (let r = 0; r < 8; r++) {
                    const angle = (r / 8) * Math.PI * 2 + interiorAnimationFrame * 0.02;
                    ctx.beginPath();
                    ctx.moveTo(sunX + Math.cos(angle) * (sunPulse + 3), sunY + Math.sin(angle) * (sunPulse + 3));
                    ctx.lineTo(sunX + Math.cos(angle) * (sunPulse + 10), sunY + Math.sin(angle) * (sunPulse + 10));
                    ctx.stroke();
                }
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(sunX, sunY, sunPulse, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FF8C00';
                ctx.beginPath();
                ctx.arc(sunX - 5, sunY - 3, 2, 0, Math.PI * 2);
                ctx.arc(sunX + 5, sunY - 3, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(sunX, sunY + 3, 5, 0, Math.PI);
                ctx.stroke();

                // Clouds
                const cloudOff = (interiorAnimationFrame * 0.3) % (tvW + 60);
                ctx.fillStyle = '#FFF';
                [cloudOff, cloudOff + 100, cloudOff + 200].forEach(cx => {
                    const wrappedX = tvX + (cx % (tvW + 60)) - 30;
                    ctx.beginPath();
                    ctx.arc(wrappedX, tvY + 25, 12, 0, Math.PI * 2);
                    ctx.arc(wrappedX + 12, tvY + 20, 14, 0, Math.PI * 2);
                    ctx.arc(wrappedX + 24, tvY + 25, 11, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Green hills
                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.moveTo(tvX, tvY + tvH);
                ctx.quadraticCurveTo(tvX + tvW * 0.25, tvY + tvH - 40, tvX + tvW * 0.5, tvY + tvH - 10);
                ctx.quadraticCurveTo(tvX + tvW * 0.75, tvY + tvH - 50, tvX + tvW, tvY + tvH - 15);
                ctx.lineTo(tvX + tvW, tvY + tvH);
                ctx.closePath();
                ctx.fill();

                // Cartoon cat walking
                const catCartoonX = tvX + ((interiorAnimationFrame * 0.8) % (tvW + 40)) - 20;
                const catBob = Math.sin(interiorAnimationFrame * 0.15) * 3;
                ctx.fillStyle = '#FF69B4';
                ctx.beginPath();
                ctx.ellipse(catCartoonX, tvY + tvH - 35 + catBob, 12, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(catCartoonX + 8, tvY + tvH - 45 + catBob, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(catCartoonX + 3, tvY + tvH - 53 + catBob);
                ctx.lineTo(catCartoonX + 6, tvY + tvH - 60 + catBob);
                ctx.lineTo(catCartoonX + 9, tvY + tvH - 53 + catBob);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(catCartoonX + 9, tvY + tvH - 53 + catBob);
                ctx.lineTo(catCartoonX + 12, tvY + tvH - 60 + catBob);
                ctx.lineTo(catCartoonX + 15, tvY + tvH - 53 + catBob);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(catCartoonX + 6, tvY + tvH - 46 + catBob, 1.5, 0, Math.PI * 2);
                ctx.arc(catCartoonX + 11, tvY + tvH - 46 + catBob, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#FF69B4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(catCartoonX - 10, tvY + tvH - 35 + catBob);
                ctx.quadraticCurveTo(catCartoonX - 18, tvY + tvH - 55 + catBob + Math.sin(interiorAnimationFrame * 0.1) * 5, catCartoonX - 14, tvY + tvH - 50 + catBob);
                ctx.stroke();
                const legAnim = Math.sin(interiorAnimationFrame * 0.2);
                ctx.beginPath();
                ctx.moveTo(catCartoonX - 5, tvY + tvH - 27 + catBob);
                ctx.lineTo(catCartoonX - 5 + legAnim * 3, tvY + tvH - 20 + catBob);
                ctx.moveTo(catCartoonX + 5, tvY + tvH - 27 + catBob);
                ctx.lineTo(catCartoonX + 5 - legAnim * 3, tvY + tvH - 20 + catBob);
                ctx.stroke();

                // Flowers
                ['#FF4444', '#FFFF00', '#FF69B4', '#9370DB'].forEach((col, i) => {
                    const fx = tvX + 30 + i * 50;
                    ctx.fillStyle = col;
                    ctx.beginPath();
                    ctx.arc(fx, tvY + tvH - 18, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#228B22';
                    ctx.fillRect(fx - 1, tvY + tvH - 15, 2, 8);
                });

                // Channel label
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW - 55, tvY + 5, 50, 18, 4);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('BAJKA', tvX + tvW - 30, tvY + 17);

            } else if (tvChannel === 1) {
                // ===== CHANNEL 2: WIADOMO≈öCI (news) =====
                // Studio background
                const newsGrad = ctx.createLinearGradient(tvX, tvY, tvX, tvY + tvH);
                newsGrad.addColorStop(0, '#1a237e');
                newsGrad.addColorStop(1, '#283593');
                ctx.fillStyle = newsGrad;
                ctx.fillRect(tvX, tvY, tvW, tvH);

                // World map silhouette in background
                ctx.fillStyle = 'rgba(255,255,255,0.08)';
                ctx.beginPath();
                ctx.arc(tvX + tvW / 2, tvY + 50, 40, 0, Math.PI * 2);
                ctx.fill();
                // Continents (simplified blobs)
                ctx.fillStyle = 'rgba(100,180,255,0.15)';
                ctx.beginPath();
                ctx.ellipse(tvX + tvW / 2 - 15, tvY + 42, 12, 18, -0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(tvX + tvW / 2 + 15, tvY + 40, 10, 15, 0.3, 0, Math.PI * 2);
                ctx.fill();

                // News desk
                ctx.fillStyle = '#4A148C';
                ctx.fillRect(tvX, tvY + tvH - 40, tvW, 40);
                ctx.fillStyle = '#6A1B9A';
                ctx.fillRect(tvX, tvY + tvH - 40, tvW, 5);

                // Presenter (simple animal - bunny)
                const presX = tvX + tvW / 2;
                const presY = tvY + tvH - 55;
                // Body (suit)
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.ellipse(presX, presY + 15, 14, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                // Tie
                ctx.fillStyle = '#E53935';
                ctx.beginPath();
                ctx.moveTo(presX, presY + 5);
                ctx.lineTo(presX - 3, presY + 15);
                ctx.lineTo(presX + 3, presY + 15);
                ctx.closePath();
                ctx.fill();
                // Head
                ctx.fillStyle = '#F5DEB3';
                ctx.beginPath();
                ctx.arc(presX, presY, 10, 0, Math.PI * 2);
                ctx.fill();
                // Ears (bunny)
                ctx.fillStyle = '#F5DEB3';
                ctx.beginPath();
                ctx.ellipse(presX - 5, presY - 18, 3, 10, -0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(presX + 5, presY - 18, 3, 10, 0.2, 0, Math.PI * 2);
                ctx.fill();
                // Inner ears
                ctx.fillStyle = '#FFB6C1';
                ctx.beginPath();
                ctx.ellipse(presX - 5, presY - 18, 1.5, 6, -0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(presX + 5, presY - 18, 1.5, 6, 0.2, 0, Math.PI * 2);
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(presX - 4, presY - 2, 1.5, 0, Math.PI * 2);
                ctx.arc(presX + 4, presY - 2, 1.5, 0, Math.PI * 2);
                ctx.fill();
                // Mouth (talking animation)
                const mouthOpen = Math.sin(interiorAnimationFrame * 0.3) > 0 ? 2 : 0.5;
                ctx.fillStyle = '#C62828';
                ctx.beginPath();
                ctx.ellipse(presX, presY + 4, 2.5, mouthOpen, 0, 0, Math.PI * 2);
                ctx.fill();

                // Papers on desk
                ctx.fillStyle = '#FFF';
                ctx.save();
                ctx.translate(presX - 20, tvY + tvH - 35);
                ctx.rotate(-0.1);
                ctx.fillRect(0, 0, 15, 10);
                ctx.restore();
                ctx.save();
                ctx.translate(presX + 8, tvY + tvH - 34);
                ctx.rotate(0.05);
                ctx.fillRect(0, 0, 15, 10);
                ctx.restore();

                // Breaking news ticker
                ctx.fillStyle = '#C62828';
                ctx.fillRect(tvX, tvY + tvH - 18, tvW, 18);
                ctx.fillStyle = '#FFD600';
                ctx.fillRect(tvX, tvY + tvH - 18, 65, 18);
                ctx.fillStyle = '#000';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('PILNE', tvX + 32, tvY + tvH - 5);

                // Scrolling news text
                const newsTexts = 'Kicioro≈ºek znalaz≈Ç nowych przyjaci√≥≈Ç! *** Pogoda: s≈Çonecznie z tƒôczami *** Cukierki znalezione na polanie *** Hycele pokonane dzielnie! *** ';
                const newsScroll = (interiorAnimationFrame * 0.8) % (newsTexts.length * 7);
                ctx.fillStyle = '#FFF';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(newsTexts + newsTexts, tvX + 70 - newsScroll, tvY + tvH - 5);

                // Channel label
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW - 75, tvY + 5, 70, 18, 4);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('WIADOMO\u015ACI', tvX + tvW - 40, tvY + 17);

            } else if (tvChannel === 2) {
                // ===== CHANNEL 3: PI≈ÅKA NO≈ªNA (football) =====
                // Green pitch
                ctx.fillStyle = '#2E7D32';
                ctx.fillRect(tvX, tvY, tvW, tvH);

                // Pitch lines
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 1;
                // Center line
                ctx.beginPath();
                ctx.moveTo(tvX + tvW / 2, tvY);
                ctx.lineTo(tvX + tvW / 2, tvY + tvH);
                ctx.stroke();
                // Center circle
                ctx.beginPath();
                ctx.arc(tvX + tvW / 2, tvY + tvH / 2, 25, 0, Math.PI * 2);
                ctx.stroke();
                // Center dot
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.beginPath();
                ctx.arc(tvX + tvW / 2, tvY + tvH / 2, 2, 0, Math.PI * 2);
                ctx.fill();
                // Pitch stripes (mowing pattern)
                ctx.fillStyle = 'rgba(255,255,255,0.03)';
                for (let s = 0; s < tvW; s += 20) {
                    if ((s / 20) % 2 === 0) ctx.fillRect(tvX + s, tvY, 20, tvH);
                }
                // Left goal area
                ctx.strokeRect(tvX, tvY + tvH / 2 - 30, 25, 60);
                ctx.strokeRect(tvX, tvY + tvH / 2 - 15, 10, 30);
                // Right goal area
                ctx.strokeRect(tvX + tvW - 25, tvY + tvH / 2 - 30, 25, 60);
                ctx.strokeRect(tvX + tvW - 10, tvY + tvH / 2 - 15, 10, 30);

                // Ball (bouncing around)
                const ballTime = interiorAnimationFrame * 0.03;
                const ballX = tvX + tvW / 2 + Math.sin(ballTime * 1.7) * 70;
                const ballY = tvY + tvH / 2 + Math.cos(ballTime * 2.3) * 40;
                // Ball shadow
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.beginPath();
                ctx.ellipse(ballX, ballY + 5, 5, 2, 0, 0, Math.PI * 2);
                ctx.fill();
                // Ball
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(ballX, ballY, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.arc(ballX, ballY, 5, 0, Math.PI * 2);
                ctx.stroke();
                // Pentagon pattern
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(ballX, ballY, 2, 0, Math.PI * 2);
                ctx.fill();

                // Players - Team A (red)
                const teamAPositions = [
                    [tvX + 30, tvY + tvH / 2],
                    [tvX + 70, tvY + tvH / 2 - 30],
                    [tvX + 70, tvY + tvH / 2 + 30],
                    [tvX + tvW / 2 - 20, tvY + tvH / 2 + Math.sin(interiorAnimationFrame * 0.05) * 15],
                ];
                teamAPositions.forEach(([px, py]) => {
                    // Shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.beginPath();
                    ctx.ellipse(px, py + 7, 4, 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Body
                    ctx.fillStyle = '#E53935';
                    ctx.beginPath();
                    ctx.ellipse(px, py, 4, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Head
                    ctx.fillStyle = '#FFCC80';
                    ctx.beginPath();
                    ctx.arc(px, py - 7, 3, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Players - Team B (blue)
                const teamBPositions = [
                    [tvX + tvW - 30, tvY + tvH / 2],
                    [tvX + tvW - 70, tvY + tvH / 2 - 25],
                    [tvX + tvW - 70, tvY + tvH / 2 + 25],
                    [tvX + tvW / 2 + 20, tvY + tvH / 2 + Math.cos(interiorAnimationFrame * 0.06) * 15],
                ];
                teamBPositions.forEach(([px, py]) => {
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.beginPath();
                    ctx.ellipse(px, py + 7, 4, 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#1565C0';
                    ctx.beginPath();
                    ctx.ellipse(px, py, 4, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FFCC80';
                    ctx.beginPath();
                    ctx.arc(px, py - 7, 3, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Score board
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW / 2 - 40, tvY + 5, 80, 20, 4);
                ctx.fill();
                ctx.fillStyle = '#E53935';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('KOT', tvX + tvW / 2 - 22, tvY + 19);
                ctx.fillStyle = '#FFF';
                ctx.fillText('2:1', tvX + tvW / 2, tvY + 19);
                ctx.fillStyle = '#1565C0';
                ctx.fillText('HYC', tvX + tvW / 2 + 22, tvY + 19);

                // Time
                const matchTime = Math.floor((interiorAnimationFrame * 0.1) % 90) + 1;
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW / 2 - 18, tvY + 26, 36, 14, 3);
                ctx.fill();
                ctx.fillStyle = '#0F0';
                ctx.font = '10px Arial';
                ctx.fillText(matchTime + "'", tvX + tvW / 2, tvY + 37);

                // Channel label
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW - 60, tvY + tvH - 22, 55, 18, 4);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('SPORT', tvX + tvW - 33, tvY + tvH - 10);

            } else if (tvChannel === 3) {
                // ===== CHANNEL 4: POKAZ MODY (fashion show) =====
                // Runway background
                const runwayGrad = ctx.createLinearGradient(tvX, tvY, tvX, tvY + tvH);
                runwayGrad.addColorStop(0, '#1a1a2e');
                runwayGrad.addColorStop(1, '#16213e');
                ctx.fillStyle = runwayGrad;
                ctx.fillRect(tvX, tvY, tvW, tvH);

                // Runway (perspective)
                ctx.fillStyle = '#F5F5F5';
                ctx.beginPath();
                ctx.moveTo(tvX + tvW / 2 - 15, tvY);
                ctx.lineTo(tvX + tvW / 2 + 15, tvY);
                ctx.lineTo(tvX + tvW / 2 + 60, tvY + tvH);
                ctx.lineTo(tvX + tvW / 2 - 60, tvY + tvH);
                ctx.closePath();
                ctx.fill();
                // Runway center line
                ctx.strokeStyle = 'rgba(200,200,200,0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(tvX + tvW / 2, tvY);
                ctx.lineTo(tvX + tvW / 2, tvY + tvH);
                ctx.stroke();
                ctx.setLineDash([]);

                // Spotlights
                for (let i = 0; i < 3; i++) {
                    const slX = tvX + tvW / 2 - 30 + i * 30;
                    const spotGrad = ctx.createRadialGradient(slX, tvY, 0, slX, tvY + 40, 50);
                    spotGrad.addColorStop(0, `rgba(255, 220, 255, ${0.15 + Math.sin(interiorAnimationFrame * 0.08 + i) * 0.05})`);
                    spotGrad.addColorStop(1, 'rgba(255, 220, 255, 0)');
                    ctx.fillStyle = spotGrad;
                    ctx.beginPath();
                    ctx.moveTo(slX - 5, tvY);
                    ctx.lineTo(slX - 40, tvY + tvH);
                    ctx.lineTo(slX + 40, tvY + tvH);
                    ctx.lineTo(slX + 5, tvY);
                    ctx.closePath();
                    ctx.fill();
                }

                // Model walking down runway
                const modelProgress = (interiorAnimationFrame * 0.5) % 180;
                const modelPhase = modelProgress < 90 ? modelProgress / 90 : (180 - modelProgress) / 90; // 0..1..0
                const modelY = tvY + 10 + modelPhase * (tvH - 30);
                const modelScale = 0.5 + modelPhase * 0.5;
                const modelX = tvX + tvW / 2;

                ctx.save();
                ctx.translate(modelX, modelY);
                ctx.scale(modelScale, modelScale);

                // Dress (changes color based on cycle)
                const dressColors = ['#FF1493', '#8A2BE2', '#FF6347', '#00CED1', '#FFD700'];
                const dressIdx = Math.floor((interiorAnimationFrame * 0.01) % dressColors.length);
                const dressColor = dressColors[dressIdx];

                // Body
                ctx.fillStyle = '#FFCC80';
                ctx.beginPath();
                ctx.arc(0, -15, 6, 0, Math.PI * 2);
                ctx.fill();
                // Hair
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.arc(0, -18, 7, Math.PI, Math.PI * 2);
                ctx.fill();
                ctx.fillRect(-7, -18, 14, 5);
                // Long hair flowing
                ctx.beginPath();
                ctx.moveTo(-7, -16);
                ctx.quadraticCurveTo(-10, -5, -8 + Math.sin(interiorAnimationFrame * 0.1) * 2, 5);
                ctx.lineTo(-5, 5);
                ctx.lineTo(-5, -16);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(7, -16);
                ctx.quadraticCurveTo(10, -5, 8 + Math.sin(interiorAnimationFrame * 0.1 + 1) * 2, 5);
                ctx.lineTo(5, 5);
                ctx.lineTo(5, -16);
                ctx.closePath();
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-2, -16, 1, 0, Math.PI * 2);
                ctx.arc(2, -16, 1, 0, Math.PI * 2);
                ctx.fill();
                // Smile
                ctx.strokeStyle = '#C62828';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(0, -13, 2, 0, Math.PI);
                ctx.stroke();
                // Dress
                ctx.fillStyle = dressColor;
                ctx.beginPath();
                ctx.moveTo(-5, -8);
                ctx.lineTo(5, -8);
                ctx.lineTo(12, 20);
                ctx.quadraticCurveTo(0, 18 + Math.sin(interiorAnimationFrame * 0.15) * 2, -12, 20);
                ctx.closePath();
                ctx.fill();
                // Belt/waist
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(-5, -3, 10, 2);
                // Legs
                const legWalk = Math.sin(interiorAnimationFrame * 0.2) * 3;
                ctx.strokeStyle = '#FFCC80';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-3, 20);
                ctx.lineTo(-3 + legWalk, 28);
                ctx.moveTo(3, 20);
                ctx.lineTo(3 - legWalk, 28);
                ctx.stroke();
                // High heels
                ctx.fillStyle = dressColor;
                ctx.fillRect(-5 + legWalk, 27, 4, 3);
                ctx.fillRect(1 - legWalk, 27, 4, 3);

                ctx.restore();

                // Audience silhouettes at sides
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                for (let i = 0; i < 8; i++) {
                    const side = i < 4 ? -1 : 1;
                    const idx = i % 4;
                    const ax = tvX + tvW / 2 + side * (70 + idx * 10);
                    const ay = tvY + tvH - 20 - idx * 8;
                    ctx.beginPath();
                    ctx.arc(ax, ay - 5, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(ax - 3, ay - 1, 6, 8);
                }

                // Camera flashes
                if (Math.random() < 0.03) {
                    const flashX = tvX + 20 + Math.random() * (tvW - 40);
                    const flashY = tvY + tvH - 30 - Math.random() * 30;
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.beginPath();
                    ctx.arc(flashX, flashY, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Channel label
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW - 60, tvY + 5, 55, 18, 4);
                ctx.fill();
                ctx.fillStyle = '#FF69B4';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('MODA', tvX + tvW - 33, tvY + 17);

            } else if (tvChannel === 4) {
                // ===== CHANNEL 5: WY≈öCIGI SAMOCHOD√ìW (car racing) =====
                // Asphalt track background
                ctx.fillStyle = '#555';
                ctx.fillRect(tvX, tvY, tvW, tvH);

                // Road with perspective
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(tvX + tvW / 2 - 10, tvY);
                ctx.lineTo(tvX + tvW / 2 + 10, tvY);
                ctx.lineTo(tvX + tvW + 20, tvY + tvH);
                ctx.lineTo(tvX - 20, tvY + tvH);
                ctx.closePath();
                ctx.fill();

                // Road lines (dashed center, perspective)
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 12]);
                const lineScroll = (interiorAnimationFrame * 3) % 20;
                ctx.lineDashOffset = -lineScroll;
                ctx.beginPath();
                ctx.moveTo(tvX + tvW / 2, tvY);
                ctx.lineTo(tvX + tvW / 2, tvY + tvH);
                ctx.stroke();
                ctx.setLineDash([]);

                // Red-white curbs on sides
                for (let cy = tvY; cy < tvY + tvH; cy += 8) {
                    const progress = (cy - tvY) / tvH;
                    const leftEdge = tvX + tvW / 2 - 10 - progress * (tvW / 2 + 10);
                    const rightEdge = tvX + tvW / 2 + 10 + progress * (tvW / 2 + 10);
                    ctx.fillStyle = ((cy / 8) % 2 === 0) ? '#E53935' : '#FFF';
                    ctx.fillRect(leftEdge - 4, cy, 4, 8);
                    ctx.fillRect(rightEdge, cy, 4, 8);
                }

                // Grass on the side
                ctx.fillStyle = '#2E7D32';
                // Left grass
                ctx.beginPath();
                ctx.moveTo(tvX, tvY);
                ctx.lineTo(tvX + tvW / 2 - 10, tvY);
                ctx.lineTo(tvX - 24, tvY + tvH);
                ctx.lineTo(tvX, tvY + tvH);
                ctx.closePath();
                ctx.fill();
                // Right grass
                ctx.beginPath();
                ctx.moveTo(tvX + tvW, tvY);
                ctx.lineTo(tvX + tvW / 2 + 10, tvY);
                ctx.lineTo(tvX + tvW + 24, tvY + tvH);
                ctx.lineTo(tvX + tvW, tvY + tvH);
                ctx.closePath();
                ctx.fill();

                // Cars racing
                const carColors = ['#E53935', '#1565C0', '#FFD600', '#4CAF50', '#FF6F00'];
                for (let c = 0; c < 4; c++) {
                    const carPhase = ((interiorAnimationFrame * (1.5 + c * 0.3)) + c * 60) % (tvH + 40);
                    const carProgress = carPhase / (tvH + 40);
                    const carY = tvY - 10 + carPhase;
                    const carScale = 0.3 + carProgress * 0.7;
                    const laneOffset = (c % 2 === 0 ? -1 : 1) * (15 + carProgress * 30) + Math.sin(interiorAnimationFrame * 0.05 + c) * 5;
                    const carX = tvX + tvW / 2 + laneOffset;

                    if (carY > tvY - 10 && carY < tvY + tvH + 10) {
                        ctx.save();
                        ctx.translate(carX, carY);
                        ctx.scale(carScale, carScale);

                        // Car shadow
                        ctx.fillStyle = 'rgba(0,0,0,0.3)';
                        ctx.beginPath();
                        ctx.ellipse(2, 5, 14, 4, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Car body
                        ctx.fillStyle = carColors[c];
                        ctx.beginPath();
                        ctx.roundRect(-12, -8, 24, 16, 4);
                        ctx.fill();

                        // Windshield
                        ctx.fillStyle = 'rgba(100,200,255,0.6)';
                        ctx.beginPath();
                        ctx.roundRect(-6, -6, 12, 5, 2);
                        ctx.fill();

                        // Wheels
                        ctx.fillStyle = '#111';
                        ctx.fillRect(-14, -5, 4, 5);
                        ctx.fillRect(10, -5, 4, 5);
                        ctx.fillRect(-14, 2, 4, 5);
                        ctx.fillRect(10, 2, 4, 5);

                        // Number on hood
                        ctx.fillStyle = '#FFF';
                        ctx.font = 'bold 7px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(String(c + 1), 0, 5);

                        // Speed lines behind car
                        ctx.strokeStyle = `rgba(255,255,255,${0.3 * carScale})`;
                        ctx.lineWidth = 1;
                        for (let sl = 0; sl < 3; sl++) {
                            ctx.beginPath();
                            ctx.moveTo(-8 + sl * 8, -10);
                            ctx.lineTo(-8 + sl * 8, -15 - Math.random() * 5);
                            ctx.stroke();
                        }

                        ctx.restore();
                    }
                }

                // Lap counter
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.beginPath();
                ctx.roundRect(tvX + 5, tvY + 5, 55, 20, 4);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'left';
                const lap = Math.floor((interiorAnimationFrame * 0.02) % 20) + 1;
                ctx.fillText('Okr. ' + lap + '/20', tvX + 10, tvY + 19);

                // Speed indicator
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW - 65, tvY + tvH - 25, 60, 20, 4);
                ctx.fill();
                const speed = 180 + Math.floor(Math.sin(interiorAnimationFrame * 0.04) * 40);
                ctx.fillStyle = speed > 200 ? '#FF4444' : '#FFF';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(speed + ' km/h', tvX + tvW - 35, tvY + tvH - 11);

                // Channel label
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW - 75, tvY + 5, 70, 18, 4);
                ctx.fill();
                ctx.fillStyle = '#FF6F00';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('WY\u015ACIGI', tvX + tvW - 40, tvY + 17);

            } else if (tvChannel === 5) {
                // ===== CHANNEL 6: KLAUN (clown show) =====
                // Circus tent background
                const tentGrad = ctx.createLinearGradient(tvX, tvY, tvX + tvW, tvY);
                for (let i = 0; i <= 8; i++) {
                    tentGrad.addColorStop(i / 8, i % 2 === 0 ? '#E53935' : '#FFF');
                }
                ctx.fillStyle = tentGrad;
                ctx.fillRect(tvX, tvY, tvW, tvH);

                // Stage floor
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(tvX, tvY + tvH * 0.65, tvW, tvH * 0.35);
                ctx.fillStyle = '#A0522D';
                for (let sx = tvX; sx < tvX + tvW; sx += 20) {
                    ctx.fillRect(sx, tvY + tvH * 0.65, 10, tvH * 0.35);
                }

                // Spotlight beams
                ctx.fillStyle = 'rgba(255, 255, 100, 0.15)';
                ctx.beginPath();
                ctx.moveTo(tvX + 30, tvY);
                ctx.lineTo(tvX + tvW / 2 - 30, tvY + tvH * 0.65);
                ctx.lineTo(tvX + tvW / 2 + 30, tvY + tvH * 0.65);
                ctx.lineTo(tvX + tvW - 30, tvY);
                ctx.closePath();
                ctx.fill();

                // Clown body
                const clownX = tvX + tvW / 2;
                const clownY = tvY + tvH * 0.45;
                const clownBob = Math.sin(interiorAnimationFrame * 0.08) * 4;

                // Big shoes
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.ellipse(clownX - 15, clownY + 35 + clownBob, 18, 6, -0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(clownX + 15, clownY + 35 + clownBob, 18, 6, 0.2, 0, Math.PI * 2);
                ctx.fill();

                // Legs (baggy pants)
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(clownX - 12, clownY + 15 + clownBob, 10, 20);
                ctx.fillRect(clownX + 2, clownY + 15 + clownBob, 10, 20);

                // Body (polka dot shirt)
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.ellipse(clownX, clownY + clownBob, 18, 20, 0, 0, Math.PI * 2);
                ctx.fill();
                // Polka dots
                ctx.fillStyle = '#FFF';
                [[-6,-5],[5,-8],[0,5],[-8,3],[7,2]].forEach(([dx,dy]) => {
                    ctx.beginPath();
                    ctx.arc(clownX + dx, clownY + dy + clownBob, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Big bow tie
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.moveTo(clownX, clownY - 15 + clownBob);
                ctx.lineTo(clownX - 12, clownY - 22 + clownBob);
                ctx.lineTo(clownX - 12, clownY - 8 + clownBob);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(clownX, clownY - 15 + clownBob);
                ctx.lineTo(clownX + 12, clownY - 22 + clownBob);
                ctx.lineTo(clownX + 12, clownY - 8 + clownBob);
                ctx.closePath();
                ctx.fill();

                // Arms (juggling)
                const armAngle1 = interiorAnimationFrame * 0.1;
                const armAngle2 = interiorAnimationFrame * 0.1 + Math.PI;
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(clownX - 15, clownY - 5 + clownBob);
                ctx.lineTo(clownX - 28 + Math.cos(armAngle1) * 8, clownY - 20 + Math.sin(armAngle1) * 5 + clownBob);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(clownX + 15, clownY - 5 + clownBob);
                ctx.lineTo(clownX + 28 + Math.cos(armAngle2) * 8, clownY - 20 + Math.sin(armAngle2) * 5 + clownBob);
                ctx.stroke();

                // Head
                ctx.fillStyle = '#FFDAB9';
                ctx.beginPath();
                ctx.arc(clownX, clownY - 25 + clownBob, 14, 0, Math.PI * 2);
                ctx.fill();

                // Red nose
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.arc(clownX, clownY - 23 + clownBob, 5, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(clownX - 6, clownY - 28 + clownBob, 2.5, 0, Math.PI * 2);
                ctx.arc(clownX + 6, clownY - 28 + clownBob, 2.5, 0, Math.PI * 2);
                ctx.fill();

                // Big smile
                ctx.strokeStyle = '#E53935';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(clownX, clownY - 22 + clownBob, 8, 0.1 * Math.PI, 0.9 * Math.PI);
                ctx.stroke();

                // Colorful hair/wig
                ctx.fillStyle = '#FF6F00';
                const hairPts = [[-14,-30],[-16,-36],[-10,-40],[-4,-42],[4,-42],[10,-40],[16,-36],[14,-30]];
                hairPts.forEach(([hx,hy]) => {
                    ctx.beginPath();
                    ctx.arc(clownX + hx, clownY + hy + clownBob + Math.sin(interiorAnimationFrame * 0.05 + hx) * 1.5, 5, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Juggling balls
                const ballColors = ['#FF0000', '#FFFF00', '#0000FF'];
                for (let b = 0; b < 3; b++) {
                    const bAngle = interiorAnimationFrame * 0.08 + b * (Math.PI * 2 / 3);
                    const jbx = clownX + Math.cos(bAngle) * 25;
                    const jby = clownY - 35 + Math.sin(bAngle) * 15 + clownBob;
                    ctx.fillStyle = ballColors[b];
                    ctx.beginPath();
                    ctx.arc(jbx, jby, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(255,255,255,0.4)';
                    ctx.beginPath();
                    ctx.arc(jbx - 1, jby - 1, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Channel label
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW - 65, tvY + 5, 60, 18, 4);
                ctx.fill();
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('KLAUN', tvX + tvW - 35, tvY + 17);

            } else if (tvChannel === 6) {
                // ===== CHANNEL 7: MUZYKA (singing show) =====
                // Dark stage background with lights
                ctx.fillStyle = '#1a1a3e';
                ctx.fillRect(tvX, tvY, tvW, tvH);

                // Disco lights
                const discoColors = ['#FF0000', '#00FF00', '#0000FF', '#FF00FF', '#FFFF00', '#00FFFF'];
                for (let d = 0; d < 5; d++) {
                    const dAngle = interiorAnimationFrame * 0.03 + d * 1.2;
                    const dx = tvX + tvW / 2 + Math.cos(dAngle) * (tvW * 0.4);
                    const dy = tvY + tvH * 0.3 + Math.sin(dAngle * 0.7) * (tvH * 0.2);
                    const grad = ctx.createRadialGradient(dx, dy, 0, dx, dy, 30);
                    grad.addColorStop(0, discoColors[d % discoColors.length].replace(')', ', 0.3)').replace('rgb', 'rgba'));
                    grad.addColorStop(0, `rgba(${parseInt(discoColors[d % discoColors.length].slice(1,3),16)}, ${parseInt(discoColors[d % discoColors.length].slice(3,5),16)}, ${parseInt(discoColors[d % discoColors.length].slice(5,7),16)}, 0.3)`);
                    grad.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = grad;
                    ctx.fillRect(tvX, tvY, tvW, tvH);
                }

                // Stage
                ctx.fillStyle = '#333';
                ctx.fillRect(tvX, tvY + tvH * 0.7, tvW, tvH * 0.3);
                ctx.fillStyle = '#444';
                ctx.fillRect(tvX, tvY + tvH * 0.7, tvW, 3);

                // Singer in center
                const singerX = tvX + tvW / 2;
                const singerY = tvY + tvH * 0.5;
                const singerBob = Math.sin(interiorAnimationFrame * 0.12) * 3;

                // Singer body (dress)
                const dressGrad = ctx.createLinearGradient(singerX, singerY - 10, singerX, singerY + 30);
                dressGrad.addColorStop(0, '#E91E63');
                dressGrad.addColorStop(1, '#AD1457');
                ctx.fillStyle = dressGrad;
                ctx.beginPath();
                ctx.moveTo(singerX - 12, singerY - 10 + singerBob);
                ctx.lineTo(singerX + 12, singerY - 10 + singerBob);
                ctx.lineTo(singerX + 18, singerY + 30 + singerBob);
                ctx.lineTo(singerX - 18, singerY + 30 + singerBob);
                ctx.closePath();
                ctx.fill();

                // Head
                ctx.fillStyle = '#FFDAB9';
                ctx.beginPath();
                ctx.arc(singerX, singerY - 20 + singerBob, 10, 0, Math.PI * 2);
                ctx.fill();

                // Hair
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(singerX, singerY - 23 + singerBob, 10, Math.PI, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(singerX - 10, singerY - 15 + singerBob, 4, 12, 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(singerX + 10, singerY - 15 + singerBob, 4, 12, -0.3, 0, Math.PI * 2);
                ctx.fill();

                // Microphone (held up)
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(singerX + 10, singerY - 8 + singerBob);
                ctx.lineTo(singerX + 16, singerY - 25 + singerBob);
                ctx.stroke();
                ctx.fillStyle = '#888';
                ctx.beginPath();
                ctx.arc(singerX + 16, singerY - 27 + singerBob, 4, 0, Math.PI * 2);
                ctx.fill();

                // Singing mouth (open, pulsing)
                const mouthSize = 3 + Math.abs(Math.sin(interiorAnimationFrame * 0.15)) * 2;
                ctx.fillStyle = '#C62828';
                ctx.beginPath();
                ctx.ellipse(singerX, singerY - 16 + singerBob, 3, mouthSize, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(singerX - 4, singerY - 22 + singerBob, 1.5, 0, Math.PI * 2);
                ctx.arc(singerX + 4, singerY - 22 + singerBob, 1.5, 0, Math.PI * 2);
                ctx.fill();

                // Music notes floating
                const noteSymbols = ['\u266A', '\u266B', '\u2669'];
                const noteColors = ['#FF69B4', '#FFD700', '#87CEEB', '#FF6B6B', '#90EE90'];
                for (let n = 0; n < 6; n++) {
                    const nPhase = (interiorAnimationFrame * 0.02 + n * 0.4) % 2;
                    const nAlpha = Math.max(0, 1 - nPhase / 2);
                    const nx = singerX - 30 + n * 12 + Math.sin(interiorAnimationFrame * 0.05 + n) * 10;
                    const ny = singerY - 30 - nPhase * 30;
                    ctx.fillStyle = noteColors[n % noteColors.length];
                    ctx.globalAlpha = nAlpha;
                    ctx.font = `bold ${10 + n % 3 * 2}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(noteSymbols[n % noteSymbols.length], nx, ny);
                }
                ctx.globalAlpha = 1;

                // Audience silhouettes at bottom
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                for (let a = 0; a < 8; a++) {
                    const ax = tvX + 10 + a * (tvW - 20) / 7;
                    const ay = tvY + tvH - 8;
                    const abob = Math.sin(interiorAnimationFrame * 0.1 + a * 0.8) * 2;
                    ctx.beginPath();
                    ctx.arc(ax, ay - 5 + abob, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(ax - 4, ay + abob, 8, 8);
                }
                // Hands up in audience
                for (let a = 0; a < 5; a++) {
                    const hx = tvX + 20 + a * (tvW - 40) / 4;
                    const hbob = Math.sin(interiorAnimationFrame * 0.15 + a) * 4;
                    ctx.strokeStyle = 'rgba(0,0,0,0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(hx, tvY + tvH - 10);
                    ctx.lineTo(hx + Math.sin(interiorAnimationFrame * 0.1 + a) * 3, tvY + tvH - 20 + hbob);
                    ctx.stroke();
                }

                // Channel label
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW - 70, tvY + 5, 65, 18, 4);
                ctx.fill();
                ctx.fillStyle = '#FF69B4';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('MUZYKA', tvX + tvW - 38, tvY + 17);
            }

            ctx.restore(); // end TV clip

            // TV power LED
            const ledColors = ['#00FF00', '#FF4444', '#4488FF', '#FF69B4', '#FF6F00', '#FFD700', '#FF69B4'];
            ctx.fillStyle = interiorAnimationFrame % 120 < 100 ? ledColors[tvChannel] : '#222';
            ctx.beginPath();
            ctx.arc(tvX + tvW / 2, tvY + tvH + 3, 2, 0, Math.PI * 2);
            ctx.fill();

            // TV screen glow (color depends on channel)
            const glowColors = ['rgba(135, 206, 235, 0.3)', 'rgba(26, 35, 126, 0.3)', 'rgba(46, 125, 50, 0.3)', 'rgba(255, 20, 147, 0.3)', 'rgba(255, 111, 0, 0.3)', 'rgba(255, 215, 0, 0.3)', 'rgba(255, 105, 180, 0.3)'];
            ctx.shadowColor = glowColors[tvChannel];
            ctx.shadowBlur = 15;
            ctx.strokeStyle = glowColors[tvChannel].replace('0.3', '0.2');
            ctx.lineWidth = 1;
            ctx.strokeRect(tvX - 1, tvY - 1, tvW + 2, tvH + 2);
            ctx.shadowBlur = 0;

            // ===== REMOTE CONTROL (on TV stand) =====
            const remoteX = tvX + tvW + 15;
            const remoteY = floorY - 65;
            // Remote body
            ctx.fillStyle = '#2C2C2C';
            ctx.beginPath();
            ctx.roundRect(remoteX, remoteY, 18, 68, 4);
            ctx.fill();
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(remoteX, remoteY, 18, 68, 4);
            ctx.stroke();
            // IR window
            ctx.fillStyle = '#4A0000';
            ctx.fillRect(remoteX + 5, remoteY + 2, 8, 3);
            // Power button (red)
            ctx.fillStyle = '#E53935';
            ctx.beginPath();
            ctx.arc(remoteX + 9, remoteY + 10, 3, 0, Math.PI * 2);
            ctx.fill();
            // Channel buttons (1-7)
            const btnColors = ['#4CAF50', '#2196F3', '#FF9800', '#FF69B4', '#FF6F00', '#FFD700', '#E91E63'];
            for (let i = 0; i < 7; i++) {
                ctx.fillStyle = tvChannel === i ? btnColors[i] : '#555';
                ctx.beginPath();
                ctx.roundRect(remoteX + 3, remoteY + 17 + i * 7, 12, 5, 2);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = '5px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(String(i + 1), remoteX + 9, remoteY + 21 + i * 7);
            }

            // ===== COUCH / KANAPA (right of TV) =====
            const couchX = 340;
            const couchY = floorY;
            const couchW = 120;
            const couchH = 55;

            // Couch base
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.roundRect(couchX, couchY - 8, couchW, 15, 3);
            ctx.fill();
            // Couch legs
            ctx.fillStyle = '#5C3D2E';
            ctx.fillRect(couchX + 8, couchY + 2, 6, 12);
            ctx.fillRect(couchX + couchW - 14, couchY + 2, 6, 12);
            // Seat cushion
            const couchGrad = ctx.createLinearGradient(couchX, couchY - couchH, couchX, couchY);
            couchGrad.addColorStop(0, '#C0392B');
            couchGrad.addColorStop(1, '#E74C3C');
            ctx.fillStyle = couchGrad;
            ctx.beginPath();
            ctx.roundRect(couchX + 3, couchY - 25, couchW - 6, 20, 6);
            ctx.fill();
            // Back cushion
            ctx.fillStyle = '#C0392B';
            ctx.beginPath();
            ctx.roundRect(couchX + 3, couchY - couchH, couchW - 6, 32, 8);
            ctx.fill();
            // Cushion divider line
            ctx.strokeStyle = '#A93226';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(couchX + couchW / 2, couchY - couchH + 5);
            ctx.lineTo(couchX + couchW / 2, couchY - 10);
            ctx.stroke();
            // Armrests
            ctx.fillStyle = '#A93226';
            ctx.beginPath();
            ctx.roundRect(couchX - 8, couchY - couchH + 10, 14, couchH - 15, 5);
            ctx.fill();
            ctx.beginPath();
            ctx.roundRect(couchX + couchW - 6, couchY - couchH + 10, 14, couchH - 15, 5);
            ctx.fill();
            // Pillow on couch
            ctx.fillStyle = '#F5B041';
            ctx.beginPath();
            ctx.ellipse(couchX + 30, couchY - 30, 15, 10, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#F7C948';
            ctx.beginPath();
            ctx.ellipse(couchX + 28, couchY - 32, 5, 4, -0.2, 0, Math.PI * 2);
            ctx.fill();

            // ===== FOOD BOWLS (right of couch) =====
            const bowlX = 510;
            const bowlY = floorY;

            // Food mat
            ctx.fillStyle = '#E8D5B7';
            ctx.beginPath();
            ctx.ellipse(bowlX + 30, bowlY + 10, 75, 18, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#C4A882';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.ellipse(bowlX + 30, bowlY + 10, 75, 18, 0, 0, Math.PI * 2);
            ctx.stroke();

            // Water bowl (left)
            // Bowl outer
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.ellipse(bowlX - 10, bowlY, 28, 12, 0, 0, Math.PI);
            ctx.fill();
            // Bowl rim
            ctx.fillStyle = '#5B7FDE';
            ctx.beginPath();
            ctx.ellipse(bowlX - 10, bowlY - 2, 30, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#3355B0';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.ellipse(bowlX - 10, bowlY - 2, 30, 10, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Water inside
            ctx.fillStyle = 'rgba(100, 180, 255, 0.6)';
            ctx.beginPath();
            ctx.ellipse(bowlX - 10, bowlY - 3, 24, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            // Water reflection
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.ellipse(bowlX - 15, bowlY - 5, 8, 3, -0.3, 0, Math.PI * 2);
            ctx.fill();
            // Paw print on bowl
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.arc(bowlX - 10, bowlY + 3, 3, 0, Math.PI * 2);
            ctx.fill();
            [[-4,-2],[-2,-5],[2,-5],[4,-2]].forEach(([dx,dy]) => {
                ctx.beginPath();
                ctx.arc(bowlX - 10 + dx, bowlY + 3 + dy, 1.5, 0, Math.PI * 2);
                ctx.fill();
            });

            // Food bowl (right)
            ctx.fillStyle = '#FF6B6B';
            ctx.beginPath();
            ctx.ellipse(bowlX + 60, bowlY, 28, 12, 0, 0, Math.PI);
            ctx.fill();
            ctx.fillStyle = '#FF8585';
            ctx.beginPath();
            ctx.ellipse(bowlX + 60, bowlY - 2, 30, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#CC4444';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.ellipse(bowlX + 60, bowlY - 2, 30, 10, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Kibble pieces
            ctx.fillStyle = '#8B6914';
            const kibblePositions = [
                [0, 0], [-8, -2], [6, -1], [-4, 2], [3, 3],
                [-10, 1], [8, 2], [-2, -4], [5, -3], [-6, 3]
            ];
            kibblePositions.forEach(([kx, ky]) => {
                ctx.beginPath();
                ctx.ellipse(bowlX + 60 + kx, bowlY - 5 + ky, 4, 3, kx * 0.1, 0, Math.PI * 2);
                ctx.fill();
            });
            // Kibble highlight
            ctx.fillStyle = '#A08030';
            kibblePositions.slice(0, 5).forEach(([kx, ky]) => {
                ctx.beginPath();
                ctx.ellipse(bowlX + 60 + kx - 1, bowlY - 6 + ky, 2, 1.5, kx * 0.1, 0, Math.PI * 2);
                ctx.fill();
            });
            // Heart on food bowl
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('‚ô•', bowlX + 60, bowlY + 6);

            // ===== CAMERA ON SHELF =====
            const cameraX = 620;
            const cameraShelfY = floorY - 50;
            // Small shelf
            ctx.fillStyle = '#8B6238';
            ctx.fillRect(cameraX - 20, cameraShelfY, 40, 5);
            ctx.fillStyle = '#A0764B';
            ctx.fillRect(cameraX - 18, cameraShelfY + 1, 36, 3);
            // Camera body
            ctx.fillStyle = '#333';
            ctx.fillRect(cameraX - 12, cameraShelfY - 18, 24, 16);
            ctx.fillStyle = '#444';
            ctx.fillRect(cameraX - 10, cameraShelfY - 16, 20, 12);
            // Lens
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.arc(cameraX, cameraShelfY - 10, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#4488FF';
            ctx.beginPath();
            ctx.arc(cameraX, cameraShelfY - 10, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.beginPath();
            ctx.arc(cameraX - 1, cameraShelfY - 11, 1.5, 0, Math.PI * 2);
            ctx.fill();
            // Flash
            ctx.fillStyle = '#DDD';
            ctx.fillRect(cameraX + 6, cameraShelfY - 20, 6, 4);
            // Viewfinder
            ctx.fillStyle = '#555';
            ctx.fillRect(cameraX - 4, cameraShelfY - 22, 8, 4);

            // ===== WALL PHOTO (if taken) =====
            if (wallPhoto) {
                const photoW = 180;
                const photoH = 110;
                const photoX = cameraX - photoW / 2;
                const photoY = floorY - 230;

                // Ornate frame
                ctx.fillStyle = '#8B6238';
                ctx.fillRect(photoX - 8, photoY - 8, photoW + 16, photoH + 16);
                ctx.fillStyle = '#A0764B';
                ctx.fillRect(photoX - 5, photoY - 5, photoW + 10, photoH + 10);
                ctx.fillStyle = '#C4935A';
                ctx.fillRect(photoX - 3, photoY - 3, photoW + 6, photoH + 6);

                // Photo image
                if (wallPhoto.loaded && wallPhoto._img) {
                    ctx.drawImage(wallPhoto._img, photoX, photoY, photoW, photoH);
                } else {
                    // Placeholder while loading
                    ctx.fillStyle = '#EEE';
                    ctx.fillRect(photoX, photoY, photoW, photoH);
                    ctx.fillStyle = '#999';
                    ctx.font = '12px Comic Sans MS';
                    ctx.textAlign = 'center';
                    ctx.fillText('≈Åadowanie...', photoX + photoW / 2, photoY + photoH / 2);
                }

                // Frame corner decorations
                ctx.fillStyle = '#8B6238';
                [[-8,-8],[photoW,-8],[-8,photoH],[photoW,photoH]].forEach(([cx,cy]) => {
                    ctx.beginPath();
                    ctx.arc(photoX + cx + 4, photoY + cy + 4, 5, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Hanging wire
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(photoX + 30, photoY - 8);
                ctx.quadraticCurveTo(photoX + photoW / 2, photoY - 25, photoX + photoW - 30, photoY - 8);
                ctx.stroke();
                // Nail
                ctx.fillStyle = '#888';
                ctx.beginPath();
                ctx.arc(photoX + photoW / 2, photoY - 22, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // ===== CAMERA FLASH EFFECT =====
            if (photoFlashTimer > 0) {
                photoFlashTimer--;
                const flashAlpha = photoFlashTimer / 20;
                ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha * 0.8})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // ===== LITTER BOX (far right corner) =====
            const litterX = canvas.width - 160;
            const litterY = floorY;

            // Litter box - 3D perspective
            // Back wall
            ctx.fillStyle = '#A8C8A8';
            ctx.beginPath();
            ctx.moveTo(litterX, litterY - 50);
            ctx.lineTo(litterX + 110, litterY - 50);
            ctx.lineTo(litterX + 100, litterY - 35);
            ctx.lineTo(litterX + 10, litterY - 35);
            ctx.closePath();
            ctx.fill();
            // Left side
            ctx.fillStyle = '#8FB88F';
            ctx.beginPath();
            ctx.moveTo(litterX, litterY - 50);
            ctx.lineTo(litterX + 10, litterY - 35);
            ctx.lineTo(litterX + 10, litterY + 10);
            ctx.lineTo(litterX, litterY + 5);
            ctx.closePath();
            ctx.fill();
            // Right side
            ctx.fillStyle = '#8FB88F';
            ctx.beginPath();
            ctx.moveTo(litterX + 110, litterY - 50);
            ctx.lineTo(litterX + 100, litterY - 35);
            ctx.lineTo(litterX + 100, litterY + 10);
            ctx.lineTo(litterX + 110, litterY + 5);
            ctx.closePath();
            ctx.fill();
            // Front
            ctx.fillStyle = '#A8C8A8';
            ctx.fillRect(litterX + 10, litterY - 15, 90, 25);
            // Rim
            ctx.fillStyle = '#7DA87D';
            ctx.fillRect(litterX + 5, litterY - 18, 100, 6);

            // Litter (sandy texture)
            ctx.fillStyle = '#E8D8B8';
            ctx.beginPath();
            ctx.ellipse(litterX + 55, litterY - 22, 42, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            // Litter texture dots
            ctx.fillStyle = '#D4C4A4';
            for (let i = 0; i < 30; i++) {
                const lx = litterX + 20 + (i * 17 + i * i * 3) % 70;
                const ly = litterY - 30 + (i * 13 + i * 7) % 16;
                ctx.beginPath();
                ctx.arc(lx, ly, 1 + (i % 2), 0, Math.PI * 2);
                ctx.fill();
            }
            // Small scoop next to litter box
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.moveTo(litterX + 115, litterY - 5);
            ctx.lineTo(litterX + 118, litterY - 45);
            ctx.lineTo(litterX + 121, litterY - 45);
            ctx.lineTo(litterX + 125, litterY - 5);
            ctx.closePath();
            ctx.fill();
            // Scoop head
            ctx.fillStyle = '#5B7FDE';
            ctx.beginPath();
            ctx.ellipse(litterX + 119, litterY - 47, 8, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            // Holes in scoop
            ctx.fillStyle = '#4169E1';
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(litterX + 116 + i * 4, litterY - 47, 1, 0, Math.PI * 2);
                ctx.fill();
            }

            // ===== TOYS (scattered on floor) =====

            // Ball (bouncy ball with stripes) - between bathtub and door
            const ballX = 1020;
            const ballY = floorY + 30;
            const ballBounce = Math.abs(Math.sin(interiorAnimationFrame * 0.03)) * 10;
            ctx.save();
            ctx.fillStyle = '#FF4444';
            ctx.beginPath();
            ctx.arc(ballX, ballY - ballBounce, 14, 0, Math.PI * 2);
            ctx.fill();
            // Ball stripe
            ctx.fillStyle = '#FFFF44';
            ctx.beginPath();
            ctx.arc(ballX, ballY - ballBounce, 14, -0.3, 0.3);
            ctx.arc(ballX, ballY - ballBounce, 14, Math.PI - 0.3, Math.PI + 0.3);
            ctx.fill();
            ctx.fillStyle = '#FFFF44';
            ctx.fillRect(ballX - 14, ballY - ballBounce - 3, 28, 6);
            // Ball highlight
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.arc(ballX - 4, ballY - ballBounce - 5, 4, 0, Math.PI * 2);
            ctx.fill();
            // Ball shadow
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath();
            ctx.ellipse(ballX, ballY + 14, 10, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Mouse toy (grey mouse on string)
            const mouseX = canvas.width / 2 - 120;
            const mouseY = floorY + 40;
            // String
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(mouseX + 25, mouseY - 5);
            ctx.quadraticCurveTo(mouseX + 40, mouseY - 20, mouseX + 50, mouseY - 5 + Math.sin(interiorAnimationFrame * 0.04) * 5);
            ctx.stroke();
            // Mouse body
            ctx.fillStyle = '#999';
            ctx.beginPath();
            ctx.ellipse(mouseX, mouseY, 15, 10, 0.1, 0, Math.PI * 2);
            ctx.fill();
            // Belly
            ctx.fillStyle = '#BBB';
            ctx.beginPath();
            ctx.ellipse(mouseX + 2, mouseY + 2, 10, 6, 0.1, 0, Math.PI * 2);
            ctx.fill();
            // Ears
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.arc(mouseX - 8, mouseY - 10, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#999';
            ctx.beginPath();
            ctx.arc(mouseX - 8, mouseY - 10, 6, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.arc(mouseX - 1, mouseY - 10, 5, 0, Math.PI * 2);
            ctx.fill();
            // Eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(mouseX - 8, mouseY - 3, 1.5, 0, Math.PI * 2);
            ctx.fill();
            // Nose
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.arc(mouseX - 14, mouseY - 1, 2, 0, Math.PI * 2);
            ctx.fill();
            // Whiskers
            ctx.strokeStyle = '#777';
            ctx.lineWidth = 0.5;
            [[-1, -3], [0, 0], [1, 3]].forEach(([_, dy]) => {
                ctx.beginPath();
                ctx.moveTo(mouseX - 14, mouseY - 1 + dy);
                ctx.lineTo(mouseX - 25, mouseY - 3 + dy);
                ctx.stroke();
            });
            // Tail
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(mouseX + 14, mouseY);
            ctx.quadraticCurveTo(mouseX + 25, mouseY - 10 + Math.sin(interiorAnimationFrame * 0.06) * 3, mouseX + 28, mouseY - 5);
            ctx.stroke();

            // Yarn ball
            const yarnX = 500;
            const yarnY = floorY + 35;
            ctx.fillStyle = '#9370DB';
            ctx.beginPath();
            ctx.arc(yarnX, yarnY, 12, 0, Math.PI * 2);
            ctx.fill();
            // Yarn threads
            ctx.strokeStyle = '#7B57C4';
            ctx.lineWidth = 1;
            for (let i = 0; i < 6; i++) {
                const a1 = i * 0.9;
                const a2 = a1 + 2;
                ctx.beginPath();
                ctx.arc(yarnX, yarnY, 10, a1, a2);
                ctx.stroke();
            }
            // Yarn highlight
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.arc(yarnX - 3, yarnY - 4, 4, 0, Math.PI * 2);
            ctx.fill();
            // Trailing thread
            ctx.strokeStyle = '#9370DB';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(yarnX + 12, yarnY);
            ctx.quadraticCurveTo(yarnX + 30, yarnY + 15, yarnX + 50, yarnY + 5);
            ctx.quadraticCurveTo(yarnX + 65, yarnY - 5, yarnX + 70, yarnY + 10);
            ctx.stroke();

            // Feather wand toy (leaning against wall)
            const wandX = canvas.width - 50;
            const wandBaseY = floorY;
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(wandX, wandBaseY);
            ctx.lineTo(wandX - 15, floorY - 120);
            ctx.stroke();
            // Feathers
            const featherColors = ['#FF69B4', '#FF4500', '#FFD700', '#9370DB', '#00CED1'];
            featherColors.forEach((col, i) => {
                ctx.fillStyle = col;
                ctx.save();
                ctx.translate(wandX - 15, floorY - 120);
                ctx.rotate(-0.5 + i * 0.25 + Math.sin(interiorAnimationFrame * 0.04 + i) * 0.1);
                ctx.beginPath();
                ctx.ellipse(0, -15, 3, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                // Feather spine
                ctx.strokeStyle = col;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(0, -3);
                ctx.lineTo(0, -25);
                ctx.stroke();
                ctx.restore();
            });

            // ===== EXIT DOOR (right wall, moved left to avoid wardrobe panel) =====
            const doorX = canvas.width - 350;
            const doorY = floorY - 160;
            // Door frame
            ctx.fillStyle = '#DDD';
            ctx.fillRect(doorX - 5, doorY - 5, 75, 165);
            // Door
            const doorGrad = ctx.createLinearGradient(doorX, doorY, doorX + 65, doorY);
            doorGrad.addColorStop(0, '#8B6238');
            doorGrad.addColorStop(0.5, '#A0764B');
            doorGrad.addColorStop(1, '#8B6238');
            ctx.fillStyle = doorGrad;
            ctx.fillRect(doorX, doorY, 65, 155);
            // Door panels
            ctx.strokeStyle = '#704E2E';
            ctx.lineWidth = 2;
            ctx.strokeRect(doorX + 8, doorY + 10, 49, 55);
            ctx.strokeRect(doorX + 8, doorY + 80, 49, 55);
            // Door knob
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(doorX + 55, doorY + 80, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#DAA520';
            ctx.beginPath();
            ctx.arc(doorX + 55, doorY + 80, 3, 0, Math.PI * 2);
            ctx.fill();

            // Exit sign
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            const signW = 140;
            const signH = 28;
            const signX = canvas.width - signW - 15;
            const signY = 12;
            // Rounded sign
            ctx.beginPath();
            ctx.roundRect(signX, signY, signW, signH, 8);
            ctx.fill();
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(signX, signY, signW, signH, 8);
            ctx.stroke();
            ctx.fillStyle = '#FF1493';
            ctx.font = 'bold 15px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('SPACJA - Wyjd≈∫', signX + signW / 2, signY + 19);

            // ===== WINDOW on wall (between couch and food) =====
            const winX = 440;
            const winY = 60;
            const winW = 100;
            const winH = 80;
            // Window frame
            ctx.fillStyle = '#FFF';
            ctx.fillRect(winX - 5, winY - 5, winW + 10, winH + 10);
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 2;
            ctx.strokeRect(winX - 5, winY - 5, winW + 10, winH + 10);
            // Sky through window (reflects outside weather)
            const wElapsed = (Date.now() - gameTimeStart) / 1000;
            const wDayCycle = (wElapsed % 60) / 60;
            const wRainCycle = wElapsed % 180;
            const wIsRaining = wRainCycle > 150;
            let winSkyColor;
            if (wDayCycle < 0.2) {
                winSkyColor = lerpColor('#1a1a3e', '#87CEEB', wDayCycle / 0.2);
            } else if (wDayCycle < 0.5) {
                winSkyColor = '#87CEEB';
            } else if (wDayCycle < 0.7) {
                winSkyColor = lerpColor('#87CEEB', '#FF6B35', (wDayCycle - 0.5) / 0.2);
            } else {
                winSkyColor = lerpColor('#FF6B35', '#0a0a2e', Math.min(1, (wDayCycle - 0.7) / 0.15));
            }
            if (wIsRaining) winSkyColor = lerpColor(winSkyColor, '#555566', 0.5);
            ctx.fillStyle = winSkyColor;
            ctx.fillRect(winX, winY, winW, winH);
            // Stars in window at night
            if (wDayCycle > 0.75) {
                const sAlpha = Math.min(1, (wDayCycle - 0.75) * 6);
                ctx.fillStyle = `rgba(255,255,220,${sAlpha})`;
                for (let si = 0; si < 5; si++) {
                    const sx = winX + 10 + si * 18;
                    const sy = winY + 10 + (si * 13) % 50;
                    ctx.beginPath();
                    ctx.arc(sx, sy, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Moon
                ctx.fillStyle = `rgba(255,253,231,${sAlpha * 0.9})`;
                ctx.beginPath();
                ctx.arc(winX + winW - 15, winY + 20, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = winSkyColor;
                ctx.beginPath();
                ctx.arc(winX + winW - 11, winY + 17, 7, 0, Math.PI * 2);
                ctx.fill();
            }
            // Sun in window during day
            if (wDayCycle > 0.15 && wDayCycle < 0.6) {
                const sunAlpha = wDayCycle < 0.25 ? (wDayCycle - 0.15) * 10 : wDayCycle > 0.5 ? (0.6 - wDayCycle) * 10 : 1;
                ctx.fillStyle = `rgba(255,255,0,${sunAlpha * 0.7})`;
                ctx.beginPath();
                ctx.arc(winX + 20, winY + 20, 10, 0, Math.PI * 2);
                ctx.fill();
            }
            // Rain drops on window
            if (wIsRaining) {
                ctx.strokeStyle = 'rgba(150,180,255,0.5)';
                ctx.lineWidth = 1;
                for (let ri = 0; ri < 8; ri++) {
                    const rx = winX + 5 + (ri * 13 + interiorAnimationFrame * 0.5) % (winW - 10);
                    const ry = winY + (ri * 17 + interiorAnimationFrame * 2) % winH;
                    ctx.beginPath();
                    ctx.moveTo(rx, ry);
                    ctx.lineTo(rx - 1, ry + 6);
                    ctx.stroke();
                }
            }
            // Window cross
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(winX + winW / 2, winY);
            ctx.lineTo(winX + winW / 2, winY + winH);
            ctx.moveTo(winX, winY + winH / 2);
            ctx.lineTo(winX + winW, winY + winH / 2);
            ctx.stroke();
            // Curtains
            ctx.fillStyle = '#FFB6C1';
            ctx.globalAlpha = 0.7;
            // Left curtain
            ctx.beginPath();
            ctx.moveTo(winX - 10, winY - 10);
            ctx.quadraticCurveTo(winX + 15, winY + winH / 2, winX - 5, winY + winH + 15);
            ctx.lineTo(winX - 15, winY + winH + 15);
            ctx.lineTo(winX - 15, winY - 10);
            ctx.closePath();
            ctx.fill();
            // Right curtain
            ctx.beginPath();
            ctx.moveTo(winX + winW + 10, winY - 10);
            ctx.quadraticCurveTo(winX + winW - 15, winY + winH / 2, winX + winW + 5, winY + winH + 15);
            ctx.lineTo(winX + winW + 15, winY + winH + 15);
            ctx.lineTo(winX + winW + 15, winY - 10);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1;
            // Curtain rod
            ctx.strokeStyle = '#DAA520';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(winX - 20, winY - 10);
            ctx.lineTo(winX + winW + 20, winY - 10);
            ctx.stroke();
            // Rod ends
            ctx.fillStyle = '#DAA520';
            ctx.beginPath();
            ctx.arc(winX - 20, winY - 10, 4, 0, Math.PI * 2);
            ctx.arc(winX + winW + 20, winY - 10, 4, 0, Math.PI * 2);
            ctx.fill();

            // ===== WALL PICTURE (small framed picture) =====
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(625, 70, 60, 50);
            ctx.fillStyle = '#FFF';
            ctx.fillRect(630, 75, 50, 40);
            // Little heart drawing inside
            ctx.fillStyle = '#FF69B4';
            ctx.font = '25px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('‚ô•', 655, 102);

            // ===== CHANDELIER (ceiling center, glows softly) =====
            const chandX = canvas.width / 2;
            const chandY = 20;

            // Ceiling mount plate
            ctx.fillStyle = '#DAA520';
            ctx.beginPath();
            ctx.ellipse(chandX, chandY, 15, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#C49B18';
            ctx.beginPath();
            ctx.ellipse(chandX, chandY, 12, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Chain links
            ctx.strokeStyle = '#DAA520';
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                const cy = chandY + 8 + i * 10;
                ctx.beginPath();
                ctx.ellipse(chandX, cy, 3, 5, 0, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Chandelier body - main ring
            const chandBodyY = chandY + 55;
            ctx.fillStyle = '#DAA520';
            ctx.beginPath();
            ctx.ellipse(chandX, chandBodyY, 40, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#C49B18';
            ctx.beginPath();
            ctx.ellipse(chandX, chandBodyY - 2, 35, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Chandelier arms and lights (5 lights)
            const numLights = 5;
            for (let i = 0; i < numLights; i++) {
                const angle = (i / numLights) * Math.PI * 2 - Math.PI / 2;
                const armEndX = chandX + Math.cos(angle) * 35;
                const armEndY = chandBodyY + Math.sin(angle) * 6;

                // Arm
                ctx.strokeStyle = '#DAA520';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(chandX + Math.cos(angle) * 10, chandBodyY + Math.sin(angle) * 2);
                ctx.quadraticCurveTo(armEndX, armEndY + 8, armEndX, armEndY + 12);
                ctx.stroke();

                // Candle holder cup
                ctx.fillStyle = '#DAA520';
                ctx.beginPath();
                ctx.moveTo(armEndX - 5, armEndY + 10);
                ctx.lineTo(armEndX + 5, armEndY + 10);
                ctx.lineTo(armEndX + 4, armEndY + 15);
                ctx.lineTo(armEndX - 4, armEndY + 15);
                ctx.closePath();
                ctx.fill();

                // Candle
                ctx.fillStyle = '#FFFFF0';
                ctx.fillRect(armEndX - 2, armEndY + 2, 4, 9);

                // Flame glow (based on light level)
                const flameFlicker = Math.sin(interiorAnimationFrame * 0.15 + i * 1.3) * 0.1;
                const flameBrightness = interiorLightLevel * (0.9 + flameFlicker);

                if (flameBrightness > 0.05) {
                    // Outer glow
                    const glowR = 12 + Math.sin(interiorAnimationFrame * 0.1 + i) * 2;
                    const flameGlow = ctx.createRadialGradient(armEndX, armEndY, 0, armEndX, armEndY, glowR);
                    flameGlow.addColorStop(0, `rgba(255, 200, 50, ${0.3 * flameBrightness})`);
                    flameGlow.addColorStop(1, `rgba(255, 200, 50, 0)`);
                    ctx.fillStyle = flameGlow;
                    ctx.beginPath();
                    ctx.arc(armEndX, armEndY, glowR, 0, Math.PI * 2);
                    ctx.fill();

                    // Flame
                    ctx.fillStyle = `rgba(255, 180, 30, ${flameBrightness})`;
                    ctx.beginPath();
                    ctx.moveTo(armEndX, armEndY - 4 - Math.sin(interiorAnimationFrame * 0.2 + i) * 2);
                    ctx.quadraticCurveTo(armEndX + 3, armEndY, armEndX, armEndY + 3);
                    ctx.quadraticCurveTo(armEndX - 3, armEndY, armEndX, armEndY - 4 - Math.sin(interiorAnimationFrame * 0.2 + i) * 2);
                    ctx.fill();

                    // Inner flame
                    ctx.fillStyle = `rgba(255, 240, 150, ${flameBrightness * 0.8})`;
                    ctx.beginPath();
                    ctx.ellipse(armEndX, armEndY, 1.5, 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Central chandelier glow (ambient light on room)
            const ambientGlowR = 100 + Math.sin(interiorAnimationFrame * 0.05) * 5;
            const ambientGlow = ctx.createRadialGradient(chandX, chandBodyY, 0, chandX, chandBodyY, ambientGlowR);
            ambientGlow.addColorStop(0, `rgba(255, 230, 150, ${0.12 * interiorLightLevel})`);
            ambientGlow.addColorStop(0.5, `rgba(255, 220, 120, ${0.05 * interiorLightLevel})`);
            ambientGlow.addColorStop(1, `rgba(255, 200, 80, 0)`);
            ctx.fillStyle = ambientGlow;
            ctx.beginPath();
            ctx.arc(chandX, chandBodyY, ambientGlowR, 0, Math.PI * 2);
            ctx.fill();

            // Bottom crystal/pendant
            ctx.fillStyle = '#E8D880';
            ctx.beginPath();
            ctx.moveTo(chandX, chandBodyY + 5);
            ctx.lineTo(chandX - 4, chandBodyY + 12);
            ctx.lineTo(chandX, chandBodyY + 20);
            ctx.lineTo(chandX + 4, chandBodyY + 12);
            ctx.closePath();
            ctx.fill();
            // Crystal sparkle
            ctx.fillStyle = `rgba(255, 255, 255, ${0.5 * interiorLightLevel + Math.sin(interiorAnimationFrame * 0.08) * 0.2 * interiorLightLevel})`;
            ctx.beginPath();
            ctx.arc(chandX - 1, chandBodyY + 10, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // ===== BED (upper-left, against back wall) =====
            const bedX = 30;
            const bedY = floorY - 10;
            const bedW = 120;
            const bedH = 50;

            // Bed legs
            ctx.fillStyle = '#5C3D2E';
            ctx.fillRect(bedX + 5, bedY + bedH - 5, 8, 15);
            ctx.fillRect(bedX + bedW - 13, bedY + bedH - 5, 8, 15);
            // Bed frame
            ctx.fillStyle = '#7B5B3A';
            ctx.fillRect(bedX, bedY, bedW, bedH);
            // Headboard
            const hbGrad = ctx.createLinearGradient(bedX, bedY - 40, bedX, bedY);
            hbGrad.addColorStop(0, '#5C3D2E');
            hbGrad.addColorStop(1, '#7B5B3A');
            ctx.fillStyle = hbGrad;
            ctx.beginPath();
            ctx.moveTo(bedX - 5, bedY);
            ctx.lineTo(bedX - 5, bedY - 35);
            ctx.quadraticCurveTo(bedX + 15, bedY - 45, bedX + 35, bedY - 35);
            ctx.lineTo(bedX + 35, bedY);
            ctx.closePath();
            ctx.fill();
            // Mattress
            ctx.fillStyle = '#FFF5EE';
            ctx.fillRect(bedX + 3, bedY + 3, bedW - 6, bedH - 10);
            // Blanket
            const blanketGrad = ctx.createLinearGradient(bedX, bedY, bedX + bedW, bedY);
            blanketGrad.addColorStop(0, '#FF85A2');
            blanketGrad.addColorStop(0.5, '#FFB6C1');
            blanketGrad.addColorStop(1, '#FF85A2');
            ctx.fillStyle = blanketGrad;
            ctx.fillRect(bedX + 35, bedY + 5, bedW - 40, bedH - 12);
            // Blanket fold line
            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(bedX + 35, bedY + 15);
            ctx.lineTo(bedX + bedW - 5, bedY + 15);
            ctx.stroke();
            // Pillow
            ctx.fillStyle = '#FFFAF0';
            ctx.beginPath();
            ctx.ellipse(bedX + 18, bedY + 18, 14, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#EEE';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.ellipse(bedX + 18, bedY + 18, 14, 10, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Footboard
            ctx.fillStyle = '#5C3D2E';
            ctx.fillRect(bedX + bedW - 5, bedY + 5, 5, bedH - 5);

            // ===== TOILET (middle area, visible - not covered by wardrobe) =====
            const toiletX = 700;
            const toiletY = floorY;

            // (bathroom area - no wall, open space)

            // Toilet base
            ctx.fillStyle = '#F5F5F5';
            ctx.beginPath();
            ctx.ellipse(toiletX, toiletY + 10, 22, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            // Toilet bowl
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.moveTo(toiletX - 18, toiletY - 25);
            ctx.lineTo(toiletX + 18, toiletY - 25);
            ctx.quadraticCurveTo(toiletX + 25, toiletY, toiletX + 20, toiletY + 8);
            ctx.lineTo(toiletX - 20, toiletY + 8);
            ctx.quadraticCurveTo(toiletX - 25, toiletY, toiletX - 18, toiletY - 25);
            ctx.fill();
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(toiletX - 18, toiletY - 25);
            ctx.lineTo(toiletX + 18, toiletY - 25);
            ctx.quadraticCurveTo(toiletX + 25, toiletY, toiletX + 20, toiletY + 8);
            ctx.lineTo(toiletX - 20, toiletY + 8);
            ctx.quadraticCurveTo(toiletX - 25, toiletY, toiletX - 18, toiletY - 25);
            ctx.stroke();
            // Seat
            ctx.fillStyle = '#FAFAFA';
            ctx.beginPath();
            ctx.ellipse(toiletX, toiletY - 12, 16, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#E0E0E0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(toiletX, toiletY - 12, 16, 10, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Water inside
            ctx.fillStyle = 'rgba(173, 216, 230, 0.5)';
            ctx.beginPath();
            ctx.ellipse(toiletX, toiletY - 12, 12, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            // Tank
            ctx.fillStyle = '#F0F0F0';
            ctx.fillRect(toiletX - 15, toiletY - 55, 30, 30);
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(toiletX - 15, toiletY - 55, 30, 30);
            // Flush handle
            ctx.strokeStyle = '#CCC';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(toiletX + 10, toiletY - 45);
            ctx.lineTo(toiletX + 20, toiletY - 48);
            ctx.stroke();
            ctx.fillStyle = '#CCC';
            ctx.beginPath();
            ctx.arc(toiletX + 20, toiletY - 48, 3, 0, Math.PI * 2);
            ctx.fill();
            // Toilet paper holder
            ctx.fillStyle = '#CCC';
            ctx.fillRect(toiletX + 30, toiletY - 30, 3, 25);
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(toiletX + 31, toiletY - 30, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#EEE';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(toiletX + 31, toiletY - 30, 10, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(toiletX + 31, toiletY - 30, 4, 0, Math.PI * 2);
            ctx.stroke();

            // ===== SINK (next to toilet) =====
            const sinkX = toiletX + 80;
            const sinkY = floorY - 60;

            // Sink pipe (going to wall)
            ctx.fillStyle = '#CCC';
            ctx.fillRect(sinkX - 3, sinkY + 40, 6, floorY - sinkY - 30);
            // Sink pedestal
            ctx.fillStyle = '#F0F0F0';
            ctx.fillRect(sinkX - 8, sinkY + 30, 16, 35);
            // Sink basin
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.ellipse(sinkX, sinkY + 15, 28, 15, 0, 0, Math.PI);
            ctx.fill();
            ctx.fillStyle = '#FAFAFA';
            ctx.beginPath();
            ctx.ellipse(sinkX, sinkY + 10, 30, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(sinkX, sinkY + 10, 30, 12, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Water in sink
            ctx.fillStyle = 'rgba(173, 216, 230, 0.3)';
            ctx.beginPath();
            ctx.ellipse(sinkX, sinkY + 11, 24, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            // Drain
            ctx.fillStyle = '#AAA';
            ctx.beginPath();
            ctx.arc(sinkX, sinkY + 13, 3, 0, Math.PI * 2);
            ctx.fill();
            // Faucet
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(sinkX - 3, sinkY - 15, 6, 20);
            // Faucet top curve
            ctx.strokeStyle = '#C0C0C0';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(sinkX, sinkY - 15, 10, Math.PI, 0);
            ctx.stroke();
            // Faucet spout
            ctx.fillStyle = '#B0B0B0';
            ctx.fillRect(sinkX + 7, sinkY - 15, 5, 10);
            // Faucet handles
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.arc(sinkX - 15, sinkY - 5, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FF4444';
            ctx.beginPath();
            ctx.arc(sinkX + 15, sinkY - 5, 5, 0, Math.PI * 2);
            ctx.fill();
            // Mirror above sink
            ctx.fillStyle = '#E8E8FF';
            ctx.beginPath();
            ctx.ellipse(sinkX, sinkY - 50, 25, 30, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#DAA520';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(sinkX, sinkY - 50, 25, 30, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Mirror reflection
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.ellipse(sinkX - 8, sinkY - 55, 8, 12, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // ===== BATHTUB (next to sink, bigger) =====
            const bathtubX = sinkX + 140;
            const bathtubY = floorY;
            const bathtubW = 140;
            const bathtubH = 70;

            // Bathtub body (back half - drawn before player)
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.moveTo(bathtubX - bathtubW / 2 + 10, bathtubY - bathtubH);
            ctx.lineTo(bathtubX + bathtubW / 2 - 10, bathtubY - bathtubH);
            ctx.quadraticCurveTo(bathtubX + bathtubW / 2, bathtubY - bathtubH / 2, bathtubX + bathtubW / 2 - 5, bathtubY - 10);
            ctx.lineTo(bathtubX - bathtubW / 2 + 5, bathtubY - 10);
            ctx.quadraticCurveTo(bathtubX - bathtubW / 2, bathtubY - bathtubH / 2, bathtubX - bathtubW / 2 + 10, bathtubY - bathtubH);
            ctx.fill();
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Bathtub rim (top edge, thicker)
            ctx.strokeStyle = '#EEE';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(bathtubX - bathtubW / 2 + 10, bathtubY - bathtubH);
            ctx.lineTo(bathtubX + bathtubW / 2 - 10, bathtubY - bathtubH);
            ctx.stroke();

            // Bathtub legs (clawfoot style)
            ctx.fillStyle = '#C0C0C0';
            // Left leg
            ctx.beginPath();
            ctx.ellipse(bathtubX - bathtubW / 2 + 15, bathtubY - 5, 6, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            // Right leg
            ctx.beginPath();
            ctx.ellipse(bathtubX + bathtubW / 2 - 15, bathtubY - 5, 6, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Faucet/tap
            ctx.strokeStyle = '#C0C0C0';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(bathtubX - 30, bathtubY - bathtubH - 5);
            ctx.lineTo(bathtubX - 30, bathtubY - bathtubH - 20);
            ctx.lineTo(bathtubX - 10, bathtubY - bathtubH - 20);
            ctx.stroke();
            // Tap drip
            ctx.strokeStyle = '#B0B0B0';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(bathtubX - 10, bathtubY - bathtubH - 20);
            ctx.lineTo(bathtubX - 10, bathtubY - bathtubH - 16);
            ctx.stroke();

            // Tap handles (hot/cold)
            ctx.fillStyle = '#E74C3C';
            ctx.beginPath();
            ctx.arc(bathtubX - 38, bathtubY - bathtubH - 18, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#3498DB';
            ctx.beginPath();
            ctx.arc(bathtubX - 22, bathtubY - bathtubH - 18, 5, 0, Math.PI * 2);
            ctx.fill();

            // Water level indicator (stored in interiorPlayer for persistence)
            if (!interiorPlayer.bathtubWaterLevel) interiorPlayer.bathtubWaterLevel = 0;
            if (interiorPlayer.bathtubWaterLevel > 0 && interiorPlayer.action !== 'bathing') {
                const waterH = bathtubH * 0.7 * interiorPlayer.bathtubWaterLevel;
                const waterAlpha = 0.3 + interiorPlayer.bathtubWaterLevel * 0.3;
                ctx.fillStyle = `rgba(100, 180, 255, ${waterAlpha})`;
                ctx.beginPath();
                ctx.ellipse(bathtubX, bathtubY - 15 - waterH / 2, bathtubW / 2 - 10, waterH / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                // Water surface reflection
                ctx.fillStyle = `rgba(255, 255, 255, ${0.3 * interiorPlayer.bathtubWaterLevel})`;
                ctx.beginPath();
                ctx.ellipse(bathtubX - 15, bathtubY - 15 - waterH, 15, 4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Drain swirl effect (visible while draining)
                if (interiorPlayer.bathtubWaterLevel < 0.95) {
                    const swirlX = bathtubX;
                    const swirlY = bathtubY - 15 - waterH * 0.3;
                    const swirlSize = 8 * interiorPlayer.bathtubWaterLevel;
                    const swirlAngle = interiorAnimationFrame * 0.15;
                    ctx.save();
                    ctx.translate(swirlX, swirlY);
                    ctx.rotate(swirlAngle);
                    ctx.strokeStyle = `rgba(70, 150, 220, ${0.4 * interiorPlayer.bathtubWaterLevel})`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    for (let a = 0; a < Math.PI * 4; a += 0.2) {
                        const r = (a / (Math.PI * 4)) * swirlSize;
                        const sx = Math.cos(a) * r;
                        const sy = Math.sin(a) * r * 0.5;
                        if (a === 0) ctx.moveTo(sx, sy);
                        else ctx.lineTo(sx, sy);
                    }
                    ctx.stroke();
                    ctx.restore();

                    // Small bubbles rising from drain
                    for (let b = 0; b < 3; b++) {
                        const bubblePhase = (interiorAnimationFrame * 0.05 + b * 2.1) % 1;
                        const bx = swirlX + Math.sin(interiorAnimationFrame * 0.08 + b * 1.7) * 6;
                        const by = swirlY - bubblePhase * waterH * 0.6;
                        const br = 2 + Math.sin(b * 1.3) * 1;
                        const bAlpha = (1 - bubblePhase) * 0.4 * interiorPlayer.bathtubWaterLevel;
                        ctx.fillStyle = `rgba(200, 230, 255, ${bAlpha})`;
                        ctx.beginPath();
                        ctx.arc(bx, by, br, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // ===== TITLE & INFO =====
            ctx.fillStyle = '#8B4513';
            ctx.font = 'bold 28px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('üè† Dom Kicioro≈ºka üè†', canvas.width / 2, 35);

            ctx.font = 'bold 18px Comic Sans MS';
            ctx.fillStyle = '#A0764B';
            ctx.fillText(`Przyjaciele w domu: ${interiorFriends.length}`, canvas.width / 2, 60);

            // ===== CAT NEEDS ICONS (top bar) =====
            const needThreshold = 70;
            const activeNeeds = [];
            if (catNeeds.hunger >= needThreshold) activeNeeds.push({ type: 'hunger', val: catNeeds.hunger });
            if (catNeeds.sleep >= needThreshold) activeNeeds.push({ type: 'sleep', val: catNeeds.sleep });
            if (catNeeds.toilet >= needThreshold) activeNeeds.push({ type: 'toilet', val: catNeeds.toilet });
            if (catNeeds.hygiene >= needThreshold) activeNeeds.push({ type: 'hygiene', val: catNeeds.hygiene });

            if (activeNeeds.length > 0) {
                const needBarW = activeNeeds.length * 60 + 20;
                const needBarX = canvas.width / 2 - needBarW / 2;
                const needBarY = 72;

                // Background bubble
                ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                ctx.beginPath();
                ctx.roundRect(needBarX, needBarY, needBarW, 50, 12);
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 150, 180, 0.6)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(needBarX, needBarY, needBarW, 50, 12);
                ctx.stroke();

                // Thought bubble tail
                ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                ctx.beginPath();
                ctx.arc(canvas.width / 2, needBarY + 55, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(canvas.width / 2 + 5, needBarY + 62, 3, 0, Math.PI * 2);
                ctx.fill();

                activeNeeds.forEach((need, idx) => {
                    const nx = needBarX + 10 + idx * 60 + 25;
                    const ny = needBarY + 25;
                    const urgency = (need.val - needThreshold) / (100 - needThreshold); // 0-1
                    const pulse = 1 + Math.sin(interiorAnimationFrame * 0.1 + idx) * 0.08 * urgency;

                    ctx.save();
                    ctx.translate(nx, ny);
                    ctx.scale(pulse, pulse);

                    if (need.type === 'hunger') {
                        // Fish icon (cat food)
                        ctx.fillStyle = urgency > 0.7 ? '#FF4444' : '#FF8C42';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 14, 8, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Fish tail
                        ctx.beginPath();
                        ctx.moveTo(-14, 0);
                        ctx.lineTo(-22, -7);
                        ctx.lineTo(-22, 7);
                        ctx.closePath();
                        ctx.fill();
                        // Eye
                        ctx.fillStyle = '#FFF';
                        ctx.beginPath();
                        ctx.arc(6, -2, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(7, -2, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (need.type === 'sleep') {
                        // Moon + Zzz icon
                        ctx.fillStyle = urgency > 0.7 ? '#FF4444' : '#6B7EC4';
                        ctx.beginPath();
                        ctx.arc(0, 0, 12, 0, Math.PI * 2);
                        ctx.fill();
                        // Moon shadow (crescent)
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                        ctx.beginPath();
                        ctx.arc(5, -3, 10, 0, Math.PI * 2);
                        ctx.fill();
                        // Redraw crescent
                        ctx.fillStyle = urgency > 0.7 ? '#FF4444' : '#6B7EC4';
                        ctx.beginPath();
                        ctx.arc(-1, -1, 11, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                        ctx.beginPath();
                        ctx.arc(3, -4, 9, 0, Math.PI * 2);
                        ctx.fill();
                        // Small Z
                        ctx.fillStyle = urgency > 0.7 ? '#FF4444' : '#8B9DD4';
                        ctx.font = 'bold 10px Comic Sans MS';
                        ctx.textAlign = 'center';
                        ctx.fillText('z', 12, -5);
                    } else if (need.type === 'toilet') {
                        // Poop icon
                        const poopColor = urgency > 0.7 ? '#FF4444' : '#8B6914';
                        ctx.fillStyle = poopColor;
                        // Bottom swirl
                        ctx.beginPath();
                        ctx.ellipse(0, 6, 10, 6, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Middle swirl
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 8, 5, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Top swirl
                        ctx.beginPath();
                        ctx.ellipse(1, -6, 6, 4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Top tip
                        ctx.beginPath();
                        ctx.arc(3, -10, 3, 0, Math.PI * 2);
                        ctx.fill();
                        // Eyes
                        ctx.fillStyle = '#FFF';
                        ctx.beginPath();
                        ctx.arc(-3, -1, 2.5, 0, Math.PI * 2);
                        ctx.arc(4, -1, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(-3, -1, 1, 0, Math.PI * 2);
                        ctx.arc(4, -1, 1, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (need.type === 'hygiene') {
                        // Shower icon
                        const showerColor = urgency > 0.7 ? '#FF4444' : '#5DADE2';
                        // Shower head
                        ctx.fillStyle = '#999';
                        ctx.beginPath();
                        ctx.roundRect(-8, -14, 16, 6, 2);
                        ctx.fill();
                        // Shower pipe
                        ctx.fillStyle = '#AAA';
                        ctx.fillRect(6, -14, 3, -6);
                        ctx.fillRect(6, -20, 10, 3);
                        // Water drops
                        ctx.fillStyle = showerColor;
                        for (let wd = 0; wd < 5; wd++) {
                            const wdx = -6 + wd * 3;
                            const wdy = -5 + (wd % 2) * 3;
                            ctx.beginPath();
                            ctx.moveTo(wdx, wdy);
                            ctx.quadraticCurveTo(wdx + 2, wdy + 4, wdx, wdy + 7);
                            ctx.quadraticCurveTo(wdx - 2, wdy + 4, wdx, wdy);
                            ctx.fill();
                        }
                    }

                    ctx.restore();
                });
            }

            // ===== UPDATE & DRAW FRIENDS =====
            updateInteriorFriends();
            interiorFriends.forEach(friend => {
                drawInteriorFriend(friend);
            });

            // ===== INTERIOR PLAYER MOVEMENT & INTERACTIONS =====
            updateInteriorPlayer(floorY, bedX, bedW, toiletX, sinkX, bathtubX);
            updatePlayer2Interior(floorY);

            // ===== DRAW PLAYER IN INTERIOR =====
            drawInteriorPlayer(floorY, bedX, bedY, bedW, bedH);

            // ===== INTERACTION HINTS =====
            drawInteriorHints(bedX, bedW, toiletX, sinkX, bathtubX, floorY);

            // ===== CONVERSATIONS =====
            updateConversation();
            drawConversation();

            // ===== P2 HUD IN INTERIOR =====
            if (player2.active && player2.selectedType) {
                ctx.save();
                const hudX = 10;
                const hudY = canvas.height - 40;
                ctx.fillStyle = 'rgba(70, 130, 230, 0.8)';
                ctx.beginPath();
                ctx.roundRect(hudX, hudY, 200, 30, 8);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.textAlign = 'left';
                ctx.fillText('P2: ' + player2.selectedType.name + ' (WASD+E)', hudX + 10, hudY + 20);
                ctx.restore();
            }

            // ===== NIGHT DIMMING OVERLAY (when sleeping) =====
            if (interiorLightLevel < 1.0) {
                const darkness = 1.0 - interiorLightLevel;
                // Dark blue overlay for nighttime feel
                ctx.fillStyle = `rgba(10, 10, 40, ${darkness * 0.7})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Window weather is already reflected in the window drawing above
            }
        }

        // Furniture targets for friends - X positions and IDs
        const furnitureSpots = {
            using_toilet: { x: 700, id: 'toilet' },
            watching_tv: { x: 200, id: 'tv' },
            couch_sleeping: { x: 400, id: 'couch' },
            playing_ball: { x: 0, id: 'ball' }, // x set dynamically
            friend_eating: { x: 510, id: 'bowls' }
        };

        function isFurnitureOccupied(spotId, excludeFriend) {
            // Check if player is using it
            if (spotId === 'toilet' && interiorPlayer.action === 'toilet') return true;
            if (spotId === 'tv' && interiorPlayer.action === 'playing') return true;
            if (spotId === 'couch' && (interiorPlayer.action === 'couch_rest' || interiorPlayer.action === 'sleeping')) return true;
            if (spotId === 'ball' && interiorPlayer.action === 'playing') return true;
            if (spotId === 'bowls' && interiorPlayer.action === 'eating') return true;
            // Check if P2 is using it
            if (player2.active) {
                if (spotId === 'toilet' && player2.interiorAction === 'toilet') return true;
                if (spotId === 'tv' && player2.interiorAction === 'playing') return true;
                if (spotId === 'couch' && (player2.interiorAction === 'couch_rest' || player2.interiorAction === 'sleeping')) return true;
                if (spotId === 'ball' && player2.interiorAction === 'playing') return true;
                if (spotId === 'bowls' && player2.interiorAction === 'eating') return true;
            }
            // Check if another friend is using or walking to it
            for (const f of interiorFriends) {
                if (f === excludeFriend) continue;
                // Skip P2-controlled friend (their state is tracked via player2.interiorAction)
                if (player2.active && f.type.emoji === p2ControlledFriendEmoji) continue;
                if (f.furnitureTarget === spotId) return true;
            }
            return false;
        }

        function countFriendsUsingFurniture() {
            let count = 0;
            for (const f of interiorFriends) {
                if (f.furnitureTarget) count++;
            }
            return count;
        }

        function updateInteriorFriends() {
            const floorY = canvas.height - 180;
            const walkSpeed = 1.5;
            furnitureSpots.playing_ball.x = 1020;

            interiorFriends.forEach(friend => {
                // Skip P2-controlled friend
                if (player2.active && friend.type.emoji === p2ControlledFriendEmoji) return;
                friend.activityTimer--;
                friend.animFrame++;

                // Change activity when timer runs out
                if (friend.activityTimer <= 0) {
                    friend.furnitureTarget = null; // Clear any furniture claim

                    // Decide next activity - mostly walking, sometimes furniture
                    const roll = Math.random();
                    let nextActivity = 'walking';

                    if (roll > 0.6 && countFriendsUsingFurniture() < 2) {
                        // Try a furniture activity
                        const furnitureOptions = ['using_toilet', 'watching_tv', 'couch_sleeping', 'playing_ball', 'friend_eating'];
                        // Shuffle and pick first available
                        const shuffled = furnitureOptions.sort(() => Math.random() - 0.5);
                        for (const opt of shuffled) {
                            if (!isFurnitureOccupied(furnitureSpots[opt].id, friend)) {
                                nextActivity = 'walking_to';
                                friend.targetActivity = opt;
                                friend.walkTargetX = furnitureSpots[opt].x;
                                friend.furnitureTarget = furnitureSpots[opt].id;
                                break;
                            }
                        }
                        if (nextActivity !== 'walking_to') {
                            nextActivity = 'walking'; // All furniture busy
                        }
                    } else if (roll > 0.5) {
                        nextActivity = 'jumping';
                    }

                    friend.activity = nextActivity;

                    if (friend.activity === 'walking') {
                        friend.activityTimer = 100 + Math.floor(Math.random() * 100);
                        friend.velX = (Math.random() > 0.5 ? 1 : -1) * (1 + Math.random());
                    } else if (friend.activity === 'jumping') {
                        friend.activityTimer = 80 + Math.floor(Math.random() * 60);
                        friend.jumpPower = -10;
                    } else if (friend.activity === 'walking_to') {
                        friend.activityTimer = 500; // Max time to reach target
                    }
                }

                // Activity behaviors
                if (friend.activity === 'walking') {
                    friend.x += friend.velX;
                    friend.y = floorY - 20;
                    if (friend.x < 50 || friend.x > canvas.width - 50) {
                        friend.velX *= -1;
                        friend.x = Math.max(50, Math.min(canvas.width - 50, friend.x));
                    }
                } else if (friend.activity === 'walking_to') {
                    // Walk toward target
                    friend.y = floorY - 20;
                    const dx = friend.walkTargetX - friend.x;
                    if (Math.abs(dx) < walkSpeed + 1) {
                        // Arrived! Switch to actual activity
                        friend.x = friend.walkTargetX;
                        friend.activity = friend.targetActivity;
                        if (friend.activity === 'using_toilet') {
                            friend.activityTimer = 120 + Math.floor(Math.random() * 60);
                        } else if (friend.activity === 'watching_tv') {
                            friend.activityTimer = 150 + Math.floor(Math.random() * 100);
                        } else if (friend.activity === 'couch_sleeping') {
                            friend.activityTimer = 200 + Math.floor(Math.random() * 100);
                        } else if (friend.activity === 'playing_ball') {
                            friend.activityTimer = 100 + Math.floor(Math.random() * 80);
                        } else if (friend.activity === 'friend_eating') {
                            friend.activityTimer = 90 + Math.floor(Math.random() * 60);
                        }
                    } else {
                        friend.velX = dx > 0 ? walkSpeed : -walkSpeed;
                        friend.x += friend.velX;
                    }
                } else if (friend.activity === 'jumping') {
                    friend.velY += 0.6;
                    friend.y += friend.velY;
                    if (friend.y >= floorY - 20) {
                        friend.y = floorY - 20;
                        friend.velY = 0;
                        if (friend.jumpPower < 0) {
                            friend.velY = friend.jumpPower;
                            friend.jumpPower = 0;
                        }
                    }
                } else if (friend.activity === 'playing_ball') {
                    friend.y = floorY - 20 + Math.sin(friend.animFrame * 0.15) * 6;
                }
                // using_toilet, watching_tv, couch_sleeping: stay in place
            });
        }

        function drawInteriorFriend(friend) {
            ctx.save();

            const drawFunctions = {
                'üê∂': drawDog,
                'üê∞': drawRabbit,
                'üêª': drawBear,
                'üêë': drawSheep,
                'üê¨': drawDolphin,
                'ü¶ä': drawFox,
                'üêº': drawPanda,
                'ü¶Ñ': drawUnicorn,
                'üê∏': drawFrog,
                'ü¶ã': drawButterfly
            };

            const drawFunction = drawFunctions[friend.type.emoji] || drawDog;

            if (friend.activity === 'walking' || friend.activity === 'walking_to') {
                // Walking animation - bob up/down and tilt
                const walkBob = Math.sin(friend.animFrame * 0.3) * 2;
                const walkTilt = Math.sin(friend.animFrame * 0.15) * 0.05;
                ctx.translate(friend.x, friend.y + walkBob);
                ctx.rotate(walkTilt);
                if (friend.velX < 0) ctx.scale(-1, 1);
                drawFunction(0, 0, 1);
            } else if (friend.activity === 'using_toilet') {
                // Sitting on toilet - draw smaller, sitting
                ctx.save();
                ctx.translate(friend.x, friend.y + 5);
                ctx.scale(0.7, 0.7);
                drawFunction(0, 0, 1);
                ctx.restore();
                // Newspaper
                ctx.fillStyle = '#F5F5DC';
                ctx.fillRect(friend.x + 12, friend.y + 5, 12, 16);
                ctx.strokeStyle = '#CCC';
                ctx.lineWidth = 0.5;
                for (let l = 0; l < 3; l++) {
                    ctx.beginPath();
                    ctx.moveTo(friend.x + 14, friend.y + 9 + l * 4);
                    ctx.lineTo(friend.x + 22, friend.y + 9 + l * 4);
                    ctx.stroke();
                }
            } else if (friend.activity === 'watching_tv') {
                // Sitting in front of TV
                drawFunction(friend.x, friend.y, 1);
                // Eyes glowing from TV light
                const tvGlow = Math.sin(friend.animFrame * 0.05) * 0.3 + 0.5;
                ctx.fillStyle = `rgba(100, 200, 255, ${tvGlow})`;
                ctx.beginPath();
                ctx.arc(friend.x - 3, friend.y + 8, 3, 0, Math.PI * 2);
                ctx.arc(friend.x + 5, friend.y + 8, 3, 0, Math.PI * 2);
                ctx.fill();
            } else if (friend.activity === 'couch_sleeping') {
                // Lying on couch - rotated
                ctx.save();
                ctx.translate(friend.x, friend.y - 15);
                ctx.rotate(-Math.PI / 2);
                ctx.scale(0.55, 0.55);
                drawFunction(0, 0, 1);
                ctx.restore();
                // Zzz
                const zt = friend.animFrame * 0.02;
                for (let z = 0; z < 2; z++) {
                    const zOff = ((zt + z * 0.8) % 1.5);
                    const zAlpha = Math.max(0, 1 - zOff / 1.5);
                    ctx.fillStyle = `rgba(100, 100, 200, ${zAlpha * 0.5})`;
                    ctx.font = `bold ${8 + z * 3 + zOff * 5}px Comic Sans MS`;
                    ctx.textAlign = 'center';
                    ctx.fillText('z', friend.x + 10 + zOff * 10 + z * 5, friend.y - 25 - zOff * 15);
                }
            } else if (friend.activity === 'friend_eating') {
                // Eating at bowls - food to mouth animation
                drawFunction(friend.x, friend.y, 1);
                const eatCycle = (friend.animFrame % 35) / 35;
                const bowlLevel = friend.y + 8;
                const mouthLevel = friend.y - 12;
                const foodPX = friend.x + 8 - eatCycle * 4;
                const foodPY = bowlLevel + (mouthLevel - bowlLevel) * eatCycle - Math.sin(eatCycle * Math.PI) * 10;
                const fAlpha = eatCycle < 0.85 ? 1 : (1 - (eatCycle - 0.85) / 0.15);
                ctx.globalAlpha = fAlpha;
                const fColors = ['#8B4513', '#FF6347', '#FFD700', '#32CD32'];
                ctx.fillStyle = fColors[Math.floor(friend.animFrame / 35) % fColors.length];
                ctx.beginPath();
                ctx.arc(foodPX, foodPY, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                // Chewing cheeks
                if (eatCycle > 0.85 || eatCycle < 0.1) {
                    const chew = Math.sin(friend.animFrame * 0.5) * 1.5;
                    ctx.fillStyle = 'rgba(255, 180, 180, 0.4)';
                    ctx.beginPath();
                    ctx.arc(friend.x - 5, mouthLevel + 2, 3 + chew, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(friend.x + 5, mouthLevel + 2, 3 - chew, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Crumbs
                for (let cr = 0; cr < 2; cr++) {
                    const crP = ((friend.animFrame * 0.06 + cr * 0.5) % 1);
                    if (crP < 0.5) {
                        ctx.fillStyle = `rgba(139, 69, 19, ${0.5 * (1 - crP / 0.5)})`;
                        ctx.beginPath();
                        ctx.arc(friend.x - 2 + cr * 4, mouthLevel + 3 + crP * 18, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            } else if (friend.activity === 'playing_ball') {
                // Bouncing with ball
                drawFunction(friend.x, friend.y, 1);
                // Small ball bouncing
                const ballY = friend.y - 25 - Math.abs(Math.sin(friend.animFrame * 0.12)) * 20;
                ctx.fillStyle = '#FF4444';
                ctx.beginPath();
                ctx.arc(friend.x + 5, ballY, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFFF44';
                ctx.fillRect(friend.x + 5 - 6, ballY - 1, 12, 2);
            } else if (friend.activity === 'talking') {
                // Talking - face the player, slight head bob
                const facingLeft = interiorPlayer.x < friend.x;
                ctx.save();
                ctx.translate(friend.x, friend.y);
                if (facingLeft) ctx.scale(-1, 1);
                const bob = Math.sin(friend.animFrame * 0.1) * 2;
                ctx.translate(0, bob);
                drawFunction(0, 0, 1);
                ctx.restore();
            } else if (friend.activity === 'p2_controlled') {
                // P2-controlled: check for furniture actions first
                const p2Action = player2.interiorAction;
                
                if (p2Action === 'sleeping') {
                    // Sleeping in bed - rotated
                    ctx.save();
                    ctx.translate(friend.x, friend.y - 15);
                    ctx.rotate(-Math.PI / 2);
                    ctx.scale(0.55, 0.55);
                    drawFunction(0, 0, 1);
                    ctx.restore();
                    // Zzz
                    const zt = interiorAnimationFrame * 0.02;
                    for (let z = 0; z < 2; z++) {
                        const zOff = ((zt + z * 0.8) % 1.5);
                        const zAlpha = Math.max(0, 1 - zOff / 1.5);
                        ctx.fillStyle = `rgba(100, 100, 200, ${zAlpha * 0.5})`;
                        ctx.font = `bold ${8 + z * 3 + zOff * 5}px Comic Sans MS`;
                        ctx.textAlign = 'center';
                        ctx.fillText('z', friend.x + 10 + zOff * 10 + z * 5, friend.y - 25 - zOff * 15);
                    }
                } else if (p2Action === 'toilet') {
                    // Sitting on toilet
                    ctx.save();
                    ctx.translate(friend.x, friend.y + 5);
                    ctx.scale(0.7, 0.7);
                    drawFunction(0, 0, 1);
                    ctx.restore();
                    // Newspaper
                    ctx.fillStyle = '#F5F5DC';
                    ctx.fillRect(friend.x + 12, friend.y + 5, 12, 16);
                } else if (p2Action === 'washing') {
                    // Washing at sink
                    drawFunction(friend.x, friend.y, 1);
                    // Water drops
                    ctx.fillStyle = 'rgba(100, 180, 255, 0.6)';
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(friend.x + 10 + i * 5, friend.y - 5 + Math.sin(interiorAnimationFrame * 0.1 + i) * 3, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (p2Action === 'eating') {
                    // Eating at bowls
                    drawFunction(friend.x, friend.y, 1);
                    const eatCycle = (interiorAnimationFrame % 35) / 35;
                    const bowlLevel = friend.y + 8;
                    const mouthLevel = friend.y - 12;
                    const foodPX = friend.x + 8 - eatCycle * 4;
                    const foodPY = bowlLevel + (mouthLevel - bowlLevel) * eatCycle - Math.sin(eatCycle * Math.PI) * 10;
                    ctx.fillStyle = '#8B4513';
                    ctx.beginPath();
                    ctx.arc(foodPX, foodPY, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p2Action === 'playing') {
                    // Playing with ball
                    drawFunction(friend.x, friend.y, 1);
                    const ballY = friend.y - 25 - Math.abs(Math.sin(interiorAnimationFrame * 0.12)) * 20;
                    ctx.fillStyle = '#FF4444';
                    ctx.beginPath();
                    ctx.arc(friend.x + 5, ballY, 6, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p2Action === 'couch_rest') {
                    // Resting on couch
                    ctx.save();
                    ctx.translate(friend.x, friend.y - 15);
                    ctx.rotate(-Math.PI / 2);
                    ctx.scale(0.55, 0.55);
                    drawFunction(0, 0, 1);
                    ctx.restore();
                } else if (p2Action === 'bathing') {
                    // Bathing - simplified
                    drawFunction(friend.x, friend.y - 10, 0.8);
                    // Water splash
                    ctx.fillStyle = 'rgba(100, 180, 255, 0.4)';
                    ctx.beginPath();
                    ctx.ellipse(friend.x, friend.y, 20, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    if (player2.bathFoam) {
                        // Foam bubbles
                        ctx.fillStyle = '#FFF';
                        for (let i = 0; i < 5; i++) {
                            ctx.beginPath();
                            ctx.arc(friend.x - 10 + i * 5, friend.y - 25 + Math.sin(interiorAnimationFrame * 0.05 + i) * 3, 4, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                } else {
                    // Default: walking animation with bob
                    const walkBob = Math.sin(player2.walkCycle * 3) * 2;
                    ctx.save();
                    ctx.translate(friend.x, friend.y + walkBob);
                    if (!player2.facingRight) ctx.scale(-1, 1);
                    drawFunction(0, 0, 1);
                    ctx.restore();
                }
                
                // P2 badge (always show)
                ctx.fillStyle = 'rgba(70, 130, 230, 0.85)';
                ctx.beginPath();
                ctx.roundRect(friend.x - 14, friend.y - 40, 28, 16, 6);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 10px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('P2', friend.x, friend.y - 28);
            } else {
                drawFunction(friend.x, friend.y, 1);
            }

            ctx.restore();
        }

        // ========== PLAYER 2 INTERIOR ==========

        function updatePlayer2Interior(floorY) {
            if (!player2.active || gameState !== 'interior') return;

            // Find controlled friend
            const friend = interiorFriends.find(f => f.type.emoji === p2ControlledFriendEmoji);
            if (!friend) {
                player2.active = false;
                player2.selectedIndex = -1;
                player2.selectedType = null;
                p2ControlledFriendEmoji = null;
                return;
            }

            // Keep AI from taking over
            friend.activity = 'p2_controlled';
            friend.furnitureTarget = null;

            // Handle action states
            if (player2.interiorAction === 'draining_water' && player2.bathtubWaterLevel > 0) {
                player2.bathtubWaterLevel = Math.max(0, player2.bathtubWaterLevel - 0.012);
                if (player2.bathtubWaterLevel <= 0) {
                    player2.interiorAction = 'none';
                }
            }

            if (player2.interiorAction !== 'none') {
                if (player2.interiorAction === 'bathing') {
                    if (keys['a'] || keys['A'] || keys['d'] || keys['D']) {
                        player2.bathFoam = false;
                        player2.interiorAction = 'none';
                    }
                    return;
                }
                if (player2.interiorAction === 'draining_water') return;

                player2.interiorActionTimer--;
                if (player2.interiorActionTimer <= 0) {
                    if (player2.interiorAction === 'filling_water') {
                        if (!player2.bathtubWaterLevel) player2.bathtubWaterLevel = 0;
                        player2.bathtubWaterLevel = Math.min(1, player2.bathtubWaterLevel + 0.34);
                        player2.interiorAction = 'none';
                    } else if (player2.interiorAction !== 'sleeping' && player2.interiorAction !== 'couch_rest') {
                        // No catNeeds updates for P2
                        player2.interiorAction = 'none';
                    }
                }
                return;
            }

            // WASD movement
            const speed = 4;
            let moving = false;
            if (keys['a'] || keys['A']) {
                player2.interiorX -= speed;
                player2.facingRight = false;
                moving = true;
            }
            if (keys['d'] || keys['D']) {
                player2.interiorX += speed;
                player2.facingRight = true;
                moving = true;
            }

            if (moving) {
                player2.walkCycle += 0.2;
            }

            // Clamp to room bounds
            player2.interiorX = Math.max(30, Math.min(canvas.width - 30, player2.interiorX));
            player2.interiorY = floorY - 20;

            // Sync friend position
            friend.x = player2.interiorX;
            friend.y = player2.interiorY;
        }

        function handleP2ActionPress() {
            if (!player2.active || gameState !== 'interior') return;

            const px = player2.interiorX;
            const floorY = canvas.height - 180;

            // Wake up from sleep
            if (player2.interiorAction === 'sleeping') {
                player2.interiorAction = 'none';
                return;
            }
            if (player2.interiorAction === 'couch_rest') {
                player2.interiorAction = 'none';
                return;
            }
            if (player2.interiorAction === 'bathing') {
                player2.bathFoam = !player2.bathFoam;
                return;
            }
            if (player2.interiorAction !== 'none') return;

            // Talk to other friends (not self)
            for (const friend of interiorFriends) {
                if (friend.type.emoji === p2ControlledFriendEmoji) continue;
                if (Math.abs(px - friend.x) < 50 && friend.activity === 'walking') {
                    startAnimalConversation(friend);
                    return;
                }
            }

            // Bed
            const bedX = 30;
            const bedW = 120;
            if (px > bedX - 20 && px < bedX + bedW + 20) {
                player2.interiorAction = 'sleeping';
                player2.interiorActionTimer = -1;
                return;
            }
            // TV
            const tvX = 80;
            const tvW = 220;
            if (px > bedX + bedW + 20 && px < tvX + tvW + 30) {
                tvChannel = (tvChannel + 1) % 7;
                return;
            }
            // Couch
            const couchX = 340;
            const couchW = 120;
            if (px > couchX - 20 && px < couchX + couchW + 20) {
                player2.interiorAction = 'couch_rest';
                player2.interiorActionTimer = -1;
                return;
            }
            // Toilet
            const toiletX = 700;
            if (Math.abs(px - toiletX) < 40) {
                player2.interiorAction = 'toilet';
                player2.interiorActionTimer = 120;
                return;
            }
            // Sink
            const sinkX = 780;
            if (Math.abs(px - sinkX) < 30) {
                player2.interiorAction = 'washing';
                player2.interiorActionTimer = 90;
                return;
            }
            // Bathtub
            const bathtubX = 870;
            if (Math.abs(px - bathtubX) < 50) {
                if (player2.bathtubWaterLevel >= 0.8) {
                    player2.interiorAction = 'bathing';
                    player2.interiorActionTimer = -1;
                    player2.bathFoam = false;
                    return;
                } else if (player2.bathtubWaterLevel > 0) {
                    player2.interiorAction = 'draining_water';
                    return;
                } else {
                    player2.interiorAction = 'filling_water';
                    player2.interiorActionTimer = 30;
                    return;
                }
            }
            // Food bowls
            const bowlX = 510;
            if (Math.abs(px - bowlX) < 60) {
                player2.interiorAction = 'eating';
                player2.interiorActionTimer = 120;
                return;
            }
            // Ball
            const ballX = 1020;
            if (Math.abs(px - ballX) < 50) {
                player2.interiorAction = 'playing';
                player2.interiorActionTimer = 90;
                return;
            }
        }

        // ========== CONVERSATION SYSTEM ==========

        const animalDialogs = {
            'üê∂': {
                name: 'Piesek',
                lines: [
                    ['Hau hau! Cze≈õƒá!', 'Cze≈õƒá Piesku!'],
                    ['Chcesz siƒô pobawiƒá?', 'Jasne!'],
                    ['Lubiƒô biegaƒá po ≈ÇƒÖce!', 'Ja te≈º!'],
                    ['Masz co≈õ do jedzenia?', 'Sprawd≈∫ miskƒô!'],
                    ['Jeste≈õ moim najlepszym przyjacielem!', 'Ty te≈º!']
                ]
            },
            'üê∞': {
                name: 'Kr√≥liczek',
                lines: [
                    ['*rusza noskiem* Cze≈õƒá!', 'Hej Kr√≥liczku!'],
                    ['Masz marchewkƒô?', 'Niestety nie...'],
                    ['Lubiƒô skakaƒá!', 'Widzƒô!'],
                    ['Moje uszka s≈ÇyszƒÖ wszystko!', 'Super moc!'],
                    ['Chcƒô siƒô przytuliƒá!', 'Chod≈∫ tutaj!']
                ]
            },
            'üêª': {
                name: 'Mi≈õ',
                lines: [
                    ['Mrrrr, cze≈õƒá!', 'Hej Misiu!'],
                    ['Lubiƒô mi√≥d!', 'Ja te≈º!'],
                    ['Czy jest pora na drzemkƒô?', 'Kanapa czeka!'],
                    ['Jestem silny!', 'Najsilniejszy!'],
                    ['Przytulisz mnie?', 'Oczywi≈õcie!']
                ]
            },
            'üêë': {
                name: 'Owieczka',
                lines: [
                    ['Beee! Dzie≈Ñ dobry!', 'Cze≈õƒá Owieczko!'],
                    ['Moja we≈Çna jest miƒôkka!', 'Mogƒô dotknƒÖƒá?'],
                    ['Lubiƒô trawkƒô!', 'Smaczna?'],
                    ['Policzysz mnie do snu?', 'Raz, dwa, trzy...'],
                    ['Beee beee!', 'Beee!']
                ]
            },
            'üê¨': {
                name: 'Delfinek',
                lines: [
                    ['*klik klik* Cze≈õƒá!', 'Hej Delfinku!'],
                    ['Tƒôskniƒô za morzem...', 'Wanna jest blisko!'],
                    ['Umiem robiƒá salta!', 'Poka≈º!'],
                    ['Klik klik klik!', 'Co m√≥wisz?'],
                    ['Lubiƒô p≈Çywaƒá!', 'Ja te≈º!']
                ]
            },
            'ü¶ä': {
                name: 'Lisek',
                lines: [
                    ['Hej hej!', 'Cze≈õƒá Lisku!'],
                    ['Jestem bardzo sprytny!', 'Wiem!'],
                    ['M√≥j ogon jest puszysty!', 'Piƒôkny!'],
                    ['Lubiƒô siƒô chowaƒá!', 'Znajdƒô ciƒô!'],
                    ['Znalaz≈Çem co≈õ ciekawego!', 'Co?!']
                ]
            },
            'üêº': {
                name: 'Panda',
                lines: [
                    ['*je bambusa* Cze≈õƒá!', 'Hej Pando!'],
                    ['Lubiƒô bambusa!', 'Smacznego!'],
                    ['Jestem czarno-bia≈Ça!', 'I piƒôkna!'],
                    ['*przewraca siƒô* Ups!', 'Haha!'],
                    ['Chcƒô siƒô przytuliƒá!', 'Chod≈∫!']
                ]
            },
            'ü¶Ñ': {
                name: 'Jednoro≈ºec',
                lines: [
                    ['‚ú® Witaj!', 'Hej!'],
                    ['M√≥j r√≥g ≈õwieci!', 'Piƒôknie!'],
                    ['Lubiƒô tƒôcze!', 'Ja te≈º!'],
                    ['Jestem magiczny!', 'Wierzƒô!'],
                    ['*posypuje brokatem*', 'B≈Çyszczy!']
                ]
            },
            'üê∏': {
                name: '≈ªabka',
                lines: [
                    ['Kum kum!', 'Cze≈õƒá ≈ªabko!'],
                    ['Lubiƒô deszcz!', 'Ja nie za bardzo...'],
                    ['Z≈Çapiƒô muchƒô!', 'Szybka jeste≈õ!'],
                    ['Kum kum kum!', 'Kum!'],
                    ['Chcesz skoczyƒá ze mnƒÖ?', 'Jasne!']
                ]
            },
            'ü¶ã': {
                name: 'Motyl',
                lines: [
                    ['*trzepocze skrzyd≈Çami*', 'Piƒôkne!'],
                    ['Lubiƒô kwiaty!', 'Ja te≈º!'],
                    ['Moje skrzyd≈Ça majƒÖ wzory!', 'Cudowne!'],
                    ['Frrr frrr!', 'Lataj dalej!'],
                    ['UsiƒÖdƒô ci na nosie!', 'Haha ≈Çaskocze!']
                ]
            }
        };

        function startAnimalConversation(friend) {
            const emoji = friend.type.emoji || friend.type;
            const dialogSet = animalDialogs[emoji] || animalDialogs['üê∂'];
            const randomLine = dialogSet.lines[Math.floor(Math.random() * dialogSet.lines.length)];

            activeConversation = {
                friend: friend,
                friendName: dialogSet.name,
                friendLine: randomLine[0],
                playerLine: randomLine[1],
                phase: 'friend_talking', // friend_talking -> player_talking -> done
                timer: 150, // ~2.5 seconds for friend to speak
                friendX: friend.x,
                friendY: friend.y
            };

            // Stop friend from moving during conversation
            friend.activity = 'talking';
            friend.activityTimer = 500; // Long enough for full conversation
        }

        function updateConversation() {
            if (!activeConversation) return;

            activeConversation.timer--;

            if (activeConversation.timer <= 0) {
                if (activeConversation.phase === 'friend_talking') {
                    activeConversation.phase = 'player_talking';
                    activeConversation.timer = 150; // ~2.5 seconds for player response
                } else if (activeConversation.phase === 'player_talking') {
                    activeConversation.phase = 'done';
                    activeConversation.timer = 60; // hearts floating
                } else {
                    // Conversation over
                    if (activeConversation.friend) {
                        activeConversation.friend.activity = 'walking';
                        activeConversation.friend.activityTimer = 100 + Math.floor(Math.random() * 100);
                        activeConversation.friend.velX = (Math.random() > 0.5 ? 1 : -1) * (1 + Math.random());
                    }
                    activeConversation = null;
                }
            }
        }

        function drawConversation() {
            if (!activeConversation) return;

            const conv = activeConversation;
            // Use LIVE positions from friend and player, not stored ones
            const friend = conv.friend;
            const fx = friend ? friend.x : conv.friendX;
            const fy = friend ? friend.y : conv.friendY;
            const px = interiorPlayer.x;
            const py = interiorPlayer.y;

            ctx.save();

            if (conv.phase === 'friend_talking' || conv.phase === 'player_talking') {
                // Always show the friend's bubble in both phases
                const friendText = conv.friendLine;
                ctx.font = 'bold 13px Comic Sans MS';
                const ftw = ctx.measureText(friendText).width + 24;
                const fbx = fx - ftw / 2;
                // Offset friend bubble higher if player bubble also showing
                const friendBubbleY = conv.phase === 'player_talking' ? fy - 75 : fy - 65;

                // Friend bubble
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.beginPath();
                ctx.roundRect(fbx, friendBubbleY, ftw, 30, 8);
                ctx.fill();
                ctx.strokeStyle = '#FF85A2';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(fbx, friendBubbleY, ftw, 30, 8);
                ctx.stroke();

                // Tail pointing to friend
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.beginPath();
                ctx.moveTo(fx - 5, friendBubbleY + 30);
                ctx.lineTo(fx, friendBubbleY + 40);
                ctx.lineTo(fx + 5, friendBubbleY + 30);
                ctx.fill();
                ctx.strokeStyle = '#FF85A2';
                ctx.beginPath();
                ctx.moveTo(fx - 5, friendBubbleY + 30);
                ctx.lineTo(fx, friendBubbleY + 40);
                ctx.lineTo(fx + 5, friendBubbleY + 30);
                ctx.stroke();

                // Friend text
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.fillText(friendText, fx, friendBubbleY + 20);

                // Friend name label
                ctx.font = 'bold 10px Comic Sans MS';
                ctx.fillStyle = '#FF85A2';
                ctx.fillText(conv.friendName, fx, friendBubbleY - 3);

                // Player speech bubble (only in player_talking phase)
                if (conv.phase === 'player_talking') {
                    const playerText = conv.playerLine;
                    ctx.font = 'bold 13px Comic Sans MS';
                    const ptw = ctx.measureText(playerText).width + 24;
                    const pbx = px - ptw / 2;
                    const playerBubbleY = py - 65;

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    ctx.beginPath();
                    ctx.roundRect(pbx, playerBubbleY, ptw, 30, 8);
                    ctx.fill();
                    ctx.strokeStyle = '#85A2FF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.roundRect(pbx, playerBubbleY, ptw, 30, 8);
                    ctx.stroke();

                    // Tail pointing to player
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    ctx.beginPath();
                    ctx.moveTo(px - 5, playerBubbleY + 30);
                    ctx.lineTo(px, playerBubbleY + 40);
                    ctx.lineTo(px + 5, playerBubbleY + 30);
                    ctx.fill();
                    ctx.strokeStyle = '#85A2FF';
                    ctx.beginPath();
                    ctx.moveTo(px - 5, playerBubbleY + 30);
                    ctx.lineTo(px, playerBubbleY + 40);
                    ctx.lineTo(px + 5, playerBubbleY + 30);
                    ctx.stroke();

                    ctx.fillStyle = '#333';
                    ctx.textAlign = 'center';
                    ctx.fillText(playerText, px, playerBubbleY + 20);

                    ctx.font = 'bold 10px Comic Sans MS';
                    ctx.fillStyle = '#85A2FF';
                    ctx.fillText('Kicioro≈ºek', px, playerBubbleY - 3);
                }
            } else if (conv.phase === 'done') {
                // Hearts floating up between both characters
                const midX = (fx + px) / 2;
                const midY = Math.min(fy, py);
                const t = (60 - conv.timer) / 60;
                for (let h = 0; h < 3; h++) {
                    const hx = midX + Math.sin(t * 5 + h * 2) * 20;
                    const hy = midY - 40 - t * 40 - h * 15;
                    ctx.globalAlpha = Math.max(0, 1 - t);
                    ctx.font = `${14 + h * 2}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText('‚ù§Ô∏è', hx, hy);
                }
                ctx.globalAlpha = 1;
            }

            ctx.restore();
        }

        // ========== INTERIOR PLAYER SYSTEM ==========

        function updateInteriorPlayer(floorY, bedX, bedW, toiletX, sinkX, bathtubX) {
            // Smoothly transition light level based on sleeping state
            if (interiorPlayer.action === 'sleeping') {
                interiorLightLevel = Math.max(0.15, interiorLightLevel - 0.015);
            } else {
                interiorLightLevel = Math.min(1.0, interiorLightLevel + 0.02);
            }

            // Needs are updated based on steps walked (see world update + interior movement)

            // Drain bathtub water when draining action is active
            if (interiorPlayer.action === 'draining_water' && interiorPlayer.bathtubWaterLevel > 0) {
                interiorPlayer.bathtubWaterLevel = Math.max(0, interiorPlayer.bathtubWaterLevel - 0.012);
                if (interiorPlayer.bathtubWaterLevel <= 0) {
                    interiorPlayer.action = 'none';
                }
            }

            // If performing an action, count down the timer
            if (interiorPlayer.action !== 'none') {
                // Bathing: exit with arrow keys
                if (interiorPlayer.action === 'bathing') {
                    if (keys['ArrowLeft'] || keys['ArrowRight']) {
                        catNeeds.hygiene = 0;
                        interiorPlayer.bathFoam = false;
                        interiorPlayer.action = 'none';
                        interiorPlayer.bathDone = true; // Mark bath done so next space drains
                    }
                    return;
                }

                // Draining: don't move while draining
                if (interiorPlayer.action === 'draining_water') return;

                interiorPlayer.actionTimer--;
                if (interiorPlayer.actionTimer <= 0) {
                    if (interiorPlayer.action === 'filling_water') {
                        // Finished filling - increase water level
                        if (!interiorPlayer.bathtubWaterLevel) interiorPlayer.bathtubWaterLevel = 0;
                        interiorPlayer.bathtubWaterLevel = Math.min(1, interiorPlayer.bathtubWaterLevel + 0.34);
                        interiorPlayer.action = 'none';
                    } else if (interiorPlayer.action !== 'sleeping' && interiorPlayer.action !== 'couch_rest') {
                        // Satisfy the corresponding need when action finishes
                        if (interiorPlayer.action === 'eating') catNeeds.hunger = 0;
                        if (interiorPlayer.action === 'toilet') catNeeds.toilet = 0;
                        if (interiorPlayer.action === 'washing') catNeeds.hygiene = Math.max(0, catNeeds.hygiene - 50);
                        interiorPlayer.action = 'none';
                    }
                }
                return; // Don't move while doing an action
            }

            // Movement with arrow keys / A,D
            const speed = 4;
            let interiorMoving = false;
            if (keys['ArrowLeft']) {
                interiorPlayer.x -= speed;
                player.facingRight = false;
                interiorMoving = true;
            }
            if (keys['ArrowRight']) {
                interiorPlayer.x += speed;
                player.facingRight = true;
                interiorMoving = true;
            }

            // Animate walk cycle when moving + count steps
            if (interiorMoving) {
                player.walkCycle += 0.2;
                catStepCounter++;
                if (catStepCounter % 50 === 0) {
                    catNeeds.hunger = Math.min(100, catNeeds.hunger + 8);
                    catNeeds.sleep = Math.min(100, catNeeds.sleep + 5);
                    catNeeds.toilet = Math.min(100, catNeeds.toilet + 10);
                    catNeeds.hygiene = Math.min(100, catNeeds.hygiene + 6);
                }
            }

            // Clamp to room bounds
            interiorPlayer.x = Math.max(30, Math.min(canvas.width - 30, interiorPlayer.x));
            interiorPlayer.y = floorY - 20;
        }

        function drawInteriorPlayer(floorY, bedX, bedY, bedW, bedH) {
            ctx.save();

            if (interiorPlayer.action === 'sleeping') {
                // Draw player lying in bed
                const sleepX = bedX + 50;
                const sleepY = bedY + 10;

                // Draw player horizontally (rotated to left side)
                ctx.save();
                ctx.translate(sleepX, sleepY);
                ctx.rotate(-Math.PI / 2); // Lying on left side (facing down)
                ctx.scale(0.7, 0.7);
                drawPlayer(0, 0);
                ctx.restore();

                // Blanket covering player
                ctx.fillStyle = 'rgba(255, 133, 162, 0.6)';
                ctx.fillRect(bedX + 40, bedY + 15, bedW - 48, bedH - 22);

                // Zzz animation
                const zzzTime = interiorAnimationFrame * 0.03;
                for (let i = 0; i < 3; i++) {
                    const zOffset = ((zzzTime + i * 0.8) % 2.4);
                    const zAlpha = Math.max(0, 1 - zOffset / 2.4);
                    const zSize = 14 + i * 4 + zOffset * 8;
                    const zx = sleepX + 10 + zOffset * 15 + i * 8;
                    const zy = sleepY - 15 - zOffset * 25;

                    ctx.fillStyle = `rgba(100, 100, 200, ${zAlpha * 0.8})`;
                    ctx.font = `bold ${zSize}px Comic Sans MS`;
                    ctx.textAlign = 'center';
                    ctx.fillText('Z', zx, zy);
                }

            } else if (interiorPlayer.action === 'toilet') {
                // Draw player sitting on toilet
                const tx = interiorPlayer.x;
                const ty = interiorPlayer.y - 15;
                ctx.save();
                ctx.scale(0.8, 0.8);
                ctx.translate(tx * 0.25, ty * 0.25 + 5);
                drawPlayer(tx, ty);
                ctx.restore();

                // Reading newspaper
                ctx.fillStyle = '#F5F5DC';
                ctx.fillRect(tx + 15, ty + 5, 20, 25);
                ctx.strokeStyle = '#AAA';
                ctx.lineWidth = 1;
                ctx.strokeRect(tx + 15, ty + 5, 20, 25);
                // Newspaper lines
                ctx.strokeStyle = '#CCC';
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.moveTo(tx + 17, ty + 12 + i * 5);
                    ctx.lineTo(tx + 33, ty + 12 + i * 5);
                    ctx.stroke();
                }

                // Timer indicator
                if (interiorPlayer.actionTimer > 0) {
                    const prog = 1 - interiorPlayer.actionTimer / 120;
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.beginPath();
                    ctx.roundRect(tx - 25, ty - 35, 50, 18, 5);
                    ctx.fill();
                    // Progress bar
                    ctx.fillStyle = '#90EE90';
                    ctx.beginPath();
                    ctx.roundRect(tx - 22, ty - 32, 44 * prog, 12, 3);
                    ctx.fill();
                }

            } else if (interiorPlayer.action === 'washing') {
                // Draw player at sink
                const wx = interiorPlayer.x;
                const wy = interiorPlayer.y;
                drawPlayer(wx, wy);

                // Water splash particles
                for (let i = 0; i < 5; i++) {
                    const splashX = wx + 10 + Math.sin(interiorAnimationFrame * 0.2 + i * 1.5) * 10;
                    const splashY = wy - 10 - Math.abs(Math.sin(interiorAnimationFrame * 0.15 + i)) * 15;
                    ctx.fillStyle = `rgba(100, 180, 255, ${0.5 + Math.sin(interiorAnimationFrame * 0.1 + i) * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(splashX, splashY, 2 + Math.sin(interiorAnimationFrame * 0.1 + i) * 1, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Soap bubbles
                for (let i = 0; i < 4; i++) {
                    const bx = wx + Math.sin(interiorAnimationFrame * 0.04 + i * 2) * 20;
                    const by = wy - 20 - ((interiorAnimationFrame * 0.5 + i * 15) % 40);
                    const br = 3 + Math.sin(i) * 1.5;
                    ctx.strokeStyle = 'rgba(200, 220, 255, 0.6)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(bx, by, br, 0, Math.PI * 2);
                    ctx.stroke();
                    // Bubble highlight
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(bx - 1, by - 1, br * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Timer
                if (interiorPlayer.actionTimer > 0) {
                    const prog = 1 - interiorPlayer.actionTimer / 90;
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.beginPath();
                    ctx.roundRect(wx - 25, wy - 55, 50, 18, 5);
                    ctx.fill();
                    ctx.fillStyle = '#87CEEB';
                    ctx.beginPath();
                    ctx.roundRect(wx - 22, wy - 52, 44 * prog, 12, 3);
                    ctx.fill();
                }

            } else if (interiorPlayer.action === 'filling_water') {
                // Draw player at bathtub filling water
                const fx = interiorPlayer.x;
                const fy = interiorPlayer.y;
                drawPlayer(fx, fy);

                // Water stream from tap
                for (let i = 0; i < 8; i++) {
                    const streamX = fx - 20 + Math.sin(interiorAnimationFrame * 0.3 + i * 0.5) * 2;
                    const streamY = fy - 50 + i * 5;
                    ctx.fillStyle = `rgba(100, 180, 255, ${0.6 - i * 0.05})`;
                    ctx.beginPath();
                    ctx.arc(streamX, streamY, 3 - i * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Splash particles at water surface
                for (let i = 0; i < 5; i++) {
                    const splashX = fx + Math.sin(interiorAnimationFrame * 0.2 + i * 1.3) * 20;
                    const splashY = fy - 10 - Math.abs(Math.sin(interiorAnimationFrame * 0.25 + i)) * 8;
                    ctx.fillStyle = `rgba(100, 180, 255, ${0.5 + Math.sin(interiorAnimationFrame * 0.1 + i) * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(splashX, splashY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Progress indicator
                const waterProgress = 1 - interiorPlayer.actionTimer / 30;
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.beginPath();
                ctx.roundRect(fx - 30, fy - 70, 60, 18, 5);
                ctx.fill();
                ctx.fillStyle = '#87CEEB';
                ctx.beginPath();
                ctx.roundRect(fx - 27, fy - 67, 54 * waterProgress, 12, 3);
                ctx.fill();
                // Water drop icon
                ctx.font = '14px Arial';
                ctx.fillText('üíß', fx - 10, fy - 58);

            } else if (interiorPlayer.action === 'draining_water') {
                // Draw player near bathtub draining water
                const dx = interiorPlayer.x;
                const dy = interiorPlayer.y;
                drawPlayer(dx, dy);

                // Drain progress bar
                const drainProgress = 1 - (interiorPlayer.bathtubWaterLevel || 0);
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.beginPath();
                ctx.roundRect(dx - 30, dy - 70, 60, 18, 5);
                ctx.fill();
                ctx.fillStyle = '#87CEEB';
                ctx.beginPath();
                ctx.roundRect(dx - 27, dy - 67, 54 * drainProgress, 12, 3);
                ctx.fill();

                // Drain icon
                ctx.font = '12px Comic Sans MS';
                ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
                ctx.textAlign = 'center';
                ctx.fillText('Spuszczanie wody...', dx, dy - 78);

            } else if (interiorPlayer.action === 'bathing') {
                // Draw player in bathtub - upper half visible above water
                const floorY = canvas.height - 180;
                const bathtubH = 70;
                const bathtubW = 140;
                // Bathtub center: sinkX(780) + 140 = 920
                const tubCenterX = 920;
                const tubTopY = floorY - bathtubH; // Top rim of tub
                const waterSurfaceY = tubTopY + 18; // Water just below rim

                // Draw upper half of player clipped at water line
                // Player is placed inside the tub, centered
                const playerDrawX = tubCenterX - 30; // drawPlayer x (left edge of 60px wide player)
                const playerDrawY = waterSurfaceY - 45; // Position so head+torso show above water

                ctx.save();
                // Clip: show only above water line, no visible border
                ctx.beginPath();
                ctx.rect(tubCenterX - bathtubW / 2 + 5, tubTopY - 100, bathtubW - 10, waterSurfaceY - tubTopY + 100);
                ctx.clip();
                // Clear any stroke/fill that could outline the clip
                ctx.strokeStyle = 'transparent';
                ctx.lineWidth = 0;
                ctx.save();
                ctx.scale(0.7, 0.7);
                drawPlayer(playerDrawX / 0.7, playerDrawY / 0.7);
                ctx.restore();
                ctx.restore();

                // Water in tub (drawn over player's lower body)
                const waterAlpha = 0.45 + Math.sin(interiorAnimationFrame * 0.04) * 0.05;
                ctx.fillStyle = `rgba(100, 180, 255, ${waterAlpha})`;
                ctx.beginPath();
                // Wavy water surface
                ctx.moveTo(tubCenterX - bathtubW / 2 + 12, waterSurfaceY);
                for (let wx = 0; wx <= bathtubW - 24; wx += 8) {
                    const waveY = waterSurfaceY + Math.sin(interiorAnimationFrame * 0.08 + wx * 0.1) * 2;
                    ctx.lineTo(tubCenterX - bathtubW / 2 + 12 + wx, waveY);
                }
                ctx.lineTo(tubCenterX + bathtubW / 2 - 12, floorY - 15);
                ctx.lineTo(tubCenterX - bathtubW / 2 + 12, floorY - 15);
                ctx.closePath();
                ctx.fill();

                // Water surface highlights
                ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
                for (let i = 0; i < 3; i++) {
                    const hlX = tubCenterX - 25 + i * 25 + Math.sin(interiorAnimationFrame * 0.06 + i) * 5;
                    ctx.beginPath();
                    ctx.ellipse(hlX, waterSurfaceY + 2, 12, 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Foam on head (toggled with SPACE)
                if (interiorPlayer.bathFoam) {
                    const foamColors = ['#FFFFFF', '#F0F8FF', '#FFFAFA', '#F5F5F5'];
                    const headX = tubCenterX + 5;
                    const headY = waterSurfaceY - 40;

                    // Large foam bubbles cluster
                    for (let i = 0; i < 7; i++) {
                        const angle = (i / 7) * Math.PI * 2;
                        const dist = 8 + (i % 3) * 4;
                        const fx = headX + Math.cos(angle + interiorAnimationFrame * 0.02) * dist;
                        const fy = headY - 10 + Math.sin(angle) * dist * 0.6;
                        const fr = 6 + Math.sin(i * 1.5) * 3;
                        ctx.fillStyle = foamColors[i % foamColors.length];
                        ctx.beginPath();
                        ctx.arc(fx, fy, fr, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.beginPath();
                        ctx.arc(fx - 2, fy - 2, fr * 0.35, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(headX, headY - 12, 9, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(200, 230, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(headX - 3, headY - 15, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Floating foam bubbles
                    for (let i = 0; i < 4; i++) {
                        const fbx = headX + Math.sin(interiorAnimationFrame * 0.04 + i * 1.5) * 20;
                        const fby = headY - 25 - ((interiorAnimationFrame * 0.4 + i * 15) % 35);
                        const fbr = 2.5 + Math.sin(i) * 1;
                        ctx.strokeStyle = 'rgba(200, 220, 255, 0.5)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(fbx, fby, fbr, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                // Happy emoji
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(interiorPlayer.bathFoam ? 'üßº' : 'üòä', tubCenterX + 35, waterSurfaceY - 35 + Math.sin(interiorAnimationFrame * 0.1) * 3);

                // Hint to press SPACE
                ctx.font = '12px Comic Sans MS';
                ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
                ctx.fillText('SPACJA - piana / strza≈Çki - wyjd≈∫', tubCenterX, floorY + 15);

            } else if (interiorPlayer.action === 'eating') {
                // Draw player eating at food bowls with food-to-mouth animation
                const px = interiorPlayer.x;
                const py = interiorPlayer.y;
                drawPlayer(px, py);

                // Animated food piece going from bowl to mouth
                const eatCycle = (interiorAnimationFrame % 40) / 40; // 0-1 cycle
                const bowlY = py + 10; // bowl level
                const mouthY = py - 15; // mouth level
                const mouthX = px + 5;

                // Food piece arc from bowl to mouth
                const foodX = px + 10 - eatCycle * 5;
                const foodY = bowlY + (mouthY - bowlY) * eatCycle - Math.sin(eatCycle * Math.PI) * 15;
                const foodAlpha = eatCycle < 0.9 ? 1 : (1 - (eatCycle - 0.9) / 0.1);

                // Draw the food morsel
                ctx.globalAlpha = foodAlpha;
                const foodColors = ['#8B4513', '#FF6347', '#FFD700', '#32CD32'];
                const foodColor = foodColors[Math.floor(interiorAnimationFrame / 40) % foodColors.length];
                ctx.fillStyle = foodColor;
                ctx.beginPath();
                ctx.arc(foodX, foodY, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                // Open mouth when food arrives
                if (eatCycle > 0.7 && eatCycle < 0.95) {
                    ctx.fillStyle = '#FF6B6B';
                    ctx.beginPath();
                    ctx.arc(mouthX, mouthY, 4, 0, Math.PI);
                    ctx.fill();
                }

                // Chewing cheeks puff
                if (eatCycle > 0.9 || eatCycle < 0.15) {
                    const chewPuff = Math.sin(interiorAnimationFrame * 0.5) * 2;
                    ctx.fillStyle = 'rgba(255, 180, 180, 0.4)';
                    ctx.beginPath();
                    ctx.arc(mouthX - 8, mouthY + 2, 4 + chewPuff, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(mouthX + 8, mouthY + 2, 4 - chewPuff, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Small crumbs falling
                for (let i = 0; i < 2; i++) {
                    const crumbPhase = ((interiorAnimationFrame * 0.06 + i * 0.5) % 1);
                    if (crumbPhase < 0.6) {
                        const cx = mouthX - 3 + i * 6 + Math.sin(interiorAnimationFrame * 0.1 + i) * 3;
                        const cy = mouthY + 3 + crumbPhase * 25;
                        ctx.fillStyle = `rgba(139, 69, 19, ${0.6 * (1 - crumbPhase / 0.6)})`;
                        ctx.beginPath();
                        ctx.arc(cx, cy, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

            } else if (interiorPlayer.action === 'playing') {
                // Draw player playing with ball
                const px = interiorPlayer.x;
                const py = interiorPlayer.y;

                // Player jumping
                const jumpY = py + Math.sin(interiorAnimationFrame * 0.2) * 8;
                drawPlayer(px, jumpY);

                // Ball being tossed up and down
                const ballThrowY = py - 40 - Math.abs(Math.sin(interiorAnimationFrame * 0.15)) * 30;
                const ballThrowX = px + Math.sin(interiorAnimationFrame * 0.15) * 15;

                ctx.fillStyle = '#FF4444';
                ctx.beginPath();
                ctx.arc(ballThrowX, ballThrowY, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFFF44';
                ctx.fillRect(ballThrowX - 12, ballThrowY - 2, 24, 4);

                // Happy emoji
                ctx.font = '18px Arial';
                ctx.fillText('üòÑ', px - 25, py - 25);

            } else if (interiorPlayer.action === 'couch_rest') {
                // Draw player lying on couch
                const couchX = 340;
                const couchY = floorY;
                const couchW = 120;

                ctx.save();
                ctx.translate(couchX + couchW / 2, couchY - 30);
                ctx.rotate(-Math.PI / 2);
                ctx.scale(0.65, 0.65);
                drawPlayer(0, 0);
                ctx.restore();

                // Blanket
                ctx.fillStyle = 'rgba(245, 176, 65, 0.4)';
                ctx.fillRect(couchX + 20, couchY - 35, couchW - 40, 20);

                // Zzz animation (slower, lighter - resting not sleeping)
                const restTime = interiorAnimationFrame * 0.02;
                for (let i = 0; i < 2; i++) {
                    const zOff = ((restTime + i * 1.0) % 2.0);
                    const zAlpha = Math.max(0, 1 - zOff / 2.0);
                    const zSize = 12 + i * 3 + zOff * 6;
                    const zx = couchX + couchW / 2 + 15 + zOff * 12 + i * 6;
                    const zy = couchY - 45 - zOff * 20;
                    ctx.fillStyle = `rgba(100, 150, 200, ${zAlpha * 0.6})`;
                    ctx.font = `bold ${zSize}px Comic Sans MS`;
                    ctx.textAlign = 'center';
                    ctx.fillText('z', zx, zy);
                }

                // Hint
                ctx.font = '12px Comic Sans MS';
                ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
                ctx.textAlign = 'center';
                ctx.fillText('SPACJA - wsta≈Ñ', couchX + couchW / 2, floorY + 15);

            } else {
                // Normal standing - draw player at current position
                drawPlayer(interiorPlayer.x, interiorPlayer.y);
            }

            ctx.restore();
        }

        function drawInteriorHints(bedX, bedW, toiletX, sinkX, bathtubX, floorY) {
            if (interiorPlayer.action !== 'none') return;

            const px = interiorPlayer.x;
            ctx.textAlign = 'center';

            // Near bed?
            if (px > bedX - 20 && px < bedX + bedW + 20) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(bedX + bedW / 2 - 55, floorY - 85, 110, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#9370DB';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(bedX + bedW / 2 - 55, floorY - 85, 110, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#6A5ACD';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - ≈öpij üí§', bedX + bedW / 2, floorY - 67);
            }

            // Near TV (right of bed area)?
            const tvZoneX = 190; // Center of TV interaction zone
            if (px > bedX + bedW + 20 && px < 340) {
                const channelNames = ['Bajka', 'Wiadomo≈õci', 'Sport', 'Moda', 'Wy≈õcigi', 'Klaun', 'Muzyka'];
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(tvZoneX - 75, floorY - 85, 150, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(tvZoneX - 75, floorY - 85, 150, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#E53935';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - ' + channelNames[tvChannel] + ' üì∫', tvZoneX, floorY - 67);
            }

            // Near couch?
            const couchX = 340;
            const couchW = 120;
            if (px > couchX - 20 && px < couchX + couchW + 20) {
                const couchCenterX = couchX + couchW / 2;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(couchCenterX - 70, floorY - 85, 140, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#C0392B';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(couchCenterX - 70, floorY - 85, 140, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#C0392B';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - Po≈Ç√≥≈º siƒô üõãÔ∏è', couchCenterX, floorY - 67);
            }

            // Near toilet?
            if (Math.abs(px - toiletX) < 40) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(toiletX - 60, floorY - 85, 120, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#4169E1';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(toiletX - 60, floorY - 85, 120, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#4169E1';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - Toaleta üöΩ', toiletX, floorY - 67);
            }

            // Near sink?
            if (Math.abs(px - sinkX) < 40) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(sinkX - 65, floorY - 85, 130, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#4169E1';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(sinkX - 65, floorY - 85, 130, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#4169E1';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - Umyj rƒôce üßº', sinkX, floorY - 67);
            }

            // Near bathtub?
            if (Math.abs(px - bathtubX) < 70) {
                const waterLevel = interiorPlayer.bathtubWaterLevel || 0;
                const hintText = interiorPlayer.bathDone && waterLevel > 0 ? 'SPACJA - Spu≈õƒá wodƒô üîΩ' : waterLevel >= 1 ? 'SPACJA - KƒÖpiel üõÅ' : waterLevel > 0 ? 'SPACJA - Napu≈õƒá wiƒôcej üíß' : 'SPACJA - Napu≈õƒá wodƒô üíß';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(bathtubX - 75, floorY - 85, 150, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#87CEEB';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(bathtubX - 75, floorY - 85, 150, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#87CEEB';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText(hintText, bathtubX, floorY - 67);
            }

            // Near food bowls?
            const bowlX = 510;
            if (Math.abs(px - bowlX) < 60) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(bowlX - 55, floorY - 85, 110, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(bowlX - 55, floorY - 85, 110, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#FF6B6B';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - Jedz üçΩÔ∏è', bowlX, floorY - 67);
            }

            // Near camera?
            const camHintX = 620;
            if (Math.abs(px - camHintX) < 40) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(camHintX - 75, floorY - 85, 150, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(camHintX - 75, floorY - 85, 150, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#555';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - Zr√≥b zdjƒôcie üì∏', camHintX, floorY - 67);
            }

            // Near ball?
            const ballX = 1020;
            if (Math.abs(px - ballX) < 50) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(ballX - 65, floorY - 85, 130, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#FF4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(ballX - 65, floorY - 85, 130, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#FF4444';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - Podrzuƒá üéæ', ballX, floorY - 67);
            }

            // Near exit door?
            const doorX = canvas.width - 350;
            if (px > doorX - 50) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(doorX - 30, floorY - 85, 110, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#8B6238';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(doorX - 30, floorY - 85, 110, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#8B6238';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - Wyjd≈∫ üö™', doorX + 25, floorY - 67);
            }

            // Near a walking friend?
            if (!activeConversation) {
                for (const friend of interiorFriends) {
                    if (Math.abs(px - friend.x) < 50 && friend.activity === 'walking') {
                        const emoji = friend.type.emoji || friend.type;
                        const name = (animalDialogs[emoji] || {}).name || 'ZwierzƒÖtko';
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.beginPath();
                        ctx.roundRect(friend.x - 70, friend.y - 55, 140, 26, 8);
                        ctx.fill();
                        ctx.strokeStyle = '#FF85A2';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.roundRect(friend.x - 70, friend.y - 55, 140, 26, 8);
                        ctx.stroke();
                        ctx.fillStyle = '#FF85A2';
                        ctx.font = 'bold 13px Comic Sans MS';
                        ctx.fillText(`SPACJA - Pogadaj z ${name}`, friend.x, friend.y - 37);
                        break; // Only show hint for nearest friend
                    }
                }
            }
        }

        // ========== HYCEL SYSTEM ==========

        // Helper function to draw a single Hycel (zwierzak 2x wiƒôkszy)
        function drawSingleHycel(x, y, hycel, animFrame) {
            ctx.save();

            // Scale 2x
            const scale = 2;

            // Get the friend type emoji
            const friendEmoji = hycel.friendType ? hycel.friendType.emoji : 'üê∂';

            // Map emoji to draw function
            const drawFunctions = {
                'üê∂': drawDog,
                'üê∞': drawRabbit,
                'üêª': drawBear,
                'üêë': drawSheep,
                'üê¨': drawDolphin,
                'ü¶ä': drawFox,
                'üêº': drawPanda,
                'ü¶Ñ': drawUnicorn,
                'üê∏': drawFrog,
                'ü¶ã': drawButterfly
            };

            const drawFunction = drawFunctions[friendEmoji] || drawDog;

            // Draw the animal 2x bigger
            drawFunction(x, y, scale);

            // Draw net in hycel's paw/hand
            if (!hycel.defeated) {
                // Position at the right paw of the animal (body center + paw offset, scaled)
                const netX = x + 12 * scale;
                const netY = y + 45 * scale;
                const netR = 10 * scale;
                const swing = Math.sin((animFrame || 0) * 0.05) * 0.15;

                ctx.save();
                ctx.translate(netX, netY);
                ctx.rotate(swing - 0.3); // Tilted slightly as if held

                // Handle/stick (going up from paw into the net)
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2.5 * scale;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -netR * 2.2);
                ctx.stroke();

                // Net ring at the top of the stick
                const ringY = -netR * 2.2;
                ctx.strokeStyle = '#8B6914';
                ctx.lineWidth = 2 * scale;
                ctx.beginPath();
                ctx.arc(0, ringY, netR, 0, Math.PI * 2);
                ctx.stroke();

                // Radial ropes from center
                ctx.lineWidth = 0.8 * scale;
                ctx.strokeStyle = '#A0822A';
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(0, ringY);
                    ctx.lineTo(Math.cos(angle) * netR, ringY + Math.sin(angle) * netR);
                    ctx.stroke();
                }

                // Concentric mesh rings
                ctx.lineWidth = 0.6 * scale;
                for (let r = 1; r <= 2; r++) {
                    ctx.beginPath();
                    ctx.arc(0, ringY, netR * r * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Semi-transparent net fill
                ctx.fillStyle = 'rgba(139, 105, 20, 0.1)';
                ctx.beginPath();
                ctx.arc(0, ringY, netR, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            ctx.restore();
        }

        function drawHycels() {
            hycels.forEach(hycel => {
                const screenX = hycel.x - worldOffset;
                const screenY = hycel.y;

                if (screenX < -100 || screenX > canvas.width + 100) return;

                // Animacja przewracania siƒô po pokonaniu
                if (hycel.defeated) {
                    if (!hycel.fallAnimation) hycel.fallAnimation = 0;
                    hycel.fallAnimation++;

                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(Math.min(hycel.fallAnimation * 0.05, Math.PI / 2)); // Przewr√≥cenie
                    ctx.translate(-screenX, -screenY);
                    ctx.globalAlpha = Math.max(0, 1 - hycel.fallAnimation * 0.02);
                    drawSingleHycel(screenX, screenY, hycel, animationFrame);
                    ctx.restore();
                    return;
                }

                // Bouncing animation
                hycel.bounceOffset += 0.1;
                const bounce = Math.sin(hycel.bounceOffset) * 5;
                const drawY = screenY + bounce;

                // Draw the Hycel using helper function
                drawSingleHycel(screenX, drawY, hycel, animationFrame);

                // Health indicator (green hearts)
                ctx.save();
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                const hearts = 'üíö'.repeat(hycel.health);
                ctx.fillText(hearts, screenX, drawY - 80);
                ctx.restore();

                // Distance check
                const distance = Math.sqrt(
                    Math.pow(player.x - hycel.x, 2) +
                    Math.pow(player.y - hycel.y, 2)
                );

                if (distance < 150) {
                    // Attack prompt
                    ctx.fillStyle = 'rgba(255, 105, 180, 0.95)';
                    ctx.strokeStyle = '#FF1493';
                    ctx.lineWidth = 3;
                    ctx.fillRect(screenX - 100, drawY + 70, 200, 40);
                    ctx.strokeRect(screenX - 100, drawY + 70, 200, 40);

                    ctx.fillStyle = '#FF1493';
                    ctx.font = 'bold 18px Comic Sans MS';
                    ctx.textAlign = 'center';
                    ctx.fillText('SPACJA - Walcz!', screenX, drawY + 95);
                }
            });
        }

        // ========== BATTLE SYSTEM ==========
        function startBattle(hycel) {
            previousState = gameState;
            gameState = 'battle';
            currentBattle = hycel;

            battleState.playerHealth = 5;
            battleState.enemyHealth = hycel.health;
            battleState.playerAttackCooldown = 0;
            battleState.enemyAttackCooldown = 60;
            battleState.message = 'Walcz z Hycelem!';
            battleState.victory = false;
            battleState.defeat = false;
            battleState.attackAnimation = 0;
            battleState.hitAnimation = 0;
            battleState.victoryAnimationFrame = 0;
            battleState.defeatAnimationFrame = 0;

            // Play battle cry
            playAnimalSound('cat');
        }

        function updateBattle() {
            // Update cooldowns
            if (battleState.playerAttackCooldown > 0) {
                battleState.playerAttackCooldown--;
            }
            if (battleState.enemyAttackCooldown > 0) {
                battleState.enemyAttackCooldown--;
            }

            // Update animations
            if (battleState.attackAnimation > 0) {
                battleState.attackAnimation--;
            }
            if (battleState.hitAnimation > 0) {
                battleState.hitAnimation--;
            }

            // Check for player attack
            if (keys[' '] && battleState.playerAttackCooldown === 0 && !battleState.victory && !battleState.defeat) {
                playerAttack();
            }

            // Enemy auto-attack
            if (battleState.enemyAttackCooldown === 0 && !battleState.victory && !battleState.defeat) {
                enemyAttack();
                battleState.enemyAttackCooldown = 60; // 1 second
            }

            // Check victory
            if (battleState.enemyHealth <= 0 && !battleState.victory) {
                battleState.victory = true;
                battleState.message = 'üéâ ZWYCIƒòSTWO! üéâ';
                battleState.victoryAnimationFrame = 0;
            }

            // Check defeat
            if (battleState.playerHealth <= 0 && !battleState.defeat) {
                battleState.defeat = true;
                battleState.message = 'üíî Ojej! Spr√≥buj jeszcze raz! üíî';
                battleState.defeatAnimationFrame = 0;
            }

            // Victory animation counter - auto end after 150 frames (~2.5 seconds)
            if (battleState.victory) {
                battleState.victoryAnimationFrame++;
                if (battleState.victoryAnimationFrame >= 150) {
                    endBattle();
                }
            }

            // Defeat animation counter - auto retry after 90 frames (~1.5 seconds)
            if (battleState.defeat) {
                battleState.defeatAnimationFrame++;
                if (battleState.defeatAnimationFrame >= 90) {
                    endBattle();
                }
            }
        }

        function playerAttack() {
            battleState.enemyHealth--;
            battleState.playerAttackCooldown = 20; // ~0.33s
            battleState.attackAnimation = 10;

            const messages = [
                '≈öwietne uderzenie! üí™',
                'Tak trzymaj! üåü',
                'Super atak! ‚ö°',
                'Doskonale! üéØ',
                'Brawo! ü¶Ñ'
            ];
            battleState.message = messages[Math.floor(Math.random() * messages.length)];

            playAttackSound();
        }

        function enemyAttack() {
            battleState.playerHealth--;
            battleState.hitAnimation = 10;
            battleState.message = 'Hycel zaatakowa≈Ç! Odpieraj siƒô!';

            playHitSound();
        }

        function endBattle() {
            if (battleState.victory) {
                // Mark hycel as defeated
                currentBattle.defeated = true;
                gameState = 'world';

                dialogBubbles.push({
                    x: player.x,
                    y: player.y,
                    followTarget: player,
                    text: 'Pokona≈Çem Hycela! üéâ',
                    fromLeft: true,
                    startTime: Date.now(),
                    duration: 2500
                });
            } else if (battleState.defeat) {
                // Reset for retry
                battleState.playerHealth = 5;
                battleState.enemyHealth = currentBattle.health;
                battleState.playerAttackCooldown = 0;
                battleState.enemyAttackCooldown = 60;
                battleState.message = 'Spr√≥buj ponownie!';
                battleState.victory = false;
                battleState.defeat = false;
            }
        }

        function drawBattle() {
            updateBattle();

            // Rainbow gradient background
            const rainbowGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            rainbowGradient.addColorStop(0, '#FF0000');
            rainbowGradient.addColorStop(0.17, '#FF7F00');
            rainbowGradient.addColorStop(0.33, '#FFFF00');
            rainbowGradient.addColorStop(0.5, '#00FF00');
            rainbowGradient.addColorStop(0.67, '#0000FF');
            rainbowGradient.addColorStop(0.83, '#4B0082');
            rainbowGradient.addColorStop(1, '#9400D3');
            ctx.fillStyle = rainbowGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Sparkling stars effect
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 3;
                const alpha = Math.sin(animationFrame * 0.05 + i) * 0.5 + 0.5;

                ctx.save();
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Draw Kicioro≈ºek (left side) - using real graphics!
            const playerBaseX = canvas.width / 3 - 30;
            const playerBaseY = canvas.height / 2;
            const playerX = playerBaseX + (battleState.attackAnimation > 0 ? 30 : 0);
            const playerY = playerBaseY;

            ctx.save();
            if (battleState.hitAnimation > 0 && battleState.hitAnimation % 4 < 2) {
                ctx.globalAlpha = 0.5; // Flash when hit
            }

            // Make player face right for battle
            player.facingRight = true;

            // Draw player
            drawPlayer(playerX, playerY);

            // Attack animation - realistic rainbow beam from horn!
            if (battleState.attackAnimation > 0) {
                const attackProgress = battleState.attackAnimation / 10;

                // Rainbow beam from horn to enemy
                const hornX = playerX + 35;
                const hornY = playerY + 5;
                const targetX = (canvas.width * 2) / 3;
                const targetY = canvas.height / 2;
                const beamDist = Math.sqrt((targetX - hornX) ** 2 + (targetY - hornY) ** 2);

                ctx.save();
                ctx.globalAlpha = attackProgress;

                // Draw each rainbow color as a separate wavy band
                const rainbowColors = [
                    '#FF0000', '#FF4500', '#FF7F00', '#FFD700',
                    '#FFFF00', '#7FFF00', '#00FF00', '#00CED1',
                    '#0000FF', '#4B0082', '#9400D3'
                ];
                const bandWidth = 4;
                const totalWidth = rainbowColors.length * bandWidth;
                const waveAmplitude = 8 + (1 - attackProgress) * 12; // Wave gets stronger as beam extends
                const waveFreq = 0.04;
                const timeOffset = animationFrame * 0.3;

                // Calculate perpendicular direction for band offsets
                const dx = targetX - hornX;
                const dy = targetY - hornY;
                const len = Math.sqrt(dx * dx + dy * dy);
                const perpX = -dy / len;
                const perpY = dx / len;

                // Outer glow
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 30;

                rainbowColors.forEach((color, bandIdx) => {
                    const bandOffset = (bandIdx - rainbowColors.length / 2) * bandWidth;

                    ctx.strokeStyle = color;
                    ctx.lineWidth = bandWidth;
                    ctx.lineCap = 'round';
                    ctx.beginPath();

                    const steps = 40;
                    for (let i = 0; i <= steps; i++) {
                        const t = i / steps;
                        // Base position along the beam
                        const baseX = hornX + dx * t;
                        const baseY = hornY + dy * t;

                        // Sinusoidal wave perpendicular to beam direction
                        const wave = Math.sin(t * beamDist * waveFreq + timeOffset + bandIdx * 0.3) * waveAmplitude * t;

                        // Beam starts narrow at horn, expands toward target
                        const widthScale = 0.3 + t * 0.7;

                        const px = baseX + perpX * (bandOffset * widthScale + wave);
                        const py = baseY + perpY * (bandOffset * widthScale + wave);

                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                });

                ctx.shadowBlur = 0;

                // Bright core beam (white center)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let i = 0; i <= 40; i++) {
                    const t = i / 40;
                    const baseX = hornX + dx * t;
                    const baseY = hornY + dy * t;
                    const wave = Math.sin(t * beamDist * waveFreq + timeOffset) * waveAmplitude * t * 0.3;
                    const px = baseX + perpX * wave;
                    const py = baseY + perpY * wave;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();

                // Sparkles and stars along the beam
                for (let i = 0; i < 15; i++) {
                    const t = (i + Math.sin(animationFrame * 0.1 + i)) / 15;
                    const sparkX = hornX + dx * t + perpX * (Math.sin(animationFrame * 0.2 + i * 2) * 20);
                    const sparkY = hornY + dy * t + perpY * (Math.sin(animationFrame * 0.2 + i * 2) * 20);
                    const sparkSize = 2 + Math.sin(animationFrame * 0.3 + i) * 2;

                    // Star shape
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    for (let s = 0; s < 5; s++) {
                        const angle = (s / 5) * Math.PI * 2 - Math.PI / 2;
                        const outerR = sparkSize;
                        const innerR = sparkSize * 0.4;
                        ctx.lineTo(sparkX + Math.cos(angle) * outerR, sparkY + Math.sin(angle) * outerR);
                        const innerAngle = angle + Math.PI / 5;
                        ctx.lineTo(sparkX + Math.cos(innerAngle) * innerR, sparkY + Math.sin(innerAngle) * innerR);
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                // Impact burst at target
                if (attackProgress > 0.5) {
                    const burstSize = (1 - attackProgress) * 40;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2 + animationFrame * 0.1;
                        ctx.fillStyle = rainbowColors[i % rainbowColors.length];
                        ctx.globalAlpha = attackProgress * 0.7;
                        ctx.beginPath();
                        ctx.arc(
                            targetX + Math.cos(angle) * burstSize,
                            targetY + Math.sin(angle) * burstSize,
                            4, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }

                ctx.restore();
            }
            ctx.restore();

            // Draw Hycel (right side) - using real graphics!
            const enemyX = (canvas.width * 2) / 3;
            const enemyY = canvas.height / 2;

            // Scale up the Hycel for battle
            ctx.save();

            // Hycel falling animation on victory
            if (battleState.victory) {
                const fallProgress = Math.min(battleState.victoryAnimationFrame / 100, 1);

                ctx.translate(enemyX, enemyY);
                // Powolny obr√≥t (przewracanie siƒô)
                ctx.rotate(fallProgress * Math.PI / 2);
                // Opadanie w d√≥≈Ç
                ctx.translate(0, fallProgress * 100);
                // Zanikanie
                ctx.globalAlpha = Math.max(0, 1 - fallProgress * 0.8);
                ctx.translate(-enemyX, -enemyY);

                drawSingleHycel(enemyX, enemyY, currentBattle, animationFrame);
            } else {
                // Enemy attack animation - throwing realistic net!
                if (battleState.enemyAttackCooldown > 50 && battleState.enemyAttackCooldown <= 60 && !battleState.defeat) {
                    const throwProgress = (60 - battleState.enemyAttackCooldown) / 10;
                    const netX = enemyX - throwProgress * 200;
                    const netY = enemyY;
                    const netRadius = 45;
                    const rotation = throwProgress * Math.PI * 2; // Net spins as it flies

                    ctx.save();
                    ctx.translate(netX, netY);
                    ctx.rotate(rotation);

                    // Outer ring of the net (thick rope)
                    ctx.strokeStyle = '#8B6914';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, netRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Inner ring
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#A0822A';
                    ctx.beginPath();
                    ctx.arc(0, 0, netRadius * 0.6, 0, Math.PI * 2);
                    ctx.stroke();

                    // Radial ropes from center to outer ring (like a spider web)
                    ctx.strokeStyle = '#8B6914';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * netRadius, Math.sin(angle) * netRadius);
                        ctx.stroke();
                    }

                    // Concentric rope rings (mesh pattern)
                    ctx.lineWidth = 1.5;
                    ctx.strokeStyle = '#A0822A';
                    for (let r = 0; r < 3; r++) {
                        const ringRadius = netRadius * (0.25 + r * 0.2);
                        ctx.beginPath();
                        ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // Weighted knots on outer ring
                    ctx.fillStyle = '#654321';
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.arc(Math.cos(angle) * netRadius, Math.sin(angle) * netRadius, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Semi-transparent fill for net area
                    ctx.fillStyle = 'rgba(139, 105, 20, 0.15)';
                    ctx.beginPath();
                    ctx.arc(0, 0, netRadius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }

                drawSingleHycel(enemyX, enemyY, currentBattle, animationFrame);
            }
            ctx.restore();

            // Health bars at top
            drawHealthBar(50, 50, battleState.playerHealth, 5, '#00FF00', 'Kicioro≈ºek');
            drawHealthBar(canvas.width - 350, 50, battleState.enemyHealth, currentBattle.health, '#FF0000', 'Hycel');

            // Message box at bottom
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillRect(canvas.width / 2 - 250, canvas.height - 120, 500, 80);
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 5;
            ctx.strokeRect(canvas.width / 2 - 250, canvas.height - 120, 500, 80);

            ctx.fillStyle = '#FF1493';
            ctx.font = 'bold 20px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText(battleState.message, canvas.width / 2, canvas.height - 70);

            // Controls hint
            if (!battleState.victory && !battleState.defeat) {
                ctx.font = 'bold 18px Comic Sans MS';
                ctx.fillText('SPACJA - Atak! üó°Ô∏è', canvas.width / 2, canvas.height - 40);
            }

            // Victory overlay with friend approaching animation
            if (battleState.victory) {
                const victoryProgress = battleState.victoryAnimationFrame / 150;

                // Fade in green overlay
                ctx.fillStyle = `rgba(0, 255, 0, ${Math.min(0.3, victoryProgress * 0.5)})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Victory text
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 60px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('üéâ ZWYCIƒòSTWO! üéâ', canvas.width / 2, canvas.height / 2 - 50);

                ctx.font = 'bold 30px Comic Sans MS';
                ctx.fillText('Uratowa≈Çe≈õ przyjaciela!', canvas.width / 2, canvas.height / 2 + 20);

                // Friend approaching from right to player
                if (victoryProgress > 0.3) {
                    const friendProgress = Math.min((victoryProgress - 0.3) / 0.7, 1);
                    const friendX = enemyX - (enemyX - playerX - 80) * friendProgress;
                    const friendY = canvas.height / 2;

                    // Draw the rescued friend using real draw function
                    const friendType = currentBattle.friendType;
                    const drawFunctions = {
                        'üê∂': drawDog, 'üê∞': drawRabbit, 'üêª': drawBear, 'üêë': drawSheep,
                        'üê¨': drawDolphin, 'ü¶ä': drawFox, 'üêº': drawPanda, 'ü¶Ñ': drawUnicorn,
                        'üê∏': drawFrog, 'ü¶ã': drawButterfly
                    };
                    const drawFn = drawFunctions[friendType.emoji] || drawDog;
                    ctx.save();
                    drawFn(friendX, friendY, 1);
                    ctx.restore();
                }
            }

            // Defeat overlay
            if (battleState.defeat) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 60px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('üíî Ojej! üíî', canvas.width / 2, canvas.height / 2 - 50);

                ctx.font = 'bold 30px Comic Sans MS';
                ctx.fillText('Spr√≥buj jeszcze raz!', canvas.width / 2, canvas.height / 2 + 20);
            }
        }

        function drawHealthBar(x, y, current, max, color, label) {
            // Label
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 20px Comic Sans MS';
            ctx.textAlign = 'left';
            ctx.fillText(label, x, y - 10);

            // Bar background
            ctx.fillStyle = '#333';
            ctx.fillRect(x, y, 300, 30);

            // Bar foreground
            ctx.fillStyle = color;
            const width = (current / max) * 300;
            ctx.fillRect(x, y, width, 30);

            // Bar outline
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 3;
            ctx.strokeRect(x, y, 300, 30);

            // Health text
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 18px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText(`${current}/${max}`, x + 150, y + 22);
        }

        // Sound functions (UI sounds via Web Audio)
        function playAttackSound() {
            try {
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);
                gain.gain.setValueAtTime(0.25, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                osc.start(now);
                osc.stop(now + 0.12);
            } catch (e) {}
        }

        function playHitSound() {
            try {
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.type = 'sawtooth';
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(80, now + 0.15);
                gain.gain.setValueAtTime(0.25, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            } catch (e) {}
        }

        // Pƒôtla
        function gameLoop() {
            if (!gameRunning) return;

            animationFrame++;
            if (houseCooldown > 0) houseCooldown--;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // State-based rendering
            if (gameState === 'kindergarten') {
                updateKindergartenBoards();
                drawKindergarten();
            } else if (gameState === 'office') {
                updateOfficeComputer();
                drawOffice();
            } else if (gameState === 'shop') {
                updateShop();
                drawShop();
                updateFartClouds();
                drawFartClouds();
            } else if (gameState === 'hairdresser') {
                updateHairdresser();
                drawHairdresser();
                updateFartClouds();
                drawFartClouds();
            } else if (gameState === 'hospital') {
                updateHospital();
                drawHospital();
                updateFartClouds();
                drawFartClouds();
            } else if (gameState === 'playground') {
                updatePlayground();
                drawPlayground();
                updateFartClouds();
                drawFartClouds();
            } else if (gameState === 'interior') {
                drawInterior();
                updateFartClouds();
                drawFartClouds();
            } else if (gameState === 'battle') {
                drawBattle();
            } else {
                // Normal world rendering
                drawBackground();
                drawTrees();
                drawFlowers();
                drawGround();
                drawDecorations();
                drawPassingAnimals();
                drawCandies();
                drawItemsToCollect();
                drawHouses(); // Draw houses
                drawKindergartens(); // Draw kindergartens
                drawOffices(); // Draw offices
                drawShops(); // Draw shops
                drawHairdressers(); // Draw hairdressers
                drawHospitals(); // Draw hospitals
                drawPlaygrounds(); // Draw playgrounds
                drawHycels(); // Draw hycels
                drawFriendsToFind();
                drawFollowingFriends();
                if (!slideState.active) {
                    drawPlayer(player.x - worldOffset, player.y);
                }
                drawPlayer2World();

                // Show cat needs above player in world (thought bubble)
                const needThresholdWorld = 70;
                const worldNeeds = [];
                if (catNeeds.hunger >= needThresholdWorld) worldNeeds.push('hunger');
                if (catNeeds.sleep >= needThresholdWorld) worldNeeds.push('sleep');
                if (catNeeds.toilet >= needThresholdWorld) worldNeeds.push('toilet');
                if (catNeeds.hygiene >= needThresholdWorld) worldNeeds.push('hygiene');
                if (worldNeeds.length > 0) {
                    const npx = player.x - worldOffset + 30;
                    const npy = player.y - 30;
                    const nbW = worldNeeds.length * 28 + 12;

                    // Thought bubble dots
                    ctx.fillStyle = 'rgba(255,255,255,0.8)';
                    ctx.beginPath();
                    ctx.arc(npx + 5, npy + 5, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(npx + 2, npy - 3, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Bubble
                    ctx.fillStyle = 'rgba(255,255,255,0.85)';
                    ctx.beginPath();
                    ctx.roundRect(npx - nbW / 2, npy - 35, nbW, 28, 10);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 150, 180, 0.6)';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.roundRect(npx - nbW / 2, npy - 35, nbW, 28, 10);
                    ctx.stroke();

                    // Mini icons
                    worldNeeds.forEach((need, i) => {
                        const ix = npx - nbW / 2 + 18 + i * 28;
                        const iy = npy - 21;
                        ctx.save();
                        ctx.translate(ix, iy);

                        if (need === 'hunger') {
                            // Fish
                            ctx.fillStyle = '#FF8C42';
                            ctx.beginPath();
                            ctx.ellipse(0, 0, 8, 5, 0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.moveTo(-8, 0);
                            ctx.lineTo(-13, -4);
                            ctx.lineTo(-13, 4);
                            ctx.closePath();
                            ctx.fill();
                        } else if (need === 'sleep') {
                            // Moon
                            ctx.fillStyle = '#6B7EC4';
                            ctx.beginPath();
                            ctx.arc(0, 0, 7, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = 'rgba(255,255,255,0.85)';
                            ctx.beginPath();
                            ctx.arc(3, -2, 6, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (need === 'toilet') {
                            // Roll
                            ctx.fillStyle = '#A0764B';
                            ctx.beginPath();
                            ctx.roundRect(-6, -6, 12, 12, 2);
                            ctx.fill();
                            ctx.fillStyle = '#FFF';
                            ctx.beginPath();
                            ctx.arc(0, 0, 4, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (need === 'hygiene') {
                            // Drop
                            ctx.fillStyle = '#5DADE2';
                            ctx.beginPath();
                            ctx.moveTo(0, -8);
                            ctx.quadraticCurveTo(7, 0, 0, 7);
                            ctx.quadraticCurveTo(-7, 0, 0, -8);
                            ctx.fill();
                        }
                        ctx.restore();
                    });
                }

                // P2 HUD indicator
                if (player2.active && player2.selectedType) {
                    ctx.save();
                    const hudX = 10;
                    const hudY = canvas.height - 40;
                    ctx.fillStyle = 'rgba(70, 130, 230, 0.8)';
                    ctx.beginPath();
                    ctx.roundRect(hudX, hudY, 200, 30, 8);
                    ctx.fill();
                    ctx.fillStyle = '#FFF';
                    ctx.font = 'bold 13px Comic Sans MS';
                    ctx.textAlign = 'left';
                    ctx.fillText('P2: ' + player2.selectedType.name + ' (WASD+E)', hudX + 10, hudY + 20);
                    ctx.restore();
                }

                // Fart clouds (behind rain, over everything else)
                updateFartClouds();
                drawFartClouds();

                // Rain (drawn over everything)
                drawRain();

                updateAndDrawDialogBubbles();

                updatePlayer();
                updatePlayer2World();
                updatePassingAnimals();
                checkCollectibles();
            }

            requestAnimationFrame(gameLoop);
        }

        // Extracted SPACE handler callable from both keyboard and touch
        function handleSpacePress() {
            // Start game from start screen
            if (!gameRunning && document.getElementById('start-screen').classList.contains('active')) {
                startGame();
                return;
            }

            // Slide interaction (world)
            if (gameState === 'world' && slideState.active && !slideState.sliding) {
                slideState.climbStep++;
                if (slideState.climbStep >= 3) {
                    slideState.climbStep = 3;
                    slideState.sliding = true;
                    slideState.slideProgress = 0;
                }
                return;
            }

            // Interior interactions
            if (gameState === 'interior') {
                const px = interiorPlayer.x;
                const floorY = canvas.height - 180;

                if (interiorPlayer.action === 'sleeping') {
                    interiorPlayer.action = 'none';
                    catNeeds.sleep = 0;
                    return;
                }
                if (interiorPlayer.action === 'couch_rest') {
                    interiorPlayer.action = 'none';
                    catNeeds.sleep = Math.max(0, catNeeds.sleep - 30);
                    return;
                }
                if (interiorPlayer.action === 'bathing') {
                    interiorPlayer.bathFoam = !interiorPlayer.bathFoam;
                    return;
                }
                if (interiorPlayer.action !== 'none') return;

                for (const friend of interiorFriends) {
                    if (Math.abs(px - friend.x) < 50 && friend.activity === 'walking') {
                        startAnimalConversation(friend);
                        return;
                    }
                }

                const bedX = 30;
                const bedW = 120;
                if (px > bedX - 20 && px < bedX + bedW + 20) {
                    interiorPlayer.action = 'sleeping';
                    interiorPlayer.actionTimer = -1;
                    return;
                }
                const tvX = 80;
                const tvW = 220;
                if (px > bedX + bedW + 20 && px < tvX + tvW + 30) {
                    tvChannel = (tvChannel + 1) % 7;
                    return;
                }
                const couchX = 340;
                const couchW = 120;
                if (px > couchX - 20 && px < couchX + couchW + 20) {
                    interiorPlayer.action = 'couch_rest';
                    interiorPlayer.actionTimer = -1;
                    return;
                }
                const toiletX = 700;
                if (Math.abs(px - toiletX) < 40) {
                    interiorPlayer.action = 'toilet';
                    interiorPlayer.actionTimer = 120;
                    return;
                }
                const sinkX = toiletX + 80;
                if (Math.abs(px - sinkX) < 40) {
                    interiorPlayer.action = 'washing';
                    interiorPlayer.actionTimer = 90;
                    return;
                }
                const bathtubX = toiletX + 220;
                if (Math.abs(px - bathtubX) < 70) {
                    if (!interiorPlayer.bathtubWaterLevel) interiorPlayer.bathtubWaterLevel = 0;
                    if (interiorPlayer.bathtubWaterLevel >= 1 && !interiorPlayer.bathDone) {
                        // Water full ‚Äî enter bath
                        interiorPlayer.action = 'bathing';
                        interiorPlayer.actionTimer = -1;
                        interiorPlayer.bathFoam = false;
                        return;
                    } else if (interiorPlayer.bathDone && interiorPlayer.bathtubWaterLevel > 0) {
                        // Already bathed, drain water
                        interiorPlayer.action = 'draining_water';
                        interiorPlayer.bathDone = false;
                        return;
                    } else if (interiorPlayer.bathtubWaterLevel < 1) {
                        // Still filling ‚Äî add more water
                        interiorPlayer.action = 'filling_water';
                        interiorPlayer.actionTimer = 30;
                        return;
                    }
                }
                const bowlX = 510;
                if (Math.abs(px - bowlX) < 60) {
                    interiorPlayer.action = 'eating';
                    interiorPlayer.actionTimer = 120;
                    return;
                }
                const ballX = 1020;
                if (Math.abs(px - ballX) < 50) {
                    interiorPlayer.action = 'playing';
                    interiorPlayer.actionTimer = 90;
                    return;
                }
                const cameraX = 620;
                if (Math.abs(px - cameraX) < 40) {
                    photoFlashTimer = 20;
                    const photoCanvas = document.createElement('canvas');
                    photoCanvas.width = 360;
                    photoCanvas.height = 220;
                    const pctx = photoCanvas.getContext('2d');
                    const bgGrad = pctx.createLinearGradient(0, 0, 0, 160);
                    bgGrad.addColorStop(0, '#FFF5E6');
                    bgGrad.addColorStop(1, '#FFECD2');
                    pctx.fillStyle = bgGrad;
                    pctx.fillRect(0, 0, 360, 160);
                    pctx.fillStyle = '#C4935A';
                    pctx.fillRect(0, 160, 360, 60);
                    pctx.strokeStyle = 'rgba(101,67,33,0.3)';
                    pctx.lineWidth = 1;
                    for (let fy = 160; fy < 220; fy += 12) {
                        pctx.beginPath(); pctx.moveTo(0, fy); pctx.lineTo(360, fy); pctx.stroke();
                    }
                    const friends = interiorFriends.slice();
                    const totalChars = friends.length + 1;
                    const spacing = Math.min(50, 300 / (totalChars + 1));
                    const startX = 180 - (totalChars - 1) * spacing / 2;
                    const groundLevel = 155;
                    const charPositions = [];
                    const playerIndex = Math.floor(totalChars / 2);
                    let friendIdx = 0;
                    for (let i = 0; i < totalChars; i++) {
                        const cx = startX + i * spacing;
                        if (i === playerIndex) {
                            charPositions.push({ type: 'player', x: cx });
                        } else if (friendIdx < friends.length) {
                            charPositions.push({ type: 'friend', x: cx, friend: friends[friendIdx] });
                            friendIdx++;
                        }
                    }
                    pctx.save();
                    const scale = 0.6;
                    charPositions.forEach(cp => {
                        pctx.save();
                        pctx.translate(cp.x, groundLevel);
                        pctx.scale(scale, scale);
                        if (cp.type === 'player') {
                            pctx.fillStyle = '#FFB6C1';
                            pctx.beginPath(); pctx.ellipse(0, -15, 12, 18, 0, 0, Math.PI * 2); pctx.fill();
                            pctx.beginPath(); pctx.arc(0, -40, 12, 0, Math.PI * 2); pctx.fill();
                            pctx.fillStyle = '#000';
                            pctx.beginPath(); pctx.arc(-4, -42, 2, 0, Math.PI * 2); pctx.arc(4, -42, 2, 0, Math.PI * 2); pctx.fill();
                            pctx.strokeStyle = '#000'; pctx.lineWidth = 1.5;
                            pctx.beginPath(); pctx.arc(0, -38, 5, 0.2, Math.PI - 0.2); pctx.stroke();
                            pctx.fillStyle = '#FFD700';
                            pctx.beginPath(); pctx.moveTo(-2, -52); pctx.lineTo(0, -65); pctx.lineTo(2, -52); pctx.fill();
                            pctx.fillStyle = '#FFB6C1';
                            [-6, 6].forEach(lx => { pctx.fillRect(lx - 3, 0, 6, 12); });
                        } else {
                            const emoji = cp.friend.type.emoji || cp.friend.type;
                            const colors = {'üê∂':'#C4A265','üê∞':'#DDD','üêª':'#8B6914','üêë':'#F5F5F5','üê¨':'#5DADE2','ü¶ä':'#FF8C00','üêº':'#333','ü¶Ñ':'#DDA0DD','üê∏':'#32CD32','ü¶ã':'#FF69B4'};
                            const col = colors[emoji] || '#AAA';
                            pctx.fillStyle = col;
                            pctx.beginPath(); pctx.ellipse(0, -12, 10, 14, 0, 0, Math.PI * 2); pctx.fill();
                            pctx.beginPath(); pctx.arc(0, -32, 9, 0, Math.PI * 2); pctx.fill();
                            pctx.fillStyle = '#000';
                            pctx.beginPath(); pctx.arc(-3, -33, 1.5, 0, Math.PI * 2); pctx.arc(3, -33, 1.5, 0, Math.PI * 2); pctx.fill();
                            pctx.strokeStyle = '#000'; pctx.lineWidth = 1;
                            pctx.beginPath(); pctx.arc(0, -30, 4, 0.2, Math.PI - 0.2); pctx.stroke();
                            pctx.fillStyle = col;
                            [-5, 5].forEach(lx => { pctx.fillRect(lx - 2, 0, 4, 10); });
                        }
                        pctx.restore();
                    });
                    pctx.restore();
                    pctx.fillStyle = 'rgba(255,255,255,0.7)';
                    pctx.font = 'bold 14px Comic Sans MS';
                    pctx.textAlign = 'center';
                    pctx.fillText('üì∏ Rodzinna fotka! üì∏', 180, 18);
                    pctx.font = '10px Arial';
                    charPositions.forEach((cp, i) => {
                        pctx.fillText('‚ù§Ô∏è', cp.x, groundLevel - 55 * scale - 10 + Math.sin(i * 1.5) * 3);
                    });
                    const img = new Image();
                    img.src = photoCanvas.toDataURL('image/png');
                    wallPhoto = { _img: img, loaded: false };
                    img.onload = () => { wallPhoto.loaded = true; };
                    return;
                }
                const doorX = canvas.width - 350;
                if (px > doorX - 50) {
                    exitHouse();
                    return;
                }
            }
        }

        // Kontrolki
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ' || e.key === 'ArrowUp') e.preventDefault();

            // Fart on Enter
            if (e.key === 'Enter' && ['world', 'interior', 'shop', 'hairdresser', 'hospital', 'playground'].includes(gameState)) {
                doFart();
            }

            // Kindergarten board navigation
            if (gameState === 'kindergarten') {
                if (kindergartenState.mathBoard.active) {
                    if (e.key === 'ArrowLeft') {
                        kindergartenState.mathBoard.selectedOption = Math.max(0, kindergartenState.mathBoard.selectedOption - 1);
                        e.preventDefault();
                    } else if (e.key === 'ArrowRight') {
                        kindergartenState.mathBoard.selectedOption = Math.min(3, kindergartenState.mathBoard.selectedOption + 1);
                        e.preventDefault();
                    } else if (e.key === 'Escape') {
                        kindergartenState.mathBoard.active = false;
                    } else if (e.key === ' ') {
                        handleKindergartenSpace();
                    }
                    startBackgroundMusic();
                    return;
                }
                if (kindergartenState.wordBoard.active) {
                    if (e.key === 'ArrowLeft') {
                        kindergartenState.wordBoard.selectedOption = Math.max(0, kindergartenState.wordBoard.selectedOption - 1);
                        e.preventDefault();
                    } else if (e.key === 'ArrowRight') {
                        kindergartenState.wordBoard.selectedOption = Math.min(3, kindergartenState.wordBoard.selectedOption + 1);
                        e.preventDefault();
                    } else if (e.key === 'Escape') {
                        kindergartenState.wordBoard.active = false;
                    } else if (e.key === ' ') {
                        handleKindergartenSpace();
                    }
                    startBackgroundMusic();
                    return;
                }
                // No board active ‚Äî space for interactions
                if (e.key === ' ') {
                    handleKindergartenSpace();
                    startBackgroundMusic();
                    return;
                }
            }

            // Office computer navigation
            if (gameState === 'office') {
                if (officeState.computer.active) {
                    if (e.key === 'ArrowLeft') {
                        officeState.computer.selectedOption = Math.max(0, officeState.computer.selectedOption - 1);
                        e.preventDefault();
                    } else if (e.key === 'ArrowRight') {
                        officeState.computer.selectedOption = Math.min(3, officeState.computer.selectedOption + 1);
                        e.preventDefault();
                    } else if (e.key === 'Escape') {
                        officeState.computer.active = false;
                    } else if (e.key === ' ') {
                        handleOfficeSpace();
                    }
                    startBackgroundMusic();
                    return;
                }
                if (e.key === ' ') {
                    handleOfficeSpace();
                    startBackgroundMusic();
                    return;
                }
            }

            // Shop navigation
            if (gameState === 'shop') {
                const allItems = getAllShopItems();
                const totalItems = allItems.length;
                if (e.key === 'ArrowLeft') {
                    shopState.selectedItem = Math.max(0, shopState.selectedItem - 1);
                    e.preventDefault();
                } else if (e.key === 'ArrowRight') {
                    shopState.selectedItem = Math.min(Math.max(0, totalItems - 1), shopState.selectedItem + 1);
                    e.preventDefault();
                } else if (e.key === 'ArrowUp') {
                    shopState.scrollY = Math.max(0, shopState.scrollY - 40);
                    e.preventDefault();
                } else if (e.key === 'ArrowDown') {
                    const maxScroll = Math.max(0, (shopState._contentH || 0) - (canvas.height - 200));
                    shopState.scrollY = Math.min(maxScroll, shopState.scrollY + 40);
                    e.preventDefault();
                } else if (e.key === 'Escape') {
                    exitShop();
                } else if (e.key === ' ') {
                    handleShopSpace();
                }
                startBackgroundMusic();
                return;
            }

            // Hairdresser navigation
            if (gameState === 'hairdresser') {
                const allItems = getAllHairItems();
                const totalItems = allItems.length;
                if (e.key === 'ArrowLeft') {
                    hairdresserState.selectedItem = Math.max(0, hairdresserState.selectedItem - 1);
                    e.preventDefault();
                } else if (e.key === 'ArrowRight') {
                    hairdresserState.selectedItem = Math.min(Math.max(0, totalItems - 1), hairdresserState.selectedItem + 1);
                    e.preventDefault();
                } else if (e.key === 'ArrowUp') {
                    hairdresserState.scrollY = Math.max(0, hairdresserState.scrollY - 40);
                    e.preventDefault();
                } else if (e.key === 'ArrowDown') {
                    const maxScroll = Math.max(0, (hairdresserState._contentH || 0) - (canvas.height - 200));
                    hairdresserState.scrollY = Math.min(maxScroll, hairdresserState.scrollY + 40);
                    e.preventDefault();
                } else if (e.key === 'Escape') {
                    exitHairdresser();
                } else if (e.key === ' ') {
                    handleHairdresserSpace();
                }
                startBackgroundMusic();
                return;
            }

            // Hospital navigation
            if (gameState === 'hospital') {
                if (e.key === 'Escape') {
                    if (hospitalState.currentGame !== null) {
                        hospitalState.currentGame = null;
                        hospitalState.gameData = {};
                    } else {
                        exitHospital();
                    }
                } else if (e.key === ' ') {
                    handleHospitalSpace();
                    e.preventDefault();
                } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    handleHospitalArrow(e.key);
                    e.preventDefault();
                }
                startBackgroundMusic();
                return;
            }

            // Playground navigation
            if (gameState === 'playground') {
                if (e.key === 'Escape') {
                    if (playgroundState.currentGame !== null) {
                        playgroundState.currentGame = null;
                        playgroundState.gameData = {};
                    } else {
                        exitPlayground();
                    }
                } else if (e.key === ' ') {
                    handlePlaygroundSpace();
                    e.preventDefault();
                } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    handlePlaygroundArrow(e.key);
                    e.preventDefault();
                }
                startBackgroundMusic();
                return;
            }

            if (e.key === ' ') {
                handleSpacePress();
            }

            // P2: Z to cycle animal, E to interact
            if (e.key === 'z' || e.key === 'Z') {
                handleP2CycleAnimal();
            }
            if (e.key === 'e' || e.key === 'E' || e.key === 'x' || e.key === 'X') {
                handleP2ActionPress();
            }

            // Uruchom muzykƒô w tle przy pierwszym klawiszu
            startBackgroundMusic();
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Uruchomienie muzyki tak≈ºe przy klikniƒôciu
        document.addEventListener('click', () => {
            startBackgroundMusic();
        });

        // ========== TOUCH CONTROLS FOR MOBILE/TABLET ==========

        // Detect touch device
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        if (isTouchDevice) {
            document.getElementById('touch-controls').style.display = 'block';
        }

        // Prevent page scrolling/zooming on touch
        document.addEventListener('touchmove', (e) => {
            if (e.target.closest('#touch-controls') || e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });

        document.addEventListener('touchstart', (e) => {
            if (e.target === canvas) {
                e.preventDefault();
                startBackgroundMusic();
            }
        }, { passive: false });

        // Touch button handlers - simulate key presses
        function setupTouchButton(element) {
            if (!element) return;
            const key = element.dataset.key;
            if (!key) return;

            let touchId = null;

            element.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                touchId = e.changedTouches[0].identifier;
                element.classList.add('pressed');
                keys[key] = true;

                // For SPACE, call the handler directly
                if (key === ' ') {
                    handleSpacePress();
                }

                startBackgroundMusic();
            }, { passive: false });

            element.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                for (const t of e.changedTouches) {
                    if (t.identifier === touchId) {
                        element.classList.remove('pressed');
                        keys[key] = false;
                        touchId = null;
                        break;
                    }
                }
            }, { passive: false });

            element.addEventListener('touchcancel', (e) => {
                element.classList.remove('pressed');
                keys[key] = false;
                touchId = null;
            }, { passive: false });
        }

        // Setup all touch buttons
        document.querySelectorAll('.touch-btn, .touch-btn-action, .touch-btn-jump').forEach(btn => {
            setupTouchButton(btn);
        });

        // Handle touch on canvas for start screen tap
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameRunning && document.getElementById('start-screen').classList.contains('active')) {
                startGame();
            }
            startBackgroundMusic();
        }, { passive: false });

        // Multi-touch support for d-pad: track active touches
        const touchDpad = document.querySelector('.touch-dpad');
        if (touchDpad) {
            let activeDpadTouches = {};

            touchDpad.addEventListener('touchstart', (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    const target = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (target && target.dataset.key) {
                        activeDpadTouches[touch.identifier] = target.dataset.key;
                        keys[target.dataset.key] = true;
                        target.classList.add('pressed');
                    }
                }
            }, { passive: false });

            touchDpad.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    const oldKey = activeDpadTouches[touch.identifier];
                    const target = document.elementFromPoint(touch.clientX, touch.clientY);
                    const newKey = target && target.dataset ? target.dataset.key : null;

                    if (oldKey && oldKey !== newKey) {
                        keys[oldKey] = false;
                        const oldEl = touchDpad.querySelector(`[data-key="${oldKey}"]`);
                        if (oldEl) oldEl.classList.remove('pressed');
                    }
                    if (newKey && newKey !== oldKey) {
                        keys[newKey] = true;
                        target.classList.add('pressed');
                        activeDpadTouches[touch.identifier] = newKey;
                    }
                    if (!newKey) {
                        delete activeDpadTouches[touch.identifier];
                    }
                }
            }, { passive: false });

            const endDpadTouch = (e) => {
                for (const touch of e.changedTouches) {
                    const key = activeDpadTouches[touch.identifier];
                    if (key) {
                        keys[key] = false;
                        const el = touchDpad.querySelector(`[data-key="${key}"]`);
                        if (el) el.classList.remove('pressed');
                        delete activeDpadTouches[touch.identifier];
                    }
                }
            };

            touchDpad.addEventListener('touchend', endDpadTouch, { passive: false });
            touchDpad.addEventListener('touchcancel', endDpadTouch, { passive: false });
        }
    </script>
</body>
</html>
