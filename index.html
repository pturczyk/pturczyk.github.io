<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¦„ğŸ˜º KicioroÅ¼ek - Spokojna Przygoda ğŸŒˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', cursive;
            background: #000;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #87CEEB;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 20px;
            border: 4px solid #FF69B4;
            font-size: 1.2em;
            color: #FF1493;
            box-shadow: 0 5px 20px rgba(255, 105, 180, 0.5);
            z-index: 10;
        }

        .friends-parade {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 20px;
            border: 4px solid #FF69B4;
            font-size: 1.1em;
            color: #FF1493;
            box-shadow: 0 5px 20px rgba(255, 105, 180, 0.5);
            z-index: 10;
            max-width: 250px;
        }

        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            padding: 40px;
            border-radius: 30px;
            border: 8px solid #FF69B4;
            text-align: center;
            display: none;
            z-index: 100;
            box-shadow: 0 10px 40px rgba(255, 105, 180, 0.5);
        }

        .message.active {
            display: block;
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        button {
            background: linear-gradient(135deg, #FF69B4, #FF1493);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.3em;
            font-family: 'Comic Sans MS', cursive;
            border-radius: 50px;
            cursor: pointer;
            margin: 10px;
            box-shadow: 0 5px 15px rgba(255, 20, 147, 0.4);
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(255, 20, 147, 0.6);
        }

        .hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 30px;
            border-radius: 15px;
            border: 3px solid #FF69B4;
            color: #FF1493;
            font-size: 1.1em;
            z-index: 10;
            display: none;
        }

        .wardrobe {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 20px;
            border: 4px solid #FF69B4;
            z-index: 10;
            max-width: 250px;
        }

        .wardrobe h3 {
            color: #FF1493;
            margin: 0 0 10px 0;
            font-size: 1.1em;
        }

        .wardrobe-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }

        .wardrobe-item {
            background: linear-gradient(135deg, #FFE5F1, #FFF);
            border: 2px solid #FF69B4;
            border-radius: 10px;
            padding: 8px;
            cursor: pointer;
            font-size: 1.8em;
            transition: all 0.2s;
            position: relative;
        }

        .wardrobe-item:hover {
            transform: scale(1.1);
            border-color: #FF1493;
            box-shadow: 0 3px 10px rgba(255, 105, 180, 0.4);
        }

        .wardrobe-item.equipped {
            background: linear-gradient(135deg, #FF69B4, #FFB6D9);
            border-color: #FF1493;
            box-shadow: 0 0 15px rgba(255, 105, 180, 0.6);
        }

        .wardrobe-item.equipped::after {
            content: 'âœ“';
            position: absolute;
            top: -5px;
            right: -5px;
            background: #00FF00;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wardrobe-section {
            margin-bottom: 8px;
        }

        .wardrobe-section-title {
            color: #8B008B;
            font-size: 0.9em;
            font-weight: bold;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div class="hud">
        ğŸ¬ Cukierki: <span id="score">0</span><br>
        ğŸ“ Pozycja: <span id="position">0</span>m<br>
        ğŸµ <span id="mood">Miau! ğŸ˜º</span>
    </div>

    <div class="friends-parade">
        <strong>Parada przyjaciÃ³Å‚:</strong><br>
        <div id="friends-list" style="margin-top: 10px; font-size: 1.5em;">
            (czeka na przyjaciÃ³Å‚)
        </div>
    </div>

    <div class="wardrobe">
        <h3>ğŸ‘— Garderoba ğŸ¦„</h3>

        <div class="wardrobe-section">
            <div class="wardrobe-section-title">RÃ³g:</div>
            <div class="wardrobe-items" id="horn-items"></div>
        </div>

        <div class="wardrobe-section">
            <div class="wardrobe-section-title">Ubranka:</div>
            <div class="wardrobe-items" id="outfit-items"></div>
        </div>

        <div class="wardrobe-section">
            <div class="wardrobe-section-title">Akcesoria:</div>
            <div class="wardrobe-items" id="accessory-items"></div>
        </div>

        <div class="wardrobe-section">
            <div class="wardrobe-section-title">Kolor futerka:</div>
            <div class="wardrobe-items" id="color-items"></div>
        </div>
    </div>

    <div class="hint">
        â¬…ï¸â¡ï¸ A/D lub strzaÅ‚ki - Spacer | â¬†ï¸ SPACJA - Skocz / Walcz / WejdÅº do domu ğŸ  | Odkrywaj spokojny Å›wiat! ğŸŒ¸
    </div>

    <div class="message active" id="start-screen">
        <h2 style="color: #FF1493; font-size: 2em; margin-bottom: 20px;">
            ğŸ¦„ğŸ˜º Witaj w Candy Krainie! ğŸŒˆâœ¨
        </h2>
        <p style="color: #8B008B; font-size: 1.2em; margin: 20px 0; line-height: 1.6;">
            Jestem KicioroÅ¼ek! ğŸ±ğŸ¦„<br><br>
            Wyruszam w spokojnÄ… podrÃ³Å¼ po piÄ™knej krainie! ğŸ’–<br>
            ZbiorÄ™ cukierki i znajdÄ™ przyjaciÃ³Å‚! ğŸ­<br><br>
            <strong>ğŸŒ¸ To spokojna przygoda bez niebezpieczeÅ„stw!</strong><br>
            Spaceruj, eksploruj i ciesz siÄ™ podrÃ³Å¼Ä…! âœ¨<br>
            MoÅ¼esz skakaÄ‡ jeÅ›li chcesz, ale nie musisz! ğŸ˜Š<br><br>
            KaÅ¼dy znaleziony przyjaciel bÄ™dzie za TobÄ… podÄ…Å¼aÅ‚! ğŸ’•
        </p>
        <button onclick="startGame()">NaciÅ›nij SPACJÄ˜ lub kliknij - Zacznij podrÃ³Å¼! ğŸš€âœ¨</button>
    </div>

    <div class="message" id="victory-screen">
        <h2 style="color: #FF1493; font-size: 2.5em;">WspaniaÅ‚a przygoda! ğŸ‰ğŸŒˆ</h2>
        <p style="color: #8B008B; font-size: 1.3em; margin: 20px 0; line-height: 1.6;">
            ZnalazÅ‚eÅ› wszystkich 10 przyjaciÃ³Å‚! ğŸŠ<br>
            Twoja parada jest kompletna! ğŸ’•âœ¨<br><br>
            Zebrane cukierki: <strong id="final-score">0</strong> ğŸ¬<br>
            Przebyta droga: <strong id="final-distance">0</strong>m ğŸ—ºï¸<br><br>
            <span style="font-size: 2em;">ğŸ±ğŸ¦„ğŸ¶ğŸ°ğŸ»ğŸ‘ğŸ¬ğŸ¦ŠğŸ¼ğŸ¦„ğŸ¸ğŸ¦‹</span><br><br>
            MoÅ¼esz dalej eksplorowaÄ‡ lub zagraÄ‡ ponownie! ğŸ˜Š
        </p>
        <button onclick="closeFriendMessage()">Dalej zwiedzaj! ğŸŒ</button>
        <button onclick="location.reload()">Nowa przygoda! ğŸ®</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Stan gry
        let gameRunning = false;
        let score = 0;
        let keys = {};
        let worldOffset = 0;
        let animationFrame = 0;

        // KicioroÅ¼ek
        const player = {
            x: 300,
            y: canvas.height - 150,
            width: 60,
            height: 80,
            speed: 8,
            velY: 0,
            jumping: false,
            gravity: 0.6,
            jumpPower: -12,
            facingRight: true,
            walkCycle: 0,
            tailSwing: 0,
            // Garderoba
            equippedHorn: 'gold',
            equippedOutfit: null,
            equippedAccessory: null,
            equippedColor: 'pink' // DomyÅ›lny rÃ³Å¼owy
        };

        // DostÄ™pne przedmioty
        let collectedItems = {
            horns: ['gold'], // ZÅ‚oty domyÅ›lnie
            outfits: [],
            accessories: [],
            colors: ['pink'] // RÃ³Å¼owy domyÅ›lnie
        };

        // Przedmioty do zbierania w Å›wiecie
        let itemsToCollect = [];

        // Definicje przedmiotÃ³w
        const itemDefinitions = {
            horns: [
                { id: 'gold', emoji: 'ğŸŒŸ', color: '#FFD700', name: 'ZÅ‚oty rÃ³g' },
                { id: 'rainbow', emoji: 'ğŸŒˆ', color: null, name: 'TÄ™czowy rÃ³g' },
                { id: 'pink', emoji: 'ğŸ’–', color: '#FF69B4', name: 'RÃ³Å¼owy rÃ³g' },
                { id: 'blue', emoji: 'ğŸ’', color: '#87CEEB', name: 'Niebieski rÃ³g' },
                { id: 'purple', emoji: 'ğŸ’œ', color: '#9370DB', name: 'Fioletowy rÃ³g' },
                { id: 'green', emoji: 'ğŸ’š', color: '#90EE90', name: 'Zielony rÃ³g' }
            ],
            outfits: [
                { id: 'cape', emoji: 'ğŸ¦¸', name: 'Peleryna' },
                { id: 'dress', emoji: 'ğŸ‘—', name: 'Sukienka' },
                { id: 'scarf', emoji: 'ğŸ§£', name: 'Szalik' },
                { id: 'shirt', emoji: 'ğŸ‘•', name: 'Koszulka' },
                { id: 'sweater', emoji: 'ğŸ§¥', name: 'Sweterek' }
            ],
            accessories: [
                { id: 'crown', emoji: 'ğŸ‘‘', name: 'Korona' },
                { id: 'bow', emoji: 'ğŸ€', name: 'Kokarda' },
                { id: 'glasses', emoji: 'ğŸ‘“', name: 'Okulary' },
                { id: 'hat', emoji: 'ğŸ©', name: 'Kapelusz' },
                { id: 'flower', emoji: 'ğŸŒ¸', name: 'Kwiatek' }
            ],
            colors: [
                { id: 'pink', emoji: 'ğŸ©·', name: 'RÃ³Å¼owy', bodyColor: '#FFC0CB', shadeColor: '#FFB6D9' },
                { id: 'white', emoji: 'ğŸ¤', name: 'BiaÅ‚y', bodyColor: '#FFF', shadeColor: '#F5F5F5' },
                { id: 'orange', emoji: 'ğŸ§¡', name: 'PomaraÅ„czowy', bodyColor: '#FFA500', shadeColor: '#FF8C00' },
                { id: 'yellow', emoji: 'ğŸ’›', name: 'Å»Ã³Å‚ty', bodyColor: '#FFD700', shadeColor: '#FFA500' },
                { id: 'green', emoji: 'ğŸ’š', name: 'Zielony', bodyColor: '#90EE90', shadeColor: '#7FBF7F' },
                { id: 'blue', emoji: 'ğŸ’™', name: 'Niebieski', bodyColor: '#87CEEB', shadeColor: '#6CA6CD' },
                { id: 'purple', emoji: 'ğŸ’œ', name: 'Fioletowy', bodyColor: '#DDA0DD', shadeColor: '#BA7FBA' },
                { id: 'brown', emoji: 'ğŸ¤', name: 'BrÄ…zowy', bodyColor: '#CD853F', shadeColor: '#8B4513' },
                { id: 'gray', emoji: 'ğŸ©¶', name: 'Szary', bodyColor: '#C0C0C0', shadeColor: '#A9A9A9' },
                { id: 'black', emoji: 'ğŸ–¤', name: 'Czarny', bodyColor: '#696969', shadeColor: '#000' }
            ]
        };

        // Przyjaciele
        let followingFriends = [];
        const friendTypes = [
            { emoji: 'ğŸ¶', name: 'TÄ™czowy Piesek', sound: 'HAU HAU! Uwielbiam spacery!', color: '#FFD700' },
            { emoji: 'ğŸ°', name: 'RÃ³Å¼owy KrÃ³liczek', sound: 'Hopsasa! Tak siÄ™ cieszÄ™!', color: '#FF69B4' },
            { emoji: 'ğŸ»', name: 'Gwiazdkowy Misiek', sound: 'MiÅ›kowe uÅ›ciski dla wszystkich!', color: '#DDA0DD' },
            { emoji: 'ğŸ‘', name: 'Chmurka Baranek', sound: 'Beeee! PÅ‚ynÄ™ jak chmurka!', color: '#E0C3FC' },
            { emoji: 'ğŸ¬', name: 'Magiczny Delfinek', sound: 'PÅ‚um pÅ‚um! WesoÅ‚o!', color: '#87CEEB' },
            { emoji: 'ğŸ¦Š', name: 'Ognisty Lisek', sound: 'Yip yip! Przygoda!', color: '#FF8C00' },
            { emoji: 'ğŸ¼', name: 'PanduÅ›', sound: 'Nom nom bambusÃ³w!', color: '#98FB98' },
            { emoji: 'ğŸ¦„', name: 'Siostrzyczka JednoroÅ¼ec', sound: 'Ihaha! JesteÅ›my rodzinÄ…!', color: '#E0B0FF' },
            { emoji: 'ğŸ¸', name: 'Å»abka Skoczek', sound: 'Kwa kwa! Super zabawa!', color: '#90EE90' },
            { emoji: 'ğŸ¦‹', name: 'Motyl BÅ‚yszczek', sound: 'Fru fru! PiÄ™kny dzieÅ„!', color: '#FFB6D9' }
        ];

        let playerHistory = [];
        const historyLength = 40;

        // Åšwiat
        let ground = [];
        let candies = [];
        let friendsToFind = [];
        let decorations = [];
        let flowers = [];
        let trees = [];
        let passingAnimals = []; // ZwierzÄ™ta ktÃ³re mijajÄ…
        let dialogBubbles = []; // Chmurki dialogowe
        const chunkSize = 1000;
        let generatedChunks = new Set();
        let furthestPosition = 0;

        // State Management System
        let gameState = 'world'; // 'world' | 'interior' | 'battle'
        let previousState = 'world';

        // House System
        let houses = []; // Dynamically generated houses

        // Interior State
        let interiorFriends = [];
        let interiorAnimationFrame = 0;
        let interiorOffset = 0; // Camera offset for scrolling interior
        let interiorPlayer = {
            x: 200, // World position
            y: 0, // set on enter based on floorY
            action: 'none', // 'none' | 'sleeping' | 'toilet' | 'washing' | 'eating' | 'playing'
            actionTimer: 0,
            actionObject: null // Which object player is interacting with
        };
        let interiorObjects = []; // Procedurally placed furniture

        // Hycel System
        let hycels = [];

        // Battle System
        let currentBattle = null;
        let battleState = {
            playerHealth: 5,
            enemyHealth: 3,
            playerAttackCooldown: 0,
            enemyAttackCooldown: 60,
            message: '',
            victory: false,
            defeat: false,
            attackAnimation: 0,
            hitAnimation: 0,
            victoryAnimationFrame: 0,
            defeatAnimationFrame: 0
        };

        // System dÅºwiÄ™kÃ³w - Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Funkcja pomocnicza do tworzenia envelope
        function createEnvelope(gainNode, attackTime, decayTime, sustainLevel, releaseTime, startTime) {
            gainNode.gain.setValueAtTime(0, startTime);
            gainNode.gain.linearRampToValueAtTime(1, startTime + attackTime);
            gainNode.gain.linearRampToValueAtTime(sustainLevel, startTime + attackTime + decayTime);
            gainNode.gain.setValueAtTime(sustainLevel, startTime + attackTime + decayTime + releaseTime);
            gainNode.gain.linearRampToValueAtTime(0, startTime + attackTime + decayTime + releaseTime + 0.1);
        }

        // Funkcja do odtwarzania dÅºwiÄ™ku zwierzÄ…tka
        function playAnimalSound(animalType) {
            const now = audioContext.currentTime;

            switch(animalType) {
                case 'cat': // Realistyczne miauczenie (wielokrotne!)
                    {
                        // Losowa liczba miaukniÄ™Ä‡ (1-3)
                        const meowCount = Math.floor(Math.random() * 3) + 1;

                        for (let i = 0; i < meowCount; i++) {
                            const startTime = now + i * 0.5; // 0.5s przerwy miÄ™dzy miaukniÄ™ciami

                            const osc = audioContext.createOscillator();
                            const gain = audioContext.createGain();
                            const filter = audioContext.createBiquadFilter();

                            osc.type = 'sawtooth';
                            osc.frequency.setValueAtTime(600, startTime);
                            osc.frequency.exponentialRampToValueAtTime(450, startTime + 0.15);
                            osc.frequency.exponentialRampToValueAtTime(550, startTime + 0.3);

                            filter.type = 'bandpass';
                            filter.frequency.value = 1800;
                            filter.Q.value = 5;

                            osc.connect(filter);
                            filter.connect(gain);
                            gain.connect(audioContext.destination);

                            gain.gain.setValueAtTime(0, startTime);
                            gain.gain.linearRampToValueAtTime(0.35, startTime + 0.05);
                            gain.gain.linearRampToValueAtTime(0.25, startTime + 0.15);
                            gain.gain.linearRampToValueAtTime(0, startTime + 0.35);

                            osc.start(startTime);
                            osc.stop(startTime + 0.35);
                        }
                    }
                    break;

                case 'dog': // Szczekanie
                    {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        const noise = audioContext.createBufferSource();
                        const noiseGain = audioContext.createGain();

                        // Szum dla realizmu
                        const bufferSize = audioContext.sampleRate * 0.2;
                        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                        const data = buffer.getChannelData(0);
                        for (let i = 0; i < bufferSize; i++) {
                            data[i] = Math.random() * 2 - 1;
                        }
                        noise.buffer = buffer;

                        osc.type = 'square';
                        osc.frequency.setValueAtTime(180, now);
                        osc.frequency.exponentialRampToValueAtTime(140, now + 0.1);

                        osc.connect(gain);
                        noise.connect(noiseGain);
                        gain.connect(audioContext.destination);
                        noiseGain.connect(audioContext.destination);

                        gain.gain.setValueAtTime(0.4, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                        noiseGain.gain.setValueAtTime(0.1, now);
                        noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                        osc.start(now);
                        osc.stop(now + 0.15);
                        noise.start(now);
                        noise.stop(now + 0.15);
                    }
                    break;

                case 'rabbit': // Pisk krÃ³lika
                    {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();

                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(1400, now);
                        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.08);

                        osc.connect(gain);
                        gain.connect(audioContext.destination);

                        gain.gain.setValueAtTime(0.25, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

                        osc.start(now);
                        osc.stop(now + 0.1);
                    }
                    break;

                case 'bear': // GÅ‚Ä™boki pomruk
                    {
                        const osc1 = audioContext.createOscillator();
                        const osc2 = audioContext.createOscillator();
                        const gain = audioContext.createGain();

                        osc1.type = 'sawtooth';
                        osc1.frequency.setValueAtTime(90, now);
                        osc1.frequency.exponentialRampToValueAtTime(70, now + 0.4);

                        osc2.type = 'sine';
                        osc2.frequency.setValueAtTime(180, now);

                        osc1.connect(gain);
                        osc2.connect(gain);
                        gain.connect(audioContext.destination);

                        gain.gain.setValueAtTime(0.4, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);

                        osc1.start(now);
                        osc2.start(now);
                        osc1.stop(now + 0.5);
                        osc2.stop(now + 0.5);
                    }
                    break;

                case 'sheep': // Beczenie
                    {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();

                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(280, now);
                        osc.frequency.setValueAtTime(320, now + 0.1);
                        osc.frequency.setValueAtTime(280, now + 0.2);
                        osc.frequency.setValueAtTime(300, now + 0.3);

                        osc.connect(gain);
                        gain.connect(audioContext.destination);

                        gain.gain.setValueAtTime(0.35, now);
                        gain.gain.setValueAtTime(0.3, now + 0.2);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

                        osc.start(now);
                        osc.stop(now + 0.4);
                    }
                    break;

                case 'dolphin': // Wysokie piski
                    {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();

                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(2200, now);
                        osc.frequency.exponentialRampToValueAtTime(2800, now + 0.08);
                        osc.frequency.exponentialRampToValueAtTime(2000, now + 0.18);
                        osc.frequency.exponentialRampToValueAtTime(2500, now + 0.25);

                        osc.connect(gain);
                        gain.connect(audioContext.destination);

                        gain.gain.setValueAtTime(0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

                        osc.start(now);
                        osc.stop(now + 0.3);
                    }
                    break;

                case 'fox': // Skowyt
                    {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();

                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(450, now);
                        osc.frequency.exponentialRampToValueAtTime(800, now + 0.2);
                        osc.frequency.exponentialRampToValueAtTime(400, now + 0.4);

                        osc.connect(gain);
                        gain.connect(audioContext.destination);

                        gain.gain.setValueAtTime(0.35, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.45);

                        osc.start(now);
                        osc.stop(now + 0.45);
                    }
                    break;

                case 'panda': // Pomruk pandy
                    {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();

                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(110, now);
                        osc.frequency.exponentialRampToValueAtTime(95, now + 0.3);

                        osc.connect(gain);
                        gain.connect(audioContext.destination);

                        gain.gain.setValueAtTime(0.4, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);

                        osc.start(now);
                        osc.stop(now + 0.35);
                    }
                    break;

                case 'unicorn': // Magiczny dÅºwiÄ™k
                    {
                        for (let i = 0; i < 3; i++) {
                            const osc = audioContext.createOscillator();
                            const gain = audioContext.createGain();

                            osc.type = 'sine';
                            const baseFreq = 800 + i * 400;
                            osc.frequency.setValueAtTime(baseFreq, now + i * 0.1);
                            osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, now + i * 0.1 + 0.15);

                            osc.connect(gain);
                            gain.connect(audioContext.destination);

                            gain.gain.setValueAtTime(0.2, now + i * 0.1);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.2);

                            osc.start(now + i * 0.1);
                            osc.stop(now + i * 0.1 + 0.2);
                        }
                    }
                    break;

                case 'frog': // Rechot
                    {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();

                        osc.type = 'square';
                        osc.frequency.setValueAtTime(240, now);
                        osc.frequency.setValueAtTime(220, now + 0.06);
                        osc.frequency.setValueAtTime(240, now + 0.12);
                        osc.frequency.setValueAtTime(220, now + 0.18);

                        osc.connect(gain);
                        gain.connect(audioContext.destination);

                        gain.gain.setValueAtTime(0.35, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);

                        osc.start(now);
                        osc.stop(now + 0.25);
                    }
                    break;

                case 'butterfly': // Delikatne brzÄ™czenie
                    {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();

                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(1600, now);
                        osc.frequency.setValueAtTime(1650, now + 0.04);
                        osc.frequency.setValueAtTime(1600, now + 0.08);
                        osc.frequency.setValueAtTime(1650, now + 0.12);

                        osc.connect(gain);
                        gain.connect(audioContext.destination);

                        gain.gain.setValueAtTime(0.15, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);

                        osc.start(now);
                        osc.stop(now + 0.18);
                    }
                    break;
            }
        }

        // Muzyka w tle - delikatna melodyjka
        let musicOscillators = [];
        let musicStarted = false;

        function startBackgroundMusic() {
            if (!musicStarted && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            if (!musicStarted) {
                // Melodia wyÅ‚Ä…czona
                // playBackgroundMelody();
                musicStarted = true;
            }
        }

        function playBackgroundMelody() {
            // Prosta, radosna melodia w pÄ™tli
            const melody = [
                {note: 523.25, duration: 0.3}, // C5
                {note: 587.33, duration: 0.3}, // D5
                {note: 659.25, duration: 0.3}, // E5
                {note: 698.46, duration: 0.3}, // F5
                {note: 783.99, duration: 0.6}, // G5
                {note: 659.25, duration: 0.3}, // E5
                {note: 698.46, duration: 0.6}, // F5
                {note: 523.25, duration: 0.6}, // C5
            ];

            let time = audioContext.currentTime;

            function playNote(frequency, duration, startTime) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.type = 'sine';
                osc.frequency.value = frequency;

                osc.connect(gain);
                gain.connect(audioContext.destination);

                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(0.04, startTime + 0.02);
                gain.gain.linearRampToValueAtTime(0.025, startTime + duration - 0.05);
                gain.gain.linearRampToValueAtTime(0, startTime + duration);

                osc.start(startTime);
                osc.stop(startTime + duration);
            }

            function scheduleMelody() {
                time = audioContext.currentTime + 0.1;
                melody.forEach(note => {
                    playNote(note.note, note.duration, time);
                    time += note.duration + 0.1;
                });

                // PowtÃ³rz melodiÄ™
                setTimeout(scheduleMelody, (time - audioContext.currentTime) * 1000);
            }

            scheduleMelody();
        }

        const candyColors = ['#FF69B4', '#FFB6D9', '#E0C3FC', '#FFF4E0', '#D4F1F9', '#FF1493', '#DDA0DD', '#F0E68C'];

        // Generowanie chunka
        function generateChunk(chunkX) {
            if (generatedChunks.has(chunkX)) return;
            generatedChunks.add(chunkX);

            const startX = chunkX * chunkSize;

            // PÅ‚aski grunt (opcjonalnie z delikatnymi wzgÃ³rzami)
            const groundY = canvas.height - 100;
            ground.push({
                x: startX,
                y: groundY,
                width: chunkSize,
                height: 100
            });

            // Cukierki na ziemi
            const numCandies = 15 + Math.floor(Math.random() * 10);
            for (let i = 0; i < numCandies; i++) {
                candies.push({
                    x: startX + Math.random() * chunkSize,
                    y: groundY - 20,
                    collected: false,
                    type: Math.floor(Math.random() * 5)
                });
            }

            // Przyjaciel (co 2-3 chunki)
            if (chunkX > 0 && chunkX % 2 === 0 && friendsToFind.length < friendTypes.length) {
                const friendType = friendTypes[friendsToFind.length];
                const friendX = startX + chunkSize / 2;
                const hasHycel = (friendsToFind.length % 2 === 1); // Indices 1, 3, 5, 7, 9

                friendsToFind.push({
                    x: friendX,
                    y: groundY - 60,
                    type: friendType,
                    found: false,
                    bounceOffset: Math.random() * Math.PI * 2,
                    hasHycel: hasHycel
                });

                // Spawn hycel if needed
                if (hasHycel) {
                    hycels.push({
                        x: friendX - 100,
                        y: groundY - 80,
                        width: 70,
                        height: 80,
                        health: 3,
                        defeated: false,
                        friendIndex: friendsToFind.length - 1,
                        bounceOffset: 0,
                        angry: false,
                        friendType: friendType // Store which animal costume
                    });
                }

                // Domek (co 2-3 zwierzÄ…tko)
                if (friendsToFind.length % 3 === 0 || friendsToFind.length % 2 === 0) {
                    houses.push({
                        x: friendX + 150, // Obok zwierzÄ…tka
                        y: groundY,
                        width: 250,
                        height: 200
                    });
                }
            }

            // Kwiaty
            for (let i = 0; i < 20; i++) {
                flowers.push({
                    x: startX + Math.random() * chunkSize,
                    y: groundY - 10,
                    color: candyColors[Math.floor(Math.random() * candyColors.length)],
                    size: 15 + Math.random() * 10,
                    swayOffset: Math.random() * Math.PI * 2
                });
            }

            // Drzewa
            for (let i = 0; i < 5; i++) {
                trees.push({
                    x: startX + Math.random() * chunkSize,
                    y: groundY,
                    height: 80 + Math.random() * 60,
                    width: 40 + Math.random() * 30
                });
            }

            // Dekoracje (motyle, ptaszki)
            for (let i = 0; i < 8; i++) {
                decorations.push({
                    x: startX + Math.random() * chunkSize,
                    y: 100 + Math.random() * 200,
                    type: Math.random() > 0.5 ? 'butterfly' : 'bird',
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.5 + Math.random()
                });
            }

            // ZwierzÄ™ta mijajÄ…ce (pszczoÅ‚y, Å¼uki, inne)
            const groundYForAnimals = canvas.height - 100;
            const animalTypes = [
                { emoji: 'ğŸ', speed: 1.5, flying: true, height: 150 }, // PszczoÅ‚a
                { emoji: 'ğŸ', speed: 0.8, flying: true, height: 200 }, // Biedronka
                { emoji: 'ğŸ¦—', speed: 0.5, flying: false, height: 30 }, // Åšwierszcz
                { emoji: 'ğŸ›', speed: 0.3, flying: false, height: 20 }, // GÄ…sienica
                { emoji: 'ğŸ¦Ÿ', speed: 2, flying: true, height: 180 }, // Komarek
                { emoji: 'ğŸ•Šï¸', speed: 1.2, flying: true, height: 120 }, // GoÅ‚Ä…bek
                { emoji: 'ğŸ¦…', speed: 1.8, flying: true, height: 80 }, // OrzeÅ‚
                { emoji: 'ğŸ¿ï¸', speed: 1, flying: false, height: 35 }, // WiewiÃ³rka
                { emoji: 'ğŸ', speed: 0.7, flying: false, height: 25 }, // Myszka
                { emoji: 'ğŸ¢', speed: 0.2, flying: false, height: 25 }, // Å»Ã³Å‚w
            ];

            for (let i = 0; i < 10; i++) {
                const animalType = animalTypes[Math.floor(Math.random() * animalTypes.length)];
                passingAnimals.push({
                    x: startX + Math.random() * chunkSize,
                    y: animalType.flying ? animalType.height : groundYForAnimals - animalType.height,
                    emoji: animalType.emoji,
                    speed: animalType.speed,
                    direction: Math.random() > 0.5 ? 1 : -1,
                    flying: animalType.flying,
                    phase: Math.random() * Math.PI * 2,
                    minX: startX - 200,
                    maxX: startX + chunkSize + 200
                });
            }

            // Przedmioty do zbierania (rogi, ubranka, akcesoria)
            if (chunkX > 0) {
                // RÃ³g (rzadko, co 5 chunkÃ³w)
                if (chunkX % 5 === 0 && Math.random() > 0.3) {
                    const availableHorns = itemDefinitions.horns.filter(h => !collectedItems.horns.includes(h.id));
                    if (availableHorns.length > 0) {
                        const horn = availableHorns[Math.floor(Math.random() * availableHorns.length)];
                        itemsToCollect.push({
                            x: startX + chunkSize / 2 + (Math.random() - 0.5) * 300,
                            y: groundY - 40,
                            type: 'horn',
                            item: horn,
                            collected: false
                        });
                    }
                }

                // Ubranka (co 3 chunki)
                if (chunkX % 3 === 0 && Math.random() > 0.2) {
                    const availableOutfits = itemDefinitions.outfits.filter(o => !collectedItems.outfits.includes(o.id));
                    if (availableOutfits.length > 0) {
                        const outfit = availableOutfits[Math.floor(Math.random() * availableOutfits.length)];
                        itemsToCollect.push({
                            x: startX + chunkSize / 2 + (Math.random() - 0.5) * 400,
                            y: groundY - 35,
                            type: 'outfit',
                            item: outfit,
                            collected: false
                        });
                    }
                }

                // Akcesoria (co 4 chunki)
                if (chunkX % 4 === 0 && Math.random() > 0.3) {
                    const availableAccessories = itemDefinitions.accessories.filter(a => !collectedItems.accessories.includes(a.id));
                    if (availableAccessories.length > 0) {
                        const accessory = availableAccessories[Math.floor(Math.random() * availableAccessories.length)];
                        itemsToCollect.push({
                            x: startX + chunkSize / 2 + (Math.random() - 0.5) * 350,
                            y: groundY - 38,
                            type: 'accessory',
                            item: accessory,
                            collected: false
                        });
                    }
                }

                // Kolory (co 6 chunkÃ³w)
                if (chunkX % 6 === 0 && Math.random() > 0.4) {
                    const availableColors = itemDefinitions.colors.filter(c => !collectedItems.colors.includes(c.id));
                    if (availableColors.length > 0) {
                        const colorItem = availableColors[Math.floor(Math.random() * availableColors.length)];
                        itemsToCollect.push({
                            x: startX + chunkSize / 2 + (Math.random() - 0.5) * 450,
                            y: groundY - 42,
                            type: 'color',
                            item: colorItem,
                            collected: false
                        });
                    }
                }
            }
        }

        function startGame() {
            document.getElementById('start-screen').classList.remove('active');
            gameRunning = true;
            score = 0;
            worldOffset = 0;
            followingFriends = [];
            playerHistory = [];
            ground = [];
            candies = [];
            friendsToFind = [];
            decorations = [];
            flowers = [];
            trees = [];
            passingAnimals = [];
            dialogBubbles = [];
            itemsToCollect = [];
            generatedChunks.clear();

            player.x = 300;
            player.y = canvas.height - 150;
            player.velY = 0;

            for (let i = -1; i <= 3; i++) {
                generateChunk(i);
            }

            updateFriendsList();
            updateWardrobe();
            gameLoop();
        }

        function closeFriendMessage() {
            document.getElementById('victory-screen').classList.remove('active');
            if (!gameRunning) {
                gameRunning = true;
                gameLoop();
            }
        }

        // Rysowanie chmurki dialogowej
        function drawDialogBubble(x, y, text, fromLeft = true) {
            const padding = 15;
            const lineHeight = 20;
            const maxWidth = 200;

            // Podziel tekst na linie
            ctx.font = '16px Comic Sans MS';
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';

            words.forEach(word => {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            });
            if (currentLine) lines.push(currentLine);

            const bubbleWidth = maxWidth + padding * 2;
            const bubbleHeight = lines.length * lineHeight + padding * 2;
            const bubbleX = fromLeft ? x + 50 : x - bubbleWidth - 50;
            const bubbleY = y - bubbleHeight - 40;

            // Chmurka (biaÅ‚e tÅ‚o)
            ctx.fillStyle = '#FFF';
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(bubbleX, bubbleY, bubbleWidth, bubbleHeight, 15);
            ctx.fill();
            ctx.stroke();

            // Ogon chmurki (trÃ³jkÄ…cik)
            ctx.fillStyle = '#FFF';
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 3;
            ctx.beginPath();
            if (fromLeft) {
                ctx.moveTo(bubbleX + 20, bubbleY + bubbleHeight);
                ctx.lineTo(x + 30, y - 20);
                ctx.lineTo(bubbleX + 40, bubbleY + bubbleHeight);
            } else {
                ctx.moveTo(bubbleX + bubbleWidth - 40, bubbleY + bubbleHeight);
                ctx.lineTo(x - 30, y - 20);
                ctx.lineTo(bubbleX + bubbleWidth - 20, bubbleY + bubbleHeight);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Tekst
            ctx.fillStyle = '#FF1493';
            ctx.font = 'bold 16px Comic Sans MS';
            lines.forEach((line, i) => {
                ctx.fillText(line, bubbleX + padding, bubbleY + padding + (i + 1) * lineHeight);
            });
        }

        // Aktualizuj i rysuj chmurki dialogowe
        function updateAndDrawDialogBubbles() {
            const currentTime = Date.now();
            dialogBubbles = dialogBubbles.filter(bubble => currentTime - bubble.startTime < bubble.duration);

            dialogBubbles.forEach(bubble => {
                const screenX = bubble.x - worldOffset;
                if (screenX > -300 && screenX < canvas.width + 300) {
                    drawDialogBubble(screenX, bubble.y, bubble.text, bubble.fromLeft);
                }
            });
        }

        // Rysowanie realistycznego KicioroÅ¼ka
        function drawPlayer(x, y) {
            ctx.save();

            // Odbicie lustrzane gdy idzie w lewo
            if (!player.facingRight) {
                ctx.translate(x + player.width / 2, y + player.height / 2);
                ctx.scale(-1, 1);
                ctx.translate(-x - player.width / 2, -y - player.height / 2);
            }

            const walkOffset = Math.sin(player.walkCycle) * 3;
            player.tailSwing += 0.1;

            // Kolory z wybranego koloru futerka
            const colorDef = itemDefinitions.colors.find(c => c.id === player.equippedColor);
            const bodyColor = colorDef.bodyColor;
            const shadeColor = colorDef.shadeColor;

            // CieÅ„
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.ellipse(x + 30, y + 75, 25, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Ogon (dÅ‚ugi i puszyty)
            ctx.strokeStyle = shadeColor;
            ctx.lineWidth = 12;
            ctx.lineCap = 'round';
            const tailX = x + 10;
            const tailY = y + 40;
            const tailCurve = Math.sin(player.tailSwing) * 20;
            ctx.beginPath();
            ctx.moveTo(tailX, tailY);
            ctx.quadraticCurveTo(
                tailX - 30 + tailCurve, tailY - 20,
                tailX - 40, tailY - 40
            );
            ctx.stroke();

            // Koniec ogona (puszysty)
            ctx.fillStyle = shadeColor;
            ctx.beginPath();
            ctx.arc(tailX - 40, tailY - 40, 8, 0, Math.PI * 2);
            ctx.fill();

            // PELERYNA (rysowana ZA PLECAMI!)
            if (player.equippedOutfit === 'cape') {
                ctx.fillStyle = '#DC143C';
                ctx.beginPath();
                ctx.moveTo(x + 20, y + 30);
                ctx.lineTo(x, y + 70);
                ctx.lineTo(x + 40, y + 70);
                ctx.lineTo(x + 40, y + 30);
                ctx.fill();
                // ZÅ‚oty koÅ‚nierz
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(x + 15, y + 28, 30, 6);
            }

            // Tylne Å‚apki
            ctx.fillStyle = bodyColor;
            // Lewa tylna
            ctx.beginPath();
            ctx.ellipse(x + 15, y + 60 + walkOffset, 10, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            // Prawa tylna
            ctx.beginPath();
            ctx.ellipse(x + 35, y + 60 - walkOffset, 10, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // CiaÅ‚o (wiÄ™ksze, bardziej kocie)
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.ellipse(x + 30, y + 45, 28, 35, 0, 0, Math.PI * 2);
            ctx.fill();

            // Gradient na brzuszku (jaÅ›niejszy odcieÅ„)
            const gradient = ctx.createRadialGradient(x + 30, y + 50, 5, x + 30, y + 50, 25);
            // JaÅ›niejszy odcieÅ„ koloru ciaÅ‚a
            const lighterColor = bodyColor + (bodyColor.length === 4 ? 'E' : 'EE');
            gradient.addColorStop(0, lighterColor);
            gradient.addColorStop(1, bodyColor + '00');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.ellipse(x + 30, y + 50, 18, 25, 0, 0, Math.PI * 2);
            ctx.fill();

            // Przednie Å‚apki
            ctx.fillStyle = bodyColor;
            // Lewa przednia
            ctx.beginPath();
            ctx.ellipse(x + 20, y + 65 - walkOffset, 8, 18, 0, 0, Math.PI * 2);
            ctx.fill();
            // Prawa przednia
            ctx.beginPath();
            ctx.ellipse(x + 40, y + 65 + walkOffset, 8, 18, 0, 0, Math.PI * 2);
            ctx.fill();

            // Paluszki na Å‚apkach (ciemniejszy odcieÅ„)
            ctx.fillStyle = shadeColor;
            [20, 40].forEach(offsetX => {
                for (let i = -1; i <= 1; i++) {
                    ctx.beginPath();
                    ctx.arc(x + offsetX + i * 3, y + 75, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // GÅ‚owa (wiÄ™ksza, bardziej szczegÃ³Å‚owa)
            ctx.fillStyle = shadeColor;
            ctx.beginPath();
            ctx.arc(x + 35, y + 25, 22, 0, Math.PI * 2);
            ctx.fill();

            // Policzki (rumieÅ„ce - zawsze rÃ³Å¼owe)
            ctx.fillStyle = 'rgba(255, 105, 180, 0.3)';
            ctx.beginPath();
            ctx.arc(x + 20, y + 30, 8, 0, Math.PI * 2);
            ctx.arc(x + 50, y + 30, 8, 0, Math.PI * 2);
            ctx.fill();

            // Uszy (wiÄ™ksze)
            ctx.fillStyle = shadeColor;
            // Lewe ucho
            ctx.beginPath();
            ctx.moveTo(x + 20, y + 15);
            ctx.lineTo(x + 15, y);
            ctx.lineTo(x + 25, y + 10);
            ctx.fill();
            // Åšrodek lewego ucha (jaÅ›niejszy)
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.moveTo(x + 20, y + 13);
            ctx.lineTo(x + 18, y + 5);
            ctx.lineTo(x + 23, y + 11);
            ctx.fill();

            // Prawe ucho
            ctx.fillStyle = shadeColor;
            ctx.beginPath();
            ctx.moveTo(x + 50, y + 15);
            ctx.lineTo(x + 55, y);
            ctx.lineTo(x + 45, y + 10);
            ctx.fill();
            // Åšrodek prawego ucha (jaÅ›niejszy)
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.moveTo(x + 50, y + 13);
            ctx.lineTo(x + 52, y + 5);
            ctx.lineTo(x + 47, y + 11);
            ctx.fill();

            // RÃ³g jednoroÅ¼ca (piÄ™kny, spiralny, w wybranym kolorze! DUÅ»O WIÄ˜KSZY - 2x!)
            const hornDef = itemDefinitions.horns.find(h => h.id === player.equippedHorn);

            if (hornDef.id === 'rainbow') {
                // TÄ™czowy rÃ³g (gradient) - 2x wiÄ™kszy, na czole
                const rainbowGradient = ctx.createLinearGradient(x + 29, y - 20, x + 41, y + 10);
                rainbowGradient.addColorStop(0, '#FF0000');
                rainbowGradient.addColorStop(0.17, '#FF7F00');
                rainbowGradient.addColorStop(0.33, '#FFFF00');
                rainbowGradient.addColorStop(0.5, '#00FF00');
                rainbowGradient.addColorStop(0.67, '#0000FF');
                rainbowGradient.addColorStop(0.83, '#4B0082');
                rainbowGradient.addColorStop(1, '#9400D3');
                ctx.fillStyle = rainbowGradient;
            } else {
                ctx.fillStyle = hornDef.color;
            }

            // WiÄ™kszy trÃ³jkÄ…t rogu - na czole zamiast na nosie
            ctx.beginPath();
            ctx.moveTo(x + 35, y - 20);  // GÃ³ra znacznie wyÅ¼ej (na czole)
            ctx.lineTo(x + 29, y + 10);  // Lewa krawÄ™dÅº - podstawa na czole
            ctx.lineTo(x + 41, y + 10);  // Prawa krawÄ™dÅº - podstawa na czole
            ctx.fill();

            // Spirala na rogu (ciemniejszy odcieÅ„) - wiÄ™ksza
            if (hornDef.id === 'rainbow') {
                ctx.strokeStyle = '#9400D3';
            } else if (hornDef.color) {
                // Ciemniejszy odcieÅ„ koloru rogu
                ctx.strokeStyle = hornDef.color.replace(/[0-9A-F]{2}([0-9A-F]{2})([0-9A-F]{2})/i, (match, p1, p2) => {
                    return match.slice(0, -6) +
                           Math.max(0, parseInt(p1, 16) - 30).toString(16).padStart(2, '0') +
                           Math.max(0, parseInt(p2, 16) - 30).toString(16).padStart(2, '0');
                });
            } else {
                ctx.strokeStyle = '#FFA500';
            }

            ctx.lineWidth = 3;  // Grubsza spirala
            for (let i = 0; i < 5; i++) {  // WiÄ™cej spiral (5 zamiast 3)
                ctx.beginPath();
                ctx.arc(x + 35, y - 15 + i * 6, 5, 0, Math.PI);  // Spirale wyÅ¼ej, na czole
                ctx.stroke();
            }

            // Blask na rogu - wiÄ™kszy i wyÅ¼ej
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(x + 37, y - 13, 4, 0, Math.PI * 2);
            ctx.fill();

            // Oczy (duÅ¼e, sÅ‚odkie)
            ctx.fillStyle = '#000';
            // Lewe oko
            ctx.beginPath();
            ctx.ellipse(x + 26, y + 23, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            // Prawe oko
            ctx.beginPath();
            ctx.ellipse(x + 44, y + 23, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // BÅ‚yski w oczach
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x + 27, y + 22, 2, 0, Math.PI * 2);
            ctx.arc(x + 45, y + 22, 2, 0, Math.PI * 2);
            ctx.fill();

            // Nosek (trÃ³jkÄ…cik)
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.moveTo(x + 35, y + 28);
            ctx.lineTo(x + 33, y + 32);
            ctx.lineTo(x + 37, y + 32);
            ctx.fill();

            // Buzia (uÅ›miech)
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(x + 35, y + 32, 6, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // WÄ…sy (dÅ‚ugie)
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            // Lewe wÄ…sy
            ctx.beginPath();
            ctx.moveTo(x + 35, y + 30);
            ctx.lineTo(x + 15, y + 26);
            ctx.moveTo(x + 35, y + 30);
            ctx.lineTo(x + 15, y + 32);
            ctx.stroke();
            // Prawe wÄ…sy
            ctx.beginPath();
            ctx.moveTo(x + 35, y + 30);
            ctx.lineTo(x + 55, y + 26);
            ctx.moveTo(x + 35, y + 30);
            ctx.lineTo(x + 55, y + 32);
            ctx.stroke();

            // Ubranka NA CIELE (WIÄ˜KSZE I BARDZIEJ WIDOCZNE!)
            if (player.equippedOutfit) {
                const outfitDef = itemDefinitions.outfits.find(o => o.id === player.equippedOutfit);

                if (outfitDef.id === 'cape') {
                    // Gwiazda na pelerynie (peleryna juÅ¼ narysowana wczeÅ›niej)
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText('â­', x + 20, y + 52);
                } else if (outfitDef.id === 'dress') {
                    // Sukienka ksiÄ™Å¼niczki (RÃ“Å»OWA, ROZKLOSZOWANA!)
                    // GÃ³ra sukienki (dopasowana)
                    ctx.fillStyle = '#FF1493';
                    ctx.fillRect(x + 15, y + 38, 30, 15);

                    // DÃ³Å‚ sukienki (rozkloszowany trapez)
                    ctx.beginPath();
                    ctx.moveTo(x + 15, y + 53); // lewy gÃ³rny rÃ³g
                    ctx.lineTo(x + 5, y + 72);  // lewy dolny rÃ³g (szerszy)
                    ctx.lineTo(x + 55, y + 72); // prawy dolny rÃ³g (szerszy)
                    ctx.lineTo(x + 45, y + 53); // prawy gÃ³rny rÃ³g
                    ctx.closePath();
                    ctx.fill();

                    // Wzorki - biaÅ‚e kropki na sukience
                    ctx.fillStyle = '#FFF';
                    for (let i = 0; i < 8; i++) {
                        for (let j = 0; j < 2; j++) {
                            ctx.beginPath();
                            ctx.arc(x + 12 + i * 6, y + 58 + j * 8, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Pasek (zÅ‚oty)
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(x + 14, y + 52, 32, 4);

                    // Kokarda na pasku
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(x + 25, y + 54, 4, 0, Math.PI * 2);
                    ctx.arc(x + 35, y + 54, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + 30, y + 54, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (outfitDef.id === 'scarf') {
                    // Szalik (GRUBY I KOLOROWY!)
                    ctx.strokeStyle = '#FF1493';
                    ctx.lineWidth = 12;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(x + 15, y + 32);
                    ctx.lineTo(x + 50, y + 35);
                    ctx.stroke();
                    // Paski na szaliku
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(x + 20 + i * 10, y + 30);
                        ctx.lineTo(x + 25 + i * 10, y + 36);
                        ctx.stroke();
                    }
                    // FrÄ™dzle
                    ctx.strokeStyle = '#FF1493';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(x + 48, y + 36);
                    ctx.lineTo(x + 52, y + 46);
                    ctx.moveTo(x + 52, y + 36);
                    ctx.lineTo(x + 56, y + 48);
                    ctx.stroke();
                } else if (outfitDef.id === 'shirt') {
                    // Koszulka (NIEBIESKA!)
                    ctx.fillStyle = '#1E90FF';
                    ctx.fillRect(x + 12, y + 38, 36, 28);
                    // KoÅ‚nierzyk
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.moveTo(x + 25, y + 38);
                    ctx.lineTo(x + 20, y + 42);
                    ctx.lineTo(x + 30, y + 42);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(x + 35, y + 38);
                    ctx.lineTo(x + 40, y + 42);
                    ctx.lineTo(x + 30, y + 42);
                    ctx.fill();
                    // Kieszonka
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x + 22, y + 50, 8, 8);
                } else if (outfitDef.id === 'sweater') {
                    // Sweterek (FIOLETOWY!)
                    ctx.fillStyle = '#9370DB';
                    ctx.fillRect(x + 10, y + 36, 40, 32);
                    // Paski
                    ctx.fillStyle = '#E6E6FA';
                    ctx.fillRect(x + 10, y + 44, 40, 4);
                    ctx.fillRect(x + 10, y + 56, 40, 4);
                    // Guziki (DUÅ»E!)
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(x + 30, y + 42, 3, 0, Math.PI * 2);
                    ctx.arc(x + 30, y + 51, 3, 0, Math.PI * 2);
                    ctx.arc(x + 30, y + 60, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Akcesoria (WIÄ˜KSZE I WYRAÅ¹NIEJSZE!)
            if (player.equippedAccessory) {
                const accessoryDef = itemDefinitions.accessories.find(a => a.id === player.equippedAccessory);

                if (accessoryDef.id === 'crown') {
                    // Korona (DUÅ»A!)
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.moveTo(x + 20, y + 3);
                    ctx.lineTo(x + 22, y - 8);
                    ctx.lineTo(x + 27, y);
                    ctx.lineTo(x + 30, y - 10);
                    ctx.lineTo(x + 33, y);
                    ctx.lineTo(x + 38, y - 8);
                    ctx.lineTo(x + 40, y + 3);
                    ctx.lineTo(x + 35, y + 6);
                    ctx.lineTo(x + 25, y + 6);
                    ctx.closePath();
                    ctx.fill();
                    // Klejnoty (DUÅ»E!)
                    ctx.fillStyle = '#FF1493';
                    ctx.beginPath();
                    ctx.arc(x + 27, y - 2, 3, 0, Math.PI * 2);
                    ctx.arc(x + 33, y - 2, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#00FF00';
                    ctx.beginPath();
                    ctx.arc(x + 30, y - 5, 4, 0, Math.PI * 2);
                    ctx.fill();
                    // ObwÃ³dka
                    ctx.strokeStyle = '#B8860B';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + 20, y + 3);
                    ctx.lineTo(x + 40, y + 3);
                    ctx.stroke();
                } else if (accessoryDef.id === 'bow') {
                    // Kokarda (DUÅ»A!)
                    ctx.fillStyle = '#FF1493';
                    ctx.beginPath();
                    ctx.arc(x + 24, y + 6, 9, 0, Math.PI * 2);
                    ctx.arc(x + 46, y + 6, 9, 0, Math.PI * 2);
                    ctx.fill();
                    // Åšrodek kokardy
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(x + 30, y + 2, 10, 8);
                    // Wzory kropki
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(x + 24, y + 4, 2, 0, Math.PI * 2);
                    ctx.arc(x + 46, y + 4, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (accessoryDef.id === 'glasses') {
                    // Okulary (WIÄ˜KSZE!)
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    // Lewe szkÅ‚o
                    ctx.beginPath();
                    ctx.arc(x + 24, y + 23, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    // Prawe szkÅ‚o
                    ctx.beginPath();
                    ctx.arc(x + 46, y + 23, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    // Mostek
                    ctx.beginPath();
                    ctx.moveTo(x + 32, y + 23);
                    ctx.lineTo(x + 38, y + 23);
                    ctx.stroke();
                    // Zauszniki
                    ctx.beginPath();
                    ctx.moveTo(x + 16, y + 23);
                    ctx.lineTo(x + 12, y + 25);
                    ctx.moveTo(x + 54, y + 23);
                    ctx.lineTo(x + 58, y + 25);
                    ctx.stroke();
                    // BÅ‚ysk na szkÅ‚ach
                    ctx.fillStyle = 'rgba(135, 206, 250, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x + 24, y + 23, 7, 0, Math.PI * 2);
                    ctx.arc(x + 46, y + 23, 7, 0, Math.PI * 2);
                    ctx.fill();
                } else if (accessoryDef.id === 'hat') {
                    // Kapelusz (WIÄ˜KSZY!)
                    ctx.fillStyle = '#654321';
                    // Korpus
                    ctx.fillRect(x + 20, y - 4, 30, 12);
                    // Rondo
                    ctx.beginPath();
                    ctx.ellipse(x + 35, y + 8, 24, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // WstÄ…Å¼ka
                    ctx.fillStyle = '#8B0000';
                    ctx.fillRect(x + 20, y + 4, 30, 4);
                } else if (accessoryDef.id === 'flower') {
                    // Kwiatek (DUÅ»Y!)
                    ctx.fillStyle = '#FF69B4';
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const px = x + 24 + Math.cos(angle) * 9;
                        const py = y + 6 + Math.sin(angle) * 9;
                        ctx.beginPath();
                        ctx.arc(px, py, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // Åšrodek kwiatka
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(x + 24, y + 6, 5, 0, Math.PI * 2);
                    ctx.fill();
                    // ÅodyÅ¼ka
                    ctx.strokeStyle = '#228B22';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x + 24, y + 11);
                    ctx.lineTo(x + 24, y + 18);
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        // Rysowanie psa (TÄ™czowy Piesek)
        function drawDog(x, y, scale = 1) {
            const s = scale;
            // Ogon
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x - 15 * s, y + 30 * s, 12 * s, 0, Math.PI * 2);
            ctx.fill();

            // CiaÅ‚o
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.ellipse(x, y + 30 * s, 18 * s, 25 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Åapki
            ctx.fillStyle = '#FFA500';
            ctx.fillRect(x - 12 * s, y + 50 * s, 8 * s, 18 * s);
            ctx.fillRect(x + 4 * s, y + 50 * s, 8 * s, 18 * s);

            // GÅ‚Ã³wka
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x, y + 10 * s, 15 * s, 0, Math.PI * 2);
            ctx.fill();

            // Uszy
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.ellipse(x - 12 * s, y + 8 * s, 6 * s, 12 * s, -0.3, 0, Math.PI * 2);
            ctx.ellipse(x + 12 * s, y + 8 * s, 6 * s, 12 * s, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 5 * s, y + 8 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(x + 5 * s, y + 8 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // BÅ‚ysk w oczach
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 4 * s, y + 7 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.arc(x + 6 * s, y + 7 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y + 15 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // JÄ™zyk
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.ellipse(x, y + 20 * s, 3 * s, 5 * s, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie krÃ³liczka
        function drawRabbit(x, y, scale = 1) {
            const s = scale;
            // Ogon (puszek)
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.arc(x - 12 * s, y + 40 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();

            // CiaÅ‚o
            ctx.fillStyle = '#FFC0CB';
            ctx.beginPath();
            ctx.ellipse(x, y + 35 * s, 16 * s, 22 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Åapki
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.ellipse(x - 10 * s, y + 55 * s, 7 * s, 10 * s, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 10 * s, y + 55 * s, 7 * s, 10 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // GÅ‚Ã³wka
            ctx.fillStyle = '#FFC0CB';
            ctx.beginPath();
            ctx.arc(x, y + 15 * s, 13 * s, 0, Math.PI * 2);
            ctx.fill();

            // DÅ‚ugie uszy
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.ellipse(x - 8 * s, y - 5 * s, 5 * s, 20 * s, -0.2, 0, Math.PI * 2);
            ctx.ellipse(x + 8 * s, y - 5 * s, 5 * s, 20 * s, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Åšrodek ucha
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.ellipse(x - 8 * s, y - 5 * s, 3 * s, 15 * s, -0.2, 0, Math.PI * 2);
            ctx.ellipse(x + 8 * s, y - 5 * s, 3 * s, 15 * s, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 5 * s, y + 13 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(x + 5 * s, y + 13 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.moveTo(x, y + 18 * s);
            ctx.lineTo(x - 2 * s, y + 21 * s);
            ctx.lineTo(x + 2 * s, y + 21 * s);
            ctx.fill();
        }

        // Rysowanie misia
        function drawBear(x, y, scale = 1) {
            const s = scale;
            // CiaÅ‚o
            ctx.fillStyle = '#DDA0DD';
            ctx.beginPath();
            ctx.ellipse(x, y + 35 * s, 20 * s, 28 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek
            ctx.fillStyle = '#E6B8E6';
            ctx.beginPath();
            ctx.ellipse(x, y + 40 * s, 14 * s, 20 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Åapki
            ctx.fillStyle = '#DDA0DD';
            ctx.beginPath();
            ctx.ellipse(x - 18 * s, y + 30 * s, 8 * s, 12 * s, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 18 * s, y + 30 * s, 8 * s, 12 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nogi
            ctx.fillStyle = '#DDA0DD';
            ctx.fillRect(x - 12 * s, y + 58 * s, 10 * s, 12 * s);
            ctx.fillRect(x + 2 * s, y + 58 * s, 10 * s, 12 * s);

            // GÅ‚Ã³wka
            ctx.fillStyle = '#DDA0DD';
            ctx.beginPath();
            ctx.arc(x, y + 12 * s, 16 * s, 0, Math.PI * 2);
            ctx.fill();

            // Uszy (okrÄ…gÅ‚e)
            ctx.fillStyle = '#BA7FBA';
            ctx.beginPath();
            ctx.arc(x - 12 * s, y + 2 * s, 8 * s, 0, Math.PI * 2);
            ctx.arc(x + 12 * s, y + 2 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();

            // Pysk
            ctx.fillStyle = '#E6B8E6';
            ctx.beginPath();
            ctx.ellipse(x, y + 16 * s, 10 * s, 8 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 6 * s, y + 10 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(x + 6 * s, y + 10 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y + 18 * s, 4 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie baranka
        function drawSheep(x, y, scale = 1) {
            const s = scale;
            // WeÅ‚niane kulki na ciele
            ctx.fillStyle = '#E0C3FC';
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const rx = Math.cos(angle) * 15 * s;
                const ry = Math.sin(angle) * 18 * s;
                ctx.beginPath();
                ctx.arc(x + rx, y + 35 * s + ry, 10 * s, 0, Math.PI * 2);
                ctx.fill();
            }

            // GÅ‚Ã³wne ciaÅ‚o
            ctx.fillStyle = '#E0C3FC';
            ctx.beginPath();
            ctx.ellipse(x, y + 35 * s, 18 * s, 22 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nogi
            ctx.fillStyle = '#D8BFD8';
            ctx.fillRect(x - 14 * s, y + 52 * s, 7 * s, 16 * s);
            ctx.fillRect(x - 3 * s, y + 52 * s, 7 * s, 16 * s);
            ctx.fillRect(x + 8 * s, y + 52 * s, 7 * s, 16 * s);

            // GÅ‚Ã³wka
            ctx.fillStyle = '#F0E6FF';
            ctx.beginPath();
            ctx.ellipse(x, y + 12 * s, 12 * s, 14 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // WeÅ‚niane kulki na gÅ‚owie
            ctx.fillStyle = '#E0C3FC';
            ctx.beginPath();
            ctx.arc(x - 8 * s, y + 5 * s, 7 * s, 0, Math.PI * 2);
            ctx.arc(x + 8 * s, y + 5 * s, 7 * s, 0, Math.PI * 2);
            ctx.arc(x, y + 0, 7 * s, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 4 * s, y + 12 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(x + 4 * s, y + 12 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y + 18 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie delfina
        function drawDolphin(x, y, scale = 1) {
            const s = scale;
            // CiaÅ‚o
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.ellipse(x, y + 30 * s, 15 * s, 25 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek
            ctx.fillStyle = '#B0E0E6';
            ctx.beginPath();
            ctx.ellipse(x, y + 35 * s, 10 * s, 18 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // PÅ‚etwy boczne
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.ellipse(x - 15 * s, y + 30 * s, 10 * s, 6 * s, -0.5, 0, Math.PI * 2);
            ctx.ellipse(x + 15 * s, y + 30 * s, 10 * s, 6 * s, 0.5, 0, Math.PI * 2);
            ctx.fill();

            // GÅ‚Ã³wka z dziobem
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.arc(x, y + 10 * s, 13 * s, 0, Math.PI * 2);
            ctx.fill();

            // DziÃ³b
            ctx.fillStyle = '#6CA6CD';
            ctx.beginPath();
            ctx.ellipse(x, y + 2 * s, 8 * s, 6 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 5 * s, y + 8 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(x + 5 * s, y + 8 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // BÅ‚ysk w oczach
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 4 * s, y + 7 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.arc(x + 6 * s, y + 7 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.fill();

            // Ogon
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.moveTo(x - 10 * s, y + 55 * s);
            ctx.lineTo(x, y + 50 * s);
            ctx.lineTo(x + 10 * s, y + 55 * s);
            ctx.fill();

            // PÅ‚etwa grzbietowa
            ctx.fillStyle = '#6CA6CD';
            ctx.beginPath();
            ctx.moveTo(x - 5 * s, y + 25 * s);
            ctx.lineTo(x, y + 15 * s);
            ctx.lineTo(x + 5 * s, y + 25 * s);
            ctx.fill();
        }

        // Rysowanie lisa
        function drawFox(x, y, scale = 1) {
            const s = scale;
            // Puszysty ogon
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.arc(x - 18 * s, y + 40 * s, 20 * s, 0, Math.PI * 2);
            ctx.fill();

            // BiaÅ‚y czubek ogona
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 22 * s, y + 35 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();

            // CiaÅ‚o
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.ellipse(x, y + 35 * s, 18 * s, 25 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek (biaÅ‚e)
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.ellipse(x, y + 40 * s, 12 * s, 18 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nogi
            ctx.fillStyle = '#FF8C00';
            ctx.fillRect(x - 12 * s, y + 55 * s, 8 * s, 14 * s);
            ctx.fillRect(x + 4 * s, y + 55 * s, 8 * s, 14 * s);

            // BiaÅ‚e Å‚apki
            ctx.fillStyle = '#FFF';
            ctx.fillRect(x - 12 * s, y + 65 * s, 8 * s, 4 * s);
            ctx.fillRect(x + 4 * s, y + 65 * s, 8 * s, 4 * s);

            // GÅ‚Ã³wka
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.arc(x, y + 12 * s, 14 * s, 0, Math.PI * 2);
            ctx.fill();

            // BiaÅ‚e policzki/pysk
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.ellipse(x, y + 18 * s, 10 * s, 8 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Uszy (trÃ³jkÄ…tne)
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.moveTo(x - 10 * s, y + 5 * s);
            ctx.lineTo(x - 14 * s, y - 8 * s);
            ctx.lineTo(x - 6 * s, y + 2 * s);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x + 10 * s, y + 5 * s);
            ctx.lineTo(x + 14 * s, y - 8 * s);
            ctx.lineTo(x + 6 * s, y + 2 * s);
            ctx.fill();

            // BiaÅ‚e Å›rodki uszu
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.moveTo(x - 10 * s, y + 3 * s);
            ctx.lineTo(x - 12 * s, y - 4 * s);
            ctx.lineTo(x - 8 * s, y + 1 * s);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x + 10 * s, y + 3 * s);
            ctx.lineTo(x + 12 * s, y - 4 * s);
            ctx.lineTo(x + 8 * s, y + 1 * s);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 5 * s, y + 10 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(x + 5 * s, y + 10 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // BÅ‚ysk w oczach
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 4 * s, y + 9 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.arc(x + 6 * s, y + 9 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y + 17 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie pandy
        function drawPanda(x, y, scale = 1) {
            const s = scale;
            // CiaÅ‚o (biaÅ‚e)
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.ellipse(x, y + 38 * s, 20 * s, 28 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Czarna Å‚ata na brzuchu
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(x, y + 45 * s, 12 * s, 15 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Åapy (czarne)
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(x - 18 * s, y + 32 * s, 9 * s, 14 * s, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 18 * s, y + 32 * s, 9 * s, 14 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nogi (czarne)
            ctx.fillStyle = '#000';
            ctx.fillRect(x - 14 * s, y + 60 * s, 11 * s, 12 * s);
            ctx.fillRect(x + 3 * s, y + 60 * s, 11 * s, 12 * s);

            // GÅ‚Ã³wka (biaÅ‚a)
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x, y + 14 * s, 17 * s, 0, Math.PI * 2);
            ctx.fill();

            // Uszy (czarne, okrÄ…gÅ‚e)
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 13 * s, y + 3 * s, 9 * s, 0, Math.PI * 2);
            ctx.arc(x + 13 * s, y + 3 * s, 9 * s, 0, Math.PI * 2);
            ctx.fill();

            // Oczy z czarnymi plamami
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(x - 7 * s, y + 12 * s, 8 * s, 10 * s, -0.2, 0, Math.PI * 2);
            ctx.ellipse(x + 7 * s, y + 12 * s, 8 * s, 10 * s, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // BiaÅ‚e gaÅ‚ki oczne
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 7 * s, y + 13 * s, 4 * s, 0, Math.PI * 2);
            ctx.arc(x + 7 * s, y + 13 * s, 4 * s, 0, Math.PI * 2);
            ctx.fill();

            // Å¹renice
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 6 * s, y + 13 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(x + 8 * s, y + 13 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y + 20 * s, 4 * s, 0, Math.PI * 2);
            ctx.fill();

            // UÅ›miech
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.arc(x, y + 22 * s, 6 * s, 0.2, Math.PI - 0.2);
            ctx.stroke();
        }

        // Rysowanie jednoroÅ¼ca (siostrzyczka)
        function drawUnicorn(x, y, scale = 1) {
            const s = scale;
            // Ogon (tÄ™czowy!)
            const tailGradient = ctx.createLinearGradient(x - 25 * s, y + 30 * s, x - 35 * s, y + 50 * s);
            tailGradient.addColorStop(0, '#FF69B4');
            tailGradient.addColorStop(0.5, '#E0C3FC');
            tailGradient.addColorStop(1, '#87CEEB');
            ctx.strokeStyle = tailGradient;
            ctx.lineWidth = 15 * s;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x - 10 * s, y + 40 * s);
            ctx.quadraticCurveTo(x - 25 * s, y + 35 * s, x - 35 * s, y + 50 * s);
            ctx.stroke();

            // CiaÅ‚o
            ctx.fillStyle = '#E0B0FF';
            ctx.beginPath();
            ctx.ellipse(x, y + 38 * s, 20 * s, 28 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek (jaÅ›niejszy)
            ctx.fillStyle = '#F0E0FF';
            ctx.beginPath();
            ctx.ellipse(x, y + 42 * s, 14 * s, 20 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nogi
            ctx.fillStyle = '#E0B0FF';
            ctx.fillRect(x - 14 * s, y + 60 * s, 10 * s, 16 * s);
            ctx.fillRect(x + 4 * s, y + 60 * s, 10 * s, 16 * s);

            // Kopytka (zÅ‚ote)
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(x - 14 * s, y + 72 * s, 10 * s, 4 * s);
            ctx.fillRect(x + 4 * s, y + 72 * s, 10 * s, 4 * s);

            // GÅ‚Ã³wka
            ctx.fillStyle = '#E0B0FF';
            ctx.beginPath();
            ctx.arc(x, y + 14 * s, 16 * s, 0, Math.PI * 2);
            ctx.fill();

            // Grzywka (tÄ™czowa!)
            const maneGradient = ctx.createLinearGradient(x - 15 * s, y, x + 15 * s, y + 20 * s);
            maneGradient.addColorStop(0, '#FF69B4');
            maneGradient.addColorStop(0.33, '#FFD700');
            maneGradient.addColorStop(0.67, '#87CEEB');
            maneGradient.addColorStop(1, '#E0C3FC');
            ctx.fillStyle = maneGradient;
            ctx.beginPath();
            ctx.arc(x - 12 * s, y + 5 * s, 10 * s, 0, Math.PI * 2);
            ctx.arc(x - 5 * s, y + 2 * s, 10 * s, 0, Math.PI * 2);
            ctx.arc(x + 5 * s, y + 2 * s, 10 * s, 0, Math.PI * 2);
            ctx.arc(x + 12 * s, y + 5 * s, 10 * s, 0, Math.PI * 2);
            ctx.fill();

            // RÃ³g (tÄ™czowy gradient)
            const hornGradient = ctx.createLinearGradient(x - 2 * s, y - 10 * s, x + 2 * s, y + 10 * s);
            hornGradient.addColorStop(0, '#FFD700');
            hornGradient.addColorStop(0.5, '#FF69B4');
            hornGradient.addColorStop(1, '#E0C3FC');
            ctx.fillStyle = hornGradient;
            ctx.beginPath();
            ctx.moveTo(x, y - 10 * s);
            ctx.lineTo(x - 4 * s, y + 5 * s);
            ctx.lineTo(x + 4 * s, y + 5 * s);
            ctx.fill();

            // Spirala na rogu
            ctx.strokeStyle = '#9370DB';
            ctx.lineWidth = 2 * s;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(x, y - 5 * s + i * 4 * s, 3 * s, 0, Math.PI);
                ctx.stroke();
            }

            // Oczy (duÅ¼e, bajkowe)
            ctx.fillStyle = '#8B008B';
            ctx.beginPath();
            ctx.arc(x - 6 * s, y + 13 * s, 4 * s, 0, Math.PI * 2);
            ctx.arc(x + 6 * s, y + 13 * s, 4 * s, 0, Math.PI * 2);
            ctx.fill();

            // BÅ‚yski w oczach
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 5 * s, y + 12 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(x + 7 * s, y + 12 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.arc(x, y + 20 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // Gwiazdki wokÃ³Å‚ (magiczne!)
            ctx.fillStyle = '#FFD700';
            [[x - 22 * s, y + 10 * s], [x + 22 * s, y + 10 * s], [x, y - 15 * s]].forEach(([sx, sy]) => {
                ctx.beginPath();
                for (let j = 0; j < 5; j++) {
                    const angle = (j * 2 * Math.PI / 5) - Math.PI / 2;
                    const r = j % 2 === 0 ? 4 * s : 2 * s;
                    const px = sx + Math.cos(angle) * r;
                    const py = sy + Math.sin(angle) * r;
                    if (j === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
            });
        }

        // Rysowanie Å¼abki
        function drawFrog(x, y, scale = 1) {
            const s = scale;
            // CiaÅ‚o (zielone)
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.ellipse(x, y + 40 * s, 20 * s, 22 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek (jaÅ›niejszy)
            ctx.fillStyle = '#B0FFB0';
            ctx.beginPath();
            ctx.ellipse(x, y + 45 * s, 14 * s, 16 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tylne nogi (duÅ¼e, Å¼abie)
            ctx.fillStyle = '#90EE90';
            // Lewa noga
            ctx.beginPath();
            ctx.ellipse(x - 20 * s, y + 55 * s, 12 * s, 8 * s, -0.5, 0, Math.PI * 2);
            ctx.fill();
            // Stopa lewa
            ctx.beginPath();
            ctx.ellipse(x - 28 * s, y + 62 * s, 10 * s, 6 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Prawa noga
            ctx.beginPath();
            ctx.ellipse(x + 20 * s, y + 55 * s, 12 * s, 8 * s, 0.5, 0, Math.PI * 2);
            ctx.fill();
            // Stopa prawa
            ctx.beginPath();
            ctx.ellipse(x + 28 * s, y + 62 * s, 10 * s, 6 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Palce na stopach
            ctx.fillStyle = '#7FBF7F';
            for (let i = -1; i <= 1; i++) {
                ctx.beginPath();
                ctx.ellipse(x - 28 * s + i * 5 * s, y + 66 * s, 2 * s, 4 * s, 0, 0, Math.PI * 2);
                ctx.ellipse(x + 28 * s + i * 5 * s, y + 66 * s, 2 * s, 4 * s, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Przednie Å‚apki (maÅ‚e)
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.ellipse(x - 15 * s, y + 38 * s, 6 * s, 10 * s, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 15 * s, y + 38 * s, 6 * s, 10 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // GÅ‚Ã³wka (szeroka)
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.ellipse(x, y + 18 * s, 18 * s, 16 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Oczy (wypukÅ‚e!)
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x - 10 * s, y + 12 * s, 8 * s, 0, Math.PI * 2);
            ctx.arc(x + 10 * s, y + 12 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();

            // Å¹renice
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(x - 10 * s, y + 13 * s, 3 * s, 5 * s, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 10 * s, y + 13 * s, 3 * s, 5 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // BÅ‚yski w oczach
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 9 * s, y + 11 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(x + 11 * s, y + 11 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Buzia (szeroki uÅ›miech)
            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.arc(x, y + 22 * s, 12 * s, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // Policzki (rÃ³Å¼owe)
            ctx.fillStyle = 'rgba(255, 192, 203, 0.4)';
            ctx.beginPath();
            ctx.arc(x - 16 * s, y + 20 * s, 5 * s, 0, Math.PI * 2);
            ctx.arc(x + 16 * s, y + 20 * s, 5 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie motyla (jako przyjaciel - wiÄ™kszy)
        function drawButterflyFriend(x, y, scale = 1) {
            const s = scale;
            // GÃ³rne skrzydÅ‚a (duÅ¼e, kolorowe)
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.ellipse(x - 18 * s, y + 20 * s, 22 * s, 28 * s, -0.3, 0, Math.PI * 2);
            ctx.ellipse(x + 18 * s, y + 20 * s, 22 * s, 28 * s, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Dolne skrzydÅ‚a
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.ellipse(x - 15 * s, y + 50 * s, 18 * s, 22 * s, -0.2, 0, Math.PI * 2);
            ctx.ellipse(x + 15 * s, y + 50 * s, 18 * s, 22 * s, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Wzory na gÃ³rnych skrzydÅ‚ach
            ctx.fillStyle = '#FFF';
            [[x - 18 * s, y + 15 * s], [x + 18 * s, y + 15 * s]].forEach(([px, py]) => {
                ctx.beginPath();
                ctx.arc(px, py, 6 * s, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.fillStyle = '#FFD700';
            [[x - 18 * s, y + 28 * s], [x + 18 * s, y + 28 * s]].forEach(([px, py]) => {
                ctx.beginPath();
                ctx.arc(px, py, 5 * s, 0, Math.PI * 2);
                ctx.fill();
            });

            // Wzory na dolnych skrzydÅ‚ach
            ctx.fillStyle = '#E0C3FC';
            [[x - 15 * s, y + 50 * s], [x + 15 * s, y + 50 * s]].forEach(([px, py]) => {
                ctx.beginPath();
                ctx.arc(px, py, 4 * s, 0, Math.PI * 2);
                ctx.fill();
            });

            // CiaÅ‚o (grube, puszyste)
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - 5 * s, y + 10 * s, 10 * s, 50 * s, 0, 0, Math.PI * 2);

            // GÅ‚Ã³wka
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y + 5 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();

            // Oczka
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 3 * s, y + 5 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(x + 3 * s, y + 5 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // CzuÅ‚ki (dÅ‚ugie, z kulkami)
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.moveTo(x - 4 * s, y);
            ctx.lineTo(x - 10 * s, y - 15 * s);
            ctx.moveTo(x + 4 * s, y);
            ctx.lineTo(x + 10 * s, y - 15 * s);
            ctx.stroke();

            // Kulki na czuÅ‚kach
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.arc(x - 10 * s, y - 15 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(x + 10 * s, y - 15 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // BÅ‚ysk na skrzydÅ‚ach (magiczny efekt)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            [[x - 22 * s, y + 12 * s], [x + 22 * s, y + 12 * s]].forEach(([px, py]) => {
                ctx.beginPath();
                ctx.arc(px, py, 4 * s, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Funkcja wyboru rysowania przyjaciela
        function drawFriend(friend, x, y, scale = 1) {
            ctx.save();

            switch(friend.emoji) {
                case 'ğŸ¶':
                    drawDog(x, y, scale);
                    break;
                case 'ğŸ°':
                    drawRabbit(x, y, scale);
                    break;
                case 'ğŸ»':
                    drawBear(x, y, scale);
                    break;
                case 'ğŸ‘':
                    drawSheep(x, y, scale);
                    break;
                case 'ğŸ¬':
                    drawDolphin(x, y, scale);
                    break;
                case 'ğŸ¦Š':
                    drawFox(x, y, scale);
                    break;
                case 'ğŸ¼':
                    drawPanda(x, y, scale);
                    break;
                case 'ğŸ¦„':
                    drawUnicorn(x, y, scale);
                    break;
                case 'ğŸ¸':
                    drawFrog(x, y, scale);
                    break;
                case 'ğŸ¦‹':
                    drawButterflyFriend(x, y, scale);
                    break;
                default:
                    // Dla pozostaÅ‚ych uÅ¼yj prostego ksztaÅ‚tu
                    ctx.fillStyle = friend.color;
                    ctx.beginPath();
                    ctx.ellipse(x, y + 30 * scale, 18 * scale, 25 * scale, 0, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = friend.color;
                    ctx.beginPath();
                    ctx.arc(x, y + 10 * scale, 15 * scale, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(x - 5 * scale, y + 10 * scale, 2 * scale, 0, Math.PI * 2);
                    ctx.arc(x + 5 * scale, y + 10 * scale, 2 * scale, 0, Math.PI * 2);
                    ctx.fill();
            }

            ctx.restore();
        }

        // TÅ‚o
        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.6, '#FFE5F1');
            gradient.addColorStop(1, '#FFF4E0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // SÅ‚oÅ„ce
            const sunX = 200 - worldOffset * 0.1;
            if (sunX > -100 && sunX < canvas.width + 100) {
                ctx.fillStyle = 'rgba(255, 255, 100, 0.6)';
                ctx.beginPath();
                ctx.arc(sunX, 100, 60, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#FFFF00';
                ctx.beginPath();
                ctx.arc(sunX, 100, 50, 0, Math.PI * 2);
                ctx.fill();
            }

            // TÄ™cza
            const rainbowX = 600 - worldOffset * 0.2;
            if (rainbowX > -500 && rainbowX < canvas.width + 500) {
                const rainbowColors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
                ctx.globalAlpha = 0.5;
                rainbowColors.forEach((color, i) => {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 12;
                    ctx.beginPath();
                    ctx.arc(rainbowX, canvas.height, 400 - i * 30, Math.PI, 0);
                    ctx.stroke();
                });
                ctx.globalAlpha = 1;
            }

            // Chmurki (bardzo wolno, niezaleÅ¼nie od kamery)
            const time = Date.now() / 1000;
            for (let i = 0; i < 3; i++) {
                const cloudBaseX = 300 + i * 400;
                const cloudX = cloudBaseX + (time * 5) - (worldOffset * 0.1); // Bardzo wolny ruch
                const screenCloudX = cloudX % (canvas.width + 200);
                const cloudY = 80 + i * 40;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(screenCloudX, cloudY, 30, 0, Math.PI * 2);
                ctx.arc(screenCloudX + 35, cloudY, 40, 0, Math.PI * 2);
                ctx.arc(screenCloudX + 70, cloudY, 30, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Drzewa
        function drawTrees() {
            trees.forEach(tree => {
                const screenX = tree.x - worldOffset;
                if (screenX < -100 || screenX > canvas.width + 100) return;

                // PieÅ„
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(screenX - tree.width/4, tree.y - tree.height, tree.width/2, tree.height);

                // Korona (rÃ³Å¼owa/fioletowa candy)
                const crownColors = ['#FF69B4', '#E0C3FC', '#FFB6D9'];
                crownColors.forEach((color, i) => {
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(
                        screenX + (i - 1) * tree.width/4,
                        tree.y - tree.height + 10,
                        tree.width/2,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                });
            });
        }

        // Kwiaty
        function drawFlowers() {
            const time = Date.now() / 1000;
            flowers.forEach(flower => {
                const screenX = flower.x - worldOffset;
                if (screenX < -50 || screenX > canvas.width + 50) return;

                const sway = Math.sin(time + flower.swayOffset) * 2;

                // Åodyga
                ctx.strokeStyle = '#90EE90';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(screenX, flower.y);
                ctx.quadraticCurveTo(screenX + sway, flower.y - flower.size/2, screenX + sway, flower.y - flower.size);
                ctx.stroke();

                // PÅ‚atki
                ctx.fillStyle = flower.color;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const px = screenX + sway + Math.cos(angle) * flower.size/3;
                    const py = flower.y - flower.size + Math.sin(angle) * flower.size/3;
                    ctx.beginPath();
                    ctx.arc(px, py, flower.size/4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Åšrodek
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(screenX + sway, flower.y - flower.size, flower.size/5, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Grunt
        function drawGround() {
            ground.forEach(g => {
                const screenX = g.x - worldOffset;
                if (screenX + g.width < -100 || screenX > canvas.width + 100) return;

                // Trawa
                const grassGradient = ctx.createLinearGradient(screenX, g.y, screenX, g.y + g.height);
                grassGradient.addColorStop(0, '#90EE90');
                grassGradient.addColorStop(1, '#228B22');
                ctx.fillStyle = grassGradient;
                ctx.fillRect(screenX, g.y, g.width, g.height);

                // Trawka (detale)
                ctx.strokeStyle = '#7FBF7F';
                ctx.lineWidth = 2;
                for (let i = 0; i < g.width; i += 20) {
                    ctx.beginPath();
                    ctx.moveTo(screenX + i, g.y);
                    ctx.lineTo(screenX + i - 2, g.y - 8);
                    ctx.moveTo(screenX + i, g.y);
                    ctx.lineTo(screenX + i + 2, g.y - 6);
                    ctx.stroke();
                }
            });
        }

        // Cukierki
        function drawCandies() {
            const time = Date.now() / 1000;
            candies.forEach(candy => {
                if (candy.collected) return;

                const screenX = candy.x - worldOffset;
                if (screenX < -50 || screenX > canvas.width + 50) return;

                const bounce = Math.sin(time * 3 + candy.x) * 3;
                const candyTypes = ['ğŸ¬', 'ğŸ­', 'ğŸ°', 'ğŸ§', 'ğŸ©'];

                ctx.font = '25px Arial';
                ctx.fillText(candyTypes[candy.type], screenX - 12, candy.y + bounce);

                // BÅ‚ysk
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(screenX, candy.y + bounce - 8, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Rysowanie przedmiotÃ³w do zbierania
        function drawItemsToCollect() {
            const time = Date.now() / 1000;
            itemsToCollect.forEach(item => {
                if (item.collected) return;

                const screenX = item.x - worldOffset;
                if (screenX < -70 || screenX > canvas.width + 70) return;

                const bounce = Math.sin(time * 2 + item.x) * 8;
                const y = item.y + bounce;

                // ÅšwiecÄ…ca aureola
                ctx.fillStyle = '#FFD700' + '30';
                ctx.beginPath();
                ctx.arc(screenX, y, 35, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#FFD700' + '50';
                ctx.beginPath();
                ctx.arc(screenX, y, 25, 0, Math.PI * 2);
                ctx.fill();

                // Gwiazdki wokÃ³Å‚
                for (let i = 0; i < 3; i++) {
                    const angle = time * 3 + i * (Math.PI * 2 / 3);
                    const sx = screenX + Math.cos(angle) * 30;
                    const sy = y + Math.sin(angle) * 30;

                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    for (let j = 0; j < 5; j++) {
                        const starAngle = (j * 2 * Math.PI / 5) - Math.PI / 2;
                        const r = j % 2 === 0 ? 5 : 2;
                        const px = sx + Math.cos(starAngle) * r;
                        const py = sy + Math.sin(starAngle) * r;
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                // Przedmiot (emoji)
                ctx.font = '40px Arial';
                ctx.fillText(item.item.emoji, screenX - 20, y + 15);

                // Nazwa przedmiotu
                ctx.fillStyle = '#FF1493';
                ctx.font = 'bold 14px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText(item.item.name, screenX, y + 35);
                ctx.textAlign = 'left';
            });
        }

        // Przyjaciele do znalezienia
        function drawFriendsToFind() {
            const time = Date.now() / 1000;
            friendsToFind.forEach(friend => {
                if (friend.found) return;

                const screenX = friend.x - worldOffset;
                if (screenX < -100 || screenX > canvas.width + 100) return;

                const bounce = Math.sin(time * 2 + friend.bounceOffset) * 15;

                // DuÅ¼a Å›wiecÄ…ca aureola
                for (let r = 80; r > 20; r -= 12) {
                    ctx.fillStyle = friend.type.color + Math.floor((1 - r/80) * 50).toString(16).padStart(2, '0');
                    ctx.beginPath();
                    ctx.arc(screenX, friend.y + bounce + 20, r, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Rysuj przyjaciela realistycznie
                ctx.save();
                drawFriend(friend.type, screenX, friend.y + bounce, 1);
                ctx.restore();

                // Gwiazdy wokÃ³Å‚ (narysowane)
                for (let i = 0; i < 4; i++) {
                    const angle = time * 2 + i * Math.PI / 2;
                    const sx = screenX + Math.cos(angle) * 65;
                    const sy = friend.y + bounce + 20 + Math.sin(angle) * 65;

                    // Gwiazdka rysowana
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    for (let j = 0; j < 5; j++) {
                        const starAngle = (j * 2 * Math.PI / 5) - Math.PI / 2;
                        const r = j % 2 === 0 ? 12 : 5;
                        const px = sx + Math.cos(starAngle) * r;
                        const py = sy + Math.sin(starAngle) * r;
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                // Serduszka (narysowane)
                const drawHeart = (hx, hy) => {
                    ctx.fillStyle = '#FF69B4';
                    ctx.beginPath();
                    ctx.moveTo(hx, hy + 5);
                    ctx.bezierCurveTo(hx, hy, hx - 8, hy - 8, hx - 12, hy - 5);
                    ctx.bezierCurveTo(hx - 16, hy, hx - 16, hy + 5, hx - 16, hy + 8);
                    ctx.bezierCurveTo(hx - 16, hy + 12, hx - 12, hy + 18, hx, hy + 25);
                    ctx.bezierCurveTo(hx + 12, hy + 18, hx + 16, hy + 12, hx + 16, hy + 8);
                    ctx.bezierCurveTo(hx + 16, hy + 5, hx + 16, hy, hx + 12, hy - 5);
                    ctx.bezierCurveTo(hx + 8, hy - 8, hx, hy, hx, hy + 5);
                    ctx.fill();
                };

                drawHeart(screenX - 45, friend.y + bounce - 40);
                drawHeart(screenX + 35, friend.y + bounce - 40);
            });
        }

        // Dekoracje (motyle, ptaszki)
        function drawDecorations() {
            const time = Date.now() / 1000;
            decorations.forEach(deco => {
                const screenX = deco.x - worldOffset * 0.5 + Math.sin(time * deco.speed + deco.phase) * 50;
                const screenY = deco.y + Math.cos(time * deco.speed + deco.phase) * 30;

                if (screenX < -50 || screenX > canvas.width + 50) return;

                ctx.save();
                if (deco.type === 'butterfly') {
                    drawButterfly(screenX, screenY);
                } else {
                    drawBird(screenX, screenY);
                }
                ctx.restore();
            });
        }

        // Rysowanie pszczoÅ‚y
        function drawBee(x, y) {
            // CieÅ„
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.beginPath();
            ctx.ellipse(x, canvas.height - 95, 12, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // SkrzydÅ‚a
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.ellipse(x - 8, y - 5, 8, 12, -0.3, 0, Math.PI * 2);
            ctx.ellipse(x + 8, y - 5, 8, 12, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // CiaÅ‚o (paski)
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.ellipse(x, y, 10, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Czarne paski
            ctx.fillStyle = '#000';
            ctx.fillRect(x - 10, y - 5, 20, 3);
            ctx.fillRect(x - 10, y + 3, 20, 3);

            // GÅ‚Ã³wka
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y - 12, 6, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 2, y - 12, 2, 0, Math.PI * 2);
            ctx.arc(x + 2, y - 12, 2, 0, Math.PI * 2);
            ctx.fill();

            // CzuÅ‚ki
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x - 3, y - 16);
            ctx.lineTo(x - 6, y - 20);
            ctx.moveTo(x + 3, y - 16);
            ctx.lineTo(x + 6, y - 20);
            ctx.stroke();
        }

        // Rysowanie biedronki
        function drawLadybug(x, y) {
            // CieÅ„
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.beginPath();
            ctx.ellipse(x, canvas.height - 95, 10, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // CiaÅ‚o
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.ellipse(x, y, 12, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Linia Å›rodkowa
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y - 15);
            ctx.lineTo(x, y + 15);
            ctx.stroke();

            // Kropki
            ctx.fillStyle = '#000';
            const dots = [[-4, -5], [4, -5], [-5, 3], [5, 3], [-3, 10], [3, 10]];
            dots.forEach(([dx, dy]) => {
                ctx.beginPath();
                ctx.arc(x + dx, y + dy, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // GÅ‚Ã³wka
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y - 18, 5, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 2, y - 18, 1.5, 0, Math.PI * 2);
            ctx.arc(x + 2, y - 18, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie ptaka
        function drawBird(x, y) {
            // CieÅ„
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.beginPath();
            ctx.ellipse(x, canvas.height - 95, 15, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // SkrzydÅ‚a
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.ellipse(x - 12, y, 15, 8, -0.5, 0, Math.PI * 2);
            ctx.ellipse(x + 12, y, 15, 8, 0.5, 0, Math.PI * 2);
            ctx.fill();

            // CiaÅ‚o
            ctx.fillStyle = '#ADD8E6';
            ctx.beginPath();
            ctx.ellipse(x, y, 12, 18, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek
            ctx.fillStyle = '#E6F3FF';
            ctx.beginPath();
            ctx.ellipse(x, y + 5, 8, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // GÅ‚Ã³wka
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.arc(x, y - 15, 8, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 3, y - 15, 2, 0, Math.PI * 2);
            ctx.arc(x + 3, y - 15, 2, 0, Math.PI * 2);
            ctx.fill();

            // DziÃ³b
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.moveTo(x, y - 13);
            ctx.lineTo(x - 2, y - 10);
            ctx.lineTo(x + 2, y - 10);
            ctx.fill();

            // Ogon
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.moveTo(x, y + 18);
            ctx.lineTo(x - 8, y + 25);
            ctx.lineTo(x + 8, y + 25);
            ctx.fill();
        }

        // Rysowanie motyla
        function drawButterfly(x, y) {
            // CieÅ„
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.beginPath();
            ctx.ellipse(x, canvas.height - 95, 12, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // GÃ³rne skrzydÅ‚a
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.ellipse(x - 10, y - 8, 12, 15, -0.4, 0, Math.PI * 2);
            ctx.ellipse(x + 10, y - 8, 12, 15, 0.4, 0, Math.PI * 2);
            ctx.fill();

            // Dolne skrzydÅ‚a
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.ellipse(x - 8, y + 8, 10, 12, -0.3, 0, Math.PI * 2);
            ctx.ellipse(x + 8, y + 8, 10, 12, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Wzory na skrzydÅ‚ach
            ctx.fillStyle = '#FFF';
            [[x - 10, y - 8], [x + 10, y - 8], [x - 8, y + 8], [x + 8, y + 8]].forEach(([px, py]) => {
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // CiaÅ‚o
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - 2, y - 15, 4, 30);

            // GÅ‚Ã³wka
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y - 17, 3, 0, Math.PI * 2);
            ctx.fill();

            // CzuÅ‚ki
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x - 2, y - 18);
            ctx.lineTo(x - 5, y - 22);
            ctx.moveTo(x + 2, y - 18);
            ctx.lineTo(x + 5, y - 22);
            ctx.stroke();

            // Kulki na czuÅ‚kach
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 5, y - 22, 1.5, 0, Math.PI * 2);
            ctx.arc(x + 5, y - 22, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie wiewiÃ³rki
        function drawSquirrel(x, y) {
            // Puszysty ogon
            ctx.fillStyle = '#D2691E';
            ctx.beginPath();
            ctx.arc(x - 15, y - 20, 18, 0, Math.PI * 2);
            ctx.fill();

            // CiaÅ‚o
            ctx.fillStyle = '#CD853F';
            ctx.beginPath();
            ctx.ellipse(x, y, 12, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek
            ctx.fillStyle = '#F4A460';
            ctx.beginPath();
            ctx.ellipse(x, y + 3, 8, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // GÅ‚Ã³wka
            ctx.fillStyle = '#CD853F';
            ctx.beginPath();
            ctx.arc(x, y - 12, 8, 0, Math.PI * 2);
            ctx.fill();

            // Uszy
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.moveTo(x - 5, y - 16);
            ctx.lineTo(x - 7, y - 22);
            ctx.lineTo(x - 3, y - 18);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x + 5, y - 16);
            ctx.lineTo(x + 7, y - 22);
            ctx.lineTo(x + 3, y - 18);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 3, y - 12, 2, 0, Math.PI * 2);
            ctx.arc(x + 3, y - 12, 2, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(x, y - 9, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Åapki
            ctx.fillStyle = '#CD853F';
            ctx.beginPath();
            ctx.ellipse(x - 8, y + 12, 4, 6, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 8, y + 12, 4, 6, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie myszki
        function drawMouse(x, y) {
            // Ogon
            ctx.strokeStyle = '#FFB6D9';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + 10, y);
            ctx.quadraticCurveTo(x + 20, y - 5, x + 25, y + 5);
            ctx.stroke();

            // CiaÅ‚o
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.ellipse(x, y, 10, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // GÅ‚Ã³wka
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.arc(x - 8, y - 5, 7, 0, Math.PI * 2);
            ctx.fill();

            // Uszy
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.arc(x - 10, y - 10, 5, 0, Math.PI * 2);
            ctx.arc(x - 6, y - 10, 5, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 10, y - 5, 2, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.arc(x - 12, y - 3, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // WÄ…sy
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x - 12, y - 3);
            ctx.lineTo(x - 18, y - 5);
            ctx.moveTo(x - 12, y - 3);
            ctx.lineTo(x - 18, y - 1);
            ctx.stroke();
        }

        // Rysowanie Å¼Ã³Å‚wia
        function drawTurtle(x, y) {
            // Skorupa
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.ellipse(x, y - 5, 15, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // WzÃ³r na skorupie
            ctx.strokeStyle = '#006400';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - 10, y - 5);
            ctx.lineTo(x + 10, y - 5);
            ctx.moveTo(x, y - 15);
            ctx.lineTo(x - 7, y);
            ctx.moveTo(x, y - 15);
            ctx.lineTo(x + 7, y);
            ctx.stroke();

            // GÅ‚Ã³wka
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.arc(x - 12, y - 3, 5, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 13, y - 4, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Åapki
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.ellipse(x - 10, y + 5, 4, 3, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 10, y + 5, 4, 3, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // ZwierzÄ™ta mijajÄ…ce
        function drawPassingAnimals() {
            const time = Date.now() / 1000;
            passingAnimals.forEach(animal => {
                const screenX = animal.x - worldOffset;
                if (screenX < -100 || screenX > canvas.width + 100) return;

                let displayY = animal.y;

                // Animacja latania (koÅ‚ysanie)
                if (animal.flying) {
                    displayY += Math.sin(time * 2 + animal.phase) * 10;
                }

                ctx.save();

                // Odbicie lustrzane gdy idzie w lewo
                if (animal.direction < 0 && !animal.flying) {
                    ctx.translate(screenX, displayY);
                    ctx.scale(-1, 1);
                    ctx.translate(-screenX, -displayY);
                }

                // Rysuj odpowiednie zwierzÄ™
                switch(animal.emoji) {
                    case 'ğŸ':
                        drawBee(screenX, displayY);
                        break;
                    case 'ğŸ':
                        drawLadybug(screenX, displayY);
                        break;
                    case 'ğŸ•Šï¸':
                    case 'ğŸ¦…':
                    case 'ğŸ¦':
                        drawBird(screenX, displayY);
                        break;
                    case 'ğŸ¦‹':
                        drawButterfly(screenX, displayY);
                        break;
                    case 'ğŸ¿ï¸':
                        drawSquirrel(screenX, displayY);
                        break;
                    case 'ğŸ':
                        drawMouse(screenX, displayY);
                        break;
                    case 'ğŸ¢':
                        drawTurtle(screenX, displayY);
                        break;
                }

                ctx.restore();
            });
        }

        // Aktualizacja zwierzÄ…t mijajÄ…cych
        function updatePassingAnimals() {
            passingAnimals.forEach(animal => {
                animal.x += animal.speed * animal.direction;

                // Odbicie od granic
                if (animal.x <= animal.minX || animal.x >= animal.maxX) {
                    animal.direction *= -1;
                }
            });
        }

        // Parada przyjaciÃ³Å‚
        function drawFollowingFriends() {
            followingFriends.forEach((friend, index) => {
                if (friend.historyIndex < playerHistory.length) {
                    const pos = playerHistory[friend.historyIndex];
                    if (pos) {
                        drawFriend(friend.type, pos.x - worldOffset - 30, pos.y - 10, 0.9);
                    }
                }
            });
        }

        // Update
        function updatePlayer() {
            let moving = false;

            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                player.x -= player.speed;
                player.facingRight = false;
                moving = true;
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                player.x += player.speed;
                player.facingRight = true;
                moving = true;
            }

            // Opcjonalne skakanie
            if ((keys[' '] || keys['ArrowUp'] || keys['w'] || keys['W']) && !player.jumping) {
                player.velY = player.jumpPower;
                player.jumping = true;
            }

            // Grawitacja (Å‚agodna)
            if (player.jumping) {
                player.velY += player.gravity;
                player.y += player.velY;

                // LÄ…dowanie
                const groundY = canvas.height - 150;
                if (player.y >= groundY) {
                    player.y = groundY;
                    player.velY = 0;
                    player.jumping = false;
                }
            }

            // Animacja chodzenia
            if (moving) {
                player.walkCycle += 0.2;
            }

            // Kamera
            const targetOffset = player.x - canvas.width / 3;
            worldOffset += (targetOffset - worldOffset) * 0.08;

            // Generuj chunki
            const currentChunk = Math.floor(player.x / chunkSize);
            for (let i = currentChunk - 1; i <= currentChunk + 2; i++) {
                generateChunk(i);
            }

            // Historia
            playerHistory.unshift({ x: player.x, y: player.y });
            if (playerHistory.length > historyLength * (followingFriends.length + 2)) {
                playerHistory.pop();
            }

            // Pozycja
            if (player.x > furthestPosition) {
                furthestPosition = player.x;
                document.getElementById('position').textContent = Math.floor(furthestPosition / 100);
            }

            // NastrÃ³j
            const moods = ['Miau! ğŸ˜º', 'Mrrr ğŸ’•', 'Purr~ âœ¨', 'Miuu ğŸŒˆ'];
            if (animationFrame % 180 === 0) {
                document.getElementById('mood').textContent = moods[Math.floor(Math.random() * moods.length)];
            }
        }

        // Zbieranie
        function checkCollectibles() {
            candies.forEach(candy => {
                if (!candy.collected &&
                    Math.abs(player.x - candy.x) < 40 &&
                    Math.abs(player.y - candy.y) < 50) {
                    candy.collected = true;
                    score++;
                    document.getElementById('score').textContent = score;
                }
            });

            // Zbieranie przedmiotÃ³w (ubranka, rogi, akcesoria)
            itemsToCollect.forEach(item => {
                if (!item.collected &&
                    Math.abs(player.x - item.x) < 50 &&
                    Math.abs(player.y - item.y) < 60) {
                    item.collected = true;

                    // Dodaj do kolekcji
                    if (item.type === 'horn') {
                        if (!collectedItems.horns.includes(item.item.id)) {
                            collectedItems.horns.push(item.item.id);
                        }
                    } else if (item.type === 'outfit') {
                        if (!collectedItems.outfits.includes(item.item.id)) {
                            collectedItems.outfits.push(item.item.id);
                        }
                    } else if (item.type === 'accessory') {
                        if (!collectedItems.accessories.includes(item.item.id)) {
                            collectedItems.accessories.push(item.item.id);
                        }
                    } else if (item.type === 'color') {
                        if (!collectedItems.colors.includes(item.item.id)) {
                            collectedItems.colors.push(item.item.id);
                        }
                    }

                    updateWardrobe();

                    // Chmurka z wiadomoÅ›ciÄ…
                    dialogBubbles.push({
                        x: player.x,
                        y: player.y,
                        text: `ZnalazÅ‚em ${item.item.name}! âœ¨`,
                        fromLeft: true,
                        startTime: Date.now(),
                        duration: 2500
                    });
                }
            });

            // Check house door collision (SPACJA to enter)
            let enteredHouse = false;
            houses.forEach(house => {
                const houseDoorX = house.x + 125;
                const horizontalDistance = Math.abs(player.x - houseDoorX);

                if (horizontalDistance < 150 && keys[' '] && !enteredHouse) {
                    enterHouse();
                    enteredHouse = true;
                }
            });

            // Check hycel collision (only if didn't enter house)
            if (!enteredHouse) {
                hycels.forEach(hycel => {
                    if (!hycel.defeated) {
                        const distance = Math.sqrt(
                            Math.pow(player.x - hycel.x, 2) +
                            Math.pow(player.y - hycel.y, 2)
                        );

                        if (distance < 150 && keys[' ']) {
                            startBattle(hycel);
                        }
                    }
                });
            }

            friendsToFind.forEach(friend => {
                if (!friend.found &&
                    Math.abs(player.x - friend.x) < 70 &&
                    Math.abs(player.y - friend.y) < 70) {

                    // Check if friend has an active hycel guarding them
                    if (friend.hasHycel) {
                        const friendHycel = hycels.find(h => h.friendIndex === friendsToFind.indexOf(friend));
                        if (friendHycel && !friendHycel.defeated) {
                            // Show friend's cry for help
                            dialogBubbles.push({
                                x: friend.x,
                                y: friend.y,
                                text: 'ğŸ˜± Hycel mnie strzeÅ¼e! PomÃ³Å¼ mi!',
                                fromLeft: false,
                                startTime: Date.now(),
                                duration: 2500
                            });
                            return; // Don't collect friend yet
                        }
                    }

                    friend.found = true;

                    // Dodaj chmurki dialogowe (rÃ³Å¼norodne rozmowy!)
                    const conversations = [
                        ['PiÄ™kny dzieÅ„, prawda? ğŸŒ', 'O tak! Idealna pogoda!'],
                        ['WidziaÅ‚eÅ› te chmurki? â˜ï¸', 'Tak! Takie puszyste!'],
                        ['Uwielbiam cukierki! ğŸ¬', 'Ja teÅ¼! SÄ… przepyszne!'],
                        ['DokÄ…d idziesz? ğŸ—ºï¸', 'Na przygodÄ™! Idziesz?'],
                        ['Co za piÄ™kna tÄ™cza! ğŸŒˆ', 'Magiczna, prawda?'],
                        ['Hej! ZgubiÅ‚eÅ› siÄ™? ğŸ’•', 'Nie! Zwiedzam Å›wiat!'],
                        ['Åadny masz rÃ³g! âœ¨', 'DziÄ™kujÄ™! JesteÅ› super!'],
                        ['Trawa jest taka zielona! ğŸŒ±', 'I kwiaty Å›liczne!'],
                        ['SÅ‚yszysz ptaki? ğŸ¦', 'Tak! ÅšpiewajÄ… piÄ™knie!'],
                        ['Witaj przyjacielu! ğŸ’–', 'Witaj! IdÄ™ z TobÄ…!'],
                        ['Lubisz przygody? ğŸ’', 'Uwielbiam! ChodÅºmy!'],
                        ['Jestem trochÄ™ gÅ‚odny... ğŸ°', 'Poszukajmy cukierkÃ³w!'],
                        ['Wieje dziÅ› wiatr! ğŸ’¨', 'Ale przyjemnie!'],
                        ['SÅ‚oÅ„ce tak grzeje! â˜€ï¸', 'Cudownie ciepÅ‚o!'],
                        ['Co tam za gÃ³rkÄ…? ğŸ”ï¸', 'SprawdÅºmy razem!'],
                        ['Nie boisz siÄ™? ğŸ˜Š', 'Z TobÄ… siÄ™ nie bojÄ™!'],
                        ['Miau! Hej tam! ğŸ˜º', 'CzeÅ›Ä‡ kiciusiu!'],
                        ['To bÄ™dzie super! ğŸ‰', 'Najlepsza przygoda!'],
                        ['Gdzie sÄ… inni? ğŸ‘¥', 'Razem ich znajdziemy!'],
                        ['Jest tak kolorowo! ğŸ¨', 'Jak w bajce!']
                    ];
                    const randomConversation = conversations[Math.floor(Math.random() * conversations.length)];

                    // Mapowanie emoji na typy dÅºwiÄ™kÃ³w
                    const soundMap = {
                        'ğŸ¶': 'dog',
                        'ğŸ°': 'rabbit',
                        'ğŸ»': 'bear',
                        'ğŸ‘': 'sheep',
                        'ğŸ¬': 'dolphin',
                        'ğŸ¦Š': 'fox',
                        'ğŸ¼': 'panda',
                        'ğŸ¦„': 'unicorn',
                        'ğŸ¸': 'frog',
                        'ğŸ¦‹': 'butterfly'
                    };

                    // Chmurka KicioroÅ¼ka
                    playAnimalSound('cat'); // Miauczenie!
                    dialogBubbles.push({
                        x: player.x,
                        y: player.y,
                        text: randomConversation[0],
                        fromLeft: true,
                        startTime: Date.now(),
                        duration: 3500
                    });

                    // Chmurka przyjaciela (pojawia siÄ™ po chwili)
                    setTimeout(() => {
                        const friendSoundType = soundMap[friend.type.emoji] || 'dog';
                        playAnimalSound(friendSoundType); // DÅºwiÄ™k przyjaciela!
                        dialogBubbles.push({
                            x: friend.x,
                            y: friend.y,
                            text: randomConversation[1],
                            fromLeft: false,
                            startTime: Date.now(),
                            duration: 3500
                        });
                    }, 1000);

                    followingFriends.push({
                        type: friend.type,
                        historyIndex: historyLength * followingFriends.length + historyLength
                    });

                    updateFriendsList();

                    // SprawdÅº zwyciÄ™stwo
                    if ((followingFriends.length + interiorFriends.length) >= friendTypes.length) {
                        setTimeout(() => {
                            document.getElementById('final-score').textContent = score;
                            document.getElementById('final-distance').textContent = Math.floor(furthestPosition / 100);
                            document.getElementById('victory-screen').classList.add('active');
                            gameRunning = false;
                        }, 3000);
                    }
                }
            });
        }

        function updateFriendsList() {
            const list = document.getElementById('friends-list');
            if (followingFriends.length === 0) {
                list.textContent = '(czeka na przyjaciÃ³Å‚)';
            } else {
                list.innerHTML = followingFriends.map(f => f.type.emoji).join(' ') +
                    `<br><small style="font-size: 0.7em;">${followingFriends.length}/${friendTypes.length}</small>`;
            }
        }

        // Aktualizacja garderoby
        function updateWardrobe() {
            // Rogi
            const hornItems = document.getElementById('horn-items');
            hornItems.innerHTML = '';
            collectedItems.horns.forEach(hornId => {
                const horn = itemDefinitions.horns.find(h => h.id === hornId);
                const div = document.createElement('div');
                div.className = 'wardrobe-item' + (player.equippedHorn === hornId ? ' equipped' : '');
                div.textContent = horn.emoji;
                div.title = horn.name;
                div.onclick = () => equipItem('horn', hornId);
                hornItems.appendChild(div);
            });

            // Ubranka
            const outfitItems = document.getElementById('outfit-items');
            outfitItems.innerHTML = '';
            // Opcja "Bez ubranka"
            const noneOutfit = document.createElement('div');
            noneOutfit.className = 'wardrobe-item' + (player.equippedOutfit === null ? ' equipped' : '');
            noneOutfit.textContent = 'ğŸš«';
            noneOutfit.title = 'Bez ubranka';
            noneOutfit.onclick = () => equipItem('outfit', null);
            outfitItems.appendChild(noneOutfit);

            collectedItems.outfits.forEach(outfitId => {
                const outfit = itemDefinitions.outfits.find(o => o.id === outfitId);
                const div = document.createElement('div');
                div.className = 'wardrobe-item' + (player.equippedOutfit === outfitId ? ' equipped' : '');
                div.textContent = outfit.emoji;
                div.title = outfit.name;
                div.onclick = () => equipItem('outfit', outfitId);
                outfitItems.appendChild(div);
            });

            // Akcesoria
            const accessoryItems = document.getElementById('accessory-items');
            accessoryItems.innerHTML = '';
            // Opcja "Bez akcesorium"
            const noneAccessory = document.createElement('div');
            noneAccessory.className = 'wardrobe-item' + (player.equippedAccessory === null ? ' equipped' : '');
            noneAccessory.textContent = 'ğŸš«';
            noneAccessory.title = 'Bez akcesorium';
            noneAccessory.onclick = () => equipItem('accessory', null);
            accessoryItems.appendChild(noneAccessory);

            collectedItems.accessories.forEach(accessoryId => {
                const accessory = itemDefinitions.accessories.find(a => a.id === accessoryId);
                const div = document.createElement('div');
                div.className = 'wardrobe-item' + (player.equippedAccessory === accessoryId ? ' equipped' : '');
                div.textContent = accessory.emoji;
                div.title = accessory.name;
                div.onclick = () => equipItem('accessory', accessoryId);
                accessoryItems.appendChild(div);
            });

            // Kolory
            const colorItems = document.getElementById('color-items');
            colorItems.innerHTML = '';
            collectedItems.colors.forEach(colorId => {
                const colorDef = itemDefinitions.colors.find(c => c.id === colorId);
                const div = document.createElement('div');
                div.className = 'wardrobe-item' + (player.equippedColor === colorId ? ' equipped' : '');
                div.textContent = colorDef.emoji;
                div.title = colorDef.name;
                div.style.backgroundColor = colorDef.bodyColor;
                div.onclick = () => equipItem('color', colorId);
                colorItems.appendChild(div);
            });
        }

        // ZakÅ‚adanie przedmiotu
        function equipItem(type, itemId) {
            if (type === 'horn') {
                player.equippedHorn = itemId;
            } else if (type === 'outfit') {
                player.equippedOutfit = itemId;
            } else if (type === 'accessory') {
                player.equippedAccessory = itemId;
            } else if (type === 'color') {
                player.equippedColor = itemId;
            }
            updateWardrobe();
        }

        // ========== HOUSE SYSTEM ==========

        function drawHouses() {
            const groundY = canvas.height - 100;

            houses.forEach(house => {
                const screenX = house.x - worldOffset;
                const screenY = groundY - house.height; // On ground level

                if (screenX < -300 || screenX > canvas.width + 100) return;

                ctx.save();

            // House body (light blue)
            ctx.fillStyle = '#ADD8E6';
            ctx.fillRect(screenX, screenY, house.width, house.height);

            // Roof (rainbow gradient)
            const roofGradient = ctx.createLinearGradient(screenX, screenY - 80, screenX + house.width, screenY);
            roofGradient.addColorStop(0, '#FF0000');
            roofGradient.addColorStop(0.2, '#FF7F00');
            roofGradient.addColorStop(0.4, '#FFFF00');
            roofGradient.addColorStop(0.6, '#00FF00');
            roofGradient.addColorStop(0.8, '#0000FF');
            roofGradient.addColorStop(1, '#8B00FF');
            ctx.fillStyle = roofGradient;
            ctx.beginPath();
            ctx.moveTo(screenX - 30, screenY);
            ctx.lineTo(screenX + house.width / 2, screenY - 80);
            ctx.lineTo(screenX + house.width + 30, screenY);
            ctx.closePath();
            ctx.fill();

            // Windows
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(screenX + 40, screenY + 50, 50, 50);
            ctx.fillRect(screenX + 160, screenY + 50, 50, 50);

            // Window crosses (purple)
            ctx.strokeStyle = '#8B00FF';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(screenX + 65, screenY + 50);
            ctx.lineTo(screenX + 65, screenY + 100);
            ctx.moveTo(screenX + 40, screenY + 75);
            ctx.lineTo(screenX + 90, screenY + 75);
            ctx.moveTo(screenX + 185, screenY + 50);
            ctx.lineTo(screenX + 185, screenY + 100);
            ctx.moveTo(screenX + 160, screenY + 75);
            ctx.lineTo(screenX + 210, screenY + 75);
            ctx.stroke();

            // Door (purple)
            ctx.fillStyle = '#8B00FF';
            ctx.fillRect(screenX + 95, screenY + 120, 60, 80);

            // Door knob (gold)
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(screenX + 135, screenY + 160, 5, 0, Math.PI * 2);
            ctx.fill();

            // Show hint when player is near (simplified)
            const houseDoorX = house.x + 125; // Center of house
            const horizontalDistance = Math.abs(player.x - houseDoorX);

            if (horizontalDistance < 200) {
                let hintText = '';
                let hintColor = '';

                hintText = 'SPACJA - WejdÅº do domku!';
                hintColor = '#00FF00';

                // Hint bubble
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.strokeStyle = hintColor;
                ctx.lineWidth = 3;
                const hintWidth = ctx.measureText(hintText).width + 40;
                ctx.fillRect(screenX + (house.width - hintWidth) / 2, screenY - 80, hintWidth, 40);
                ctx.strokeRect(screenX + (house.width - hintWidth) / 2, screenY - 80, hintWidth, 40);

                ctx.fillStyle = hintColor;
                ctx.font = 'bold 18px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText(hintText, screenX + house.width / 2, screenY - 55);
                }

                ctx.restore();
            });
        }

        let houseCooldown = 0; // Prevent instant exit after entering

        function enterHouse() {
            if (houseCooldown > 0) return;

            previousState = gameState;
            gameState = 'interior';
            houseCooldown = 30;

            // Reset interior player and camera
            interiorPlayer.x = 200;
            interiorPlayer.y = canvas.height - 200;
            interiorPlayer.action = 'none';
            interiorPlayer.actionTimer = 0;
            interiorPlayer.actionObject = null;
            interiorOffset = 0;

            // Generate procedural furniture if first time or empty
            if (interiorObjects.length === 0) {
                interiorObjects = [];

                // Exit door at start (x=100)
                interiorObjects.push({ type: 'door', x: 100 });

                // Generate furniture proceduralnie co ~300-500px
                let furnitureX = 300;
                const furnitureTypes = ['bed', 'toilet', 'sink', 'food', 'toy_ball', 'toy_mouse', 'toy_yarn'];

                for (let i = 0; i < 50; i++) { // Generate 50 furniture items
                    const randType = furnitureTypes[Math.floor(Math.random() * furnitureTypes.length)];
                    interiorObjects.push({
                        type: randType,
                        x: furnitureX,
                        variant: Math.floor(Math.random() * 3) // For variety in toys
                    });
                    furnitureX += 250 + Math.random() * 300;
                }
            }

            // Add current following friends to interior (they stay there!)
            followingFriends.forEach(f => {
                // Don't duplicate if already in interior
                const alreadyInside = interiorFriends.some(
                    inf => inf.type.emoji === f.type.emoji
                );
                if (!alreadyInside) {
                    interiorFriends.push({
                        type: f.type,
                        x: 100 + Math.random() * (canvas.width - 200),
                        y: canvas.height - 200,
                        velX: (Math.random() - 0.5) * 3,
                        velY: 0,
                        activity: ['walking', 'jumping', 'playing'][Math.floor(Math.random() * 3)],
                        activityTimer: 100 + Math.floor(Math.random() * 100),
                        jumpPower: 0,
                        animFrame: 0
                    });
                }
            });

            // Friends stay in the house - remove from parade
            followingFriends = [];
            updateFriendsList();

            interiorAnimationFrame = 0;
        }

        function exitHouse() {
            if (houseCooldown > 0) return;
            gameState = 'world';
            houseCooldown = 30;
            // Reset bathtub water
            interiorPlayer.bathtubWaterLevel = 0;
            // interiorFriends stay! They live here now.
        }

        function drawInterior() {
            interiorAnimationFrame++;
            const floorY = canvas.height - 180;

            // ===== WALLS =====
            // Warm cream wall with subtle texture
            const wallGrad = ctx.createLinearGradient(0, 0, 0, floorY);
            wallGrad.addColorStop(0, '#FFF5E6');
            wallGrad.addColorStop(1, '#FFECD2');
            ctx.fillStyle = wallGrad;
            ctx.fillRect(0, 0, canvas.width, floorY);

            // Subtle wallpaper stripes
            ctx.globalAlpha = 0.06;
            ctx.fillStyle = '#D4A574';
            for (let x = 0; x < canvas.width; x += 40) {
                ctx.fillRect(x, 0, 18, floorY);
            }
            ctx.globalAlpha = 1;

            // Baseboard / skirting board
            ctx.fillStyle = '#F5F5F5';
            ctx.fillRect(0, floorY - 15, canvas.width, 15);
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, floorY - 15, canvas.width, 15);

            // ===== FLOOR =====
            // Warm wooden floor
            const floorGrad = ctx.createLinearGradient(0, floorY, 0, canvas.height);
            floorGrad.addColorStop(0, '#C4935A');
            floorGrad.addColorStop(0.5, '#B8864E');
            floorGrad.addColorStop(1, '#A67842');
            ctx.fillStyle = floorGrad;
            ctx.fillRect(0, floorY, canvas.width, canvas.height - floorY);

            // Floor plank lines
            ctx.strokeStyle = 'rgba(101, 67, 33, 0.3)';
            ctx.lineWidth = 1;
            for (let y = floorY; y < canvas.height; y += 25) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            // Vertical plank separators
            for (let x = 0; x < canvas.width; x += 80) {
                const offset = ((x / 80) % 2) * 12;
                for (let y = floorY + offset; y < canvas.height; y += 50) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, y + 25);
                    ctx.stroke();
                }
            }

            // Wood grain details (scrolling with camera)
            ctx.strokeStyle = 'rgba(101, 67, 33, 0.08)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 40; i++) {
                const gx = ((i * 73 + 20 - interiorOffset * 0.5) % (canvas.width + 100)) - 50;
                const gy = floorY + (i * 31 + 5) % (canvas.height - floorY);
                ctx.beginPath();
                ctx.ellipse(gx, gy, 15 + (i % 3) * 5, 2, 0, 0, Math.PI * 2);
                ctx.stroke();
            }

            // ===== COZY RUG (center) =====
            const rugCX = canvas.width / 2;
            const rugCY = floorY + (canvas.height - floorY) / 2;
            // Oval rug with fringe
            ctx.save();
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath();
            ctx.ellipse(rugCX + 3, rugCY + 3, 160, 80, 0, 0, Math.PI * 2);
            ctx.fill();
            // Main rug
            const rugGrad = ctx.createRadialGradient(rugCX, rugCY, 0, rugCX, rugCY, 160);
            rugGrad.addColorStop(0, '#FF85A2');
            rugGrad.addColorStop(0.6, '#FF6B8A');
            rugGrad.addColorStop(1, '#E8527A');
            ctx.fillStyle = rugGrad;
            ctx.beginPath();
            ctx.ellipse(rugCX, rugCY, 155, 75, 0, 0, Math.PI * 2);
            ctx.fill();
            // Inner pattern
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(rugCX, rugCY, 120, 55, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(rugCX, rugCY, 80, 35, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Fringe around edges
            ctx.strokeStyle = '#E8527A';
            ctx.lineWidth = 1;
            for (let a = 0; a < Math.PI * 2; a += 0.12) {
                const fx = rugCX + Math.cos(a) * 155;
                const fy = rugCY + Math.sin(a) * 75;
                const fdx = Math.cos(a) * 8;
                const fdy = Math.sin(a) * 4;
                ctx.beginPath();
                ctx.moveTo(fx, fy);
                ctx.lineTo(fx + fdx, fy + fdy);
                ctx.stroke();
            }
            ctx.restore();

            // ===== TV ON STAND (left wall) =====
            const tvX = 80;
            const tvY = floorY - 250;
            const tvW = 220;
            const tvH = 140;

            // TV stand / cabinet
            ctx.fillStyle = '#5C3D2E';
            ctx.fillRect(tvX - 10, floorY - 80, tvW + 20, 80);
            // Drawers on stand
            ctx.strokeStyle = '#4A2F22';
            ctx.lineWidth = 1;
            ctx.strokeRect(tvX - 10, floorY - 80, tvW + 20, 80);
            ctx.beginPath();
            ctx.moveTo(tvX + tvW / 2, floorY - 80);
            ctx.lineTo(tvX + tvW / 2, floorY);
            ctx.stroke();
            // Drawer knobs
            ctx.fillStyle = '#C0A080';
            ctx.beginPath();
            ctx.arc(tvX + tvW / 4, floorY - 40, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(tvX + tvW * 3 / 4, floorY - 40, 4, 0, Math.PI * 2);
            ctx.fill();

            // TV body (dark frame)
            ctx.fillStyle = '#1A1A2E';
            ctx.fillRect(tvX - 5, tvY - 5, tvW + 10, tvH + 10);
            // Rounded corners effect
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.strokeRect(tvX - 5, tvY - 5, tvW + 10, tvH + 10);

            // TV screen with animated cartoon
            ctx.save();
            ctx.beginPath();
            ctx.rect(tvX, tvY, tvW, tvH);
            ctx.clip();

            // Cartoon background - sky
            const skyGrad = ctx.createLinearGradient(tvX, tvY, tvX, tvY + tvH);
            skyGrad.addColorStop(0, '#87CEEB');
            skyGrad.addColorStop(0.7, '#B0E0FF');
            skyGrad.addColorStop(1, '#90EE90');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(tvX, tvY, tvW, tvH);

            // Animated sun
            const sunX = tvX + 40;
            const sunY = tvY + 30;
            const sunPulse = 18 + Math.sin(interiorAnimationFrame * 0.05) * 3;
            // Sun rays
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            for (let r = 0; r < 8; r++) {
                const angle = (r / 8) * Math.PI * 2 + interiorAnimationFrame * 0.02;
                ctx.beginPath();
                ctx.moveTo(sunX + Math.cos(angle) * (sunPulse + 3), sunY + Math.sin(angle) * (sunPulse + 3));
                ctx.lineTo(sunX + Math.cos(angle) * (sunPulse + 10), sunY + Math.sin(angle) * (sunPulse + 10));
                ctx.stroke();
            }
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunPulse, 0, Math.PI * 2);
            ctx.fill();
            // Sun face
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.arc(sunX - 5, sunY - 3, 2, 0, Math.PI * 2);
            ctx.arc(sunX + 5, sunY - 3, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(sunX, sunY + 3, 5, 0, Math.PI);
            ctx.stroke();

            // Animated clouds
            const cloudOff = (interiorAnimationFrame * 0.3) % (tvW + 60);
            ctx.fillStyle = '#FFF';
            [cloudOff, cloudOff + 100, cloudOff + 200].forEach(cx => {
                const wrappedX = tvX + (cx % (tvW + 60)) - 30;
                ctx.beginPath();
                ctx.arc(wrappedX, tvY + 25, 12, 0, Math.PI * 2);
                ctx.arc(wrappedX + 12, tvY + 20, 14, 0, Math.PI * 2);
                ctx.arc(wrappedX + 24, tvY + 25, 11, 0, Math.PI * 2);
                ctx.fill();
            });

            // Green hills
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.moveTo(tvX, tvY + tvH);
            ctx.quadraticCurveTo(tvX + tvW * 0.25, tvY + tvH - 40, tvX + tvW * 0.5, tvY + tvH - 10);
            ctx.quadraticCurveTo(tvX + tvW * 0.75, tvY + tvH - 50, tvX + tvW, tvY + tvH - 15);
            ctx.lineTo(tvX + tvW, tvY + tvH);
            ctx.closePath();
            ctx.fill();

            // Cartoon cat character walking across screen
            const catCartoonX = tvX + ((interiorAnimationFrame * 0.8) % (tvW + 40)) - 20;
            const catBob = Math.sin(interiorAnimationFrame * 0.15) * 3;
            // Body
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.ellipse(catCartoonX, tvY + tvH - 35 + catBob, 12, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            // Head
            ctx.beginPath();
            ctx.arc(catCartoonX + 8, tvY + tvH - 45 + catBob, 8, 0, Math.PI * 2);
            ctx.fill();
            // Ears
            ctx.beginPath();
            ctx.moveTo(catCartoonX + 3, tvY + tvH - 53 + catBob);
            ctx.lineTo(catCartoonX + 6, tvY + tvH - 60 + catBob);
            ctx.lineTo(catCartoonX + 9, tvY + tvH - 53 + catBob);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(catCartoonX + 9, tvY + tvH - 53 + catBob);
            ctx.lineTo(catCartoonX + 12, tvY + tvH - 60 + catBob);
            ctx.lineTo(catCartoonX + 15, tvY + tvH - 53 + catBob);
            ctx.fill();
            // Eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(catCartoonX + 6, tvY + tvH - 46 + catBob, 1.5, 0, Math.PI * 2);
            ctx.arc(catCartoonX + 11, tvY + tvH - 46 + catBob, 1.5, 0, Math.PI * 2);
            ctx.fill();
            // Tail
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(catCartoonX - 10, tvY + tvH - 35 + catBob);
            ctx.quadraticCurveTo(catCartoonX - 18, tvY + tvH - 55 + catBob + Math.sin(interiorAnimationFrame * 0.1) * 5, catCartoonX - 14, tvY + tvH - 50 + catBob);
            ctx.stroke();
            // Legs (walking animation)
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 2;
            const legAnim = Math.sin(interiorAnimationFrame * 0.2);
            ctx.beginPath();
            ctx.moveTo(catCartoonX - 5, tvY + tvH - 27 + catBob);
            ctx.lineTo(catCartoonX - 5 + legAnim * 3, tvY + tvH - 20 + catBob);
            ctx.moveTo(catCartoonX + 5, tvY + tvH - 27 + catBob);
            ctx.lineTo(catCartoonX + 5 - legAnim * 3, tvY + tvH - 20 + catBob);
            ctx.stroke();

            // Flowers on the ground
            ['#FF4444', '#FFFF00', '#FF69B4', '#9370DB'].forEach((col, i) => {
                const fx = tvX + 30 + i * 50;
                ctx.fillStyle = col;
                ctx.beginPath();
                ctx.arc(fx, tvY + tvH - 18, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#228B22';
                ctx.fillRect(fx - 1, tvY + tvH - 15, 2, 8);
            });

            ctx.restore(); // end TV clip

            // TV power LED
            ctx.fillStyle = interiorAnimationFrame % 120 < 100 ? '#00FF00' : '#004400';
            ctx.beginPath();
            ctx.arc(tvX + tvW / 2, tvY + tvH + 3, 2, 0, Math.PI * 2);
            ctx.fill();

            // TV screen glow
            ctx.shadowColor = 'rgba(135, 206, 235, 0.3)';
            ctx.shadowBlur = 15;
            ctx.strokeStyle = 'rgba(135, 206, 235, 0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(tvX - 1, tvY - 1, tvW + 2, tvH + 2);
            ctx.shadowBlur = 0;

            // ===== FOOD BOWLS (right of TV) =====
            const bowlX = 350;
            const bowlY = floorY;

            // Food mat
            ctx.fillStyle = '#E8D5B7';
            ctx.beginPath();
            ctx.ellipse(bowlX + 30, bowlY + 10, 75, 18, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#C4A882';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.ellipse(bowlX + 30, bowlY + 10, 75, 18, 0, 0, Math.PI * 2);
            ctx.stroke();

            // Water bowl (left)
            // Bowl outer
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.ellipse(bowlX - 10, bowlY, 28, 12, 0, 0, Math.PI);
            ctx.fill();
            // Bowl rim
            ctx.fillStyle = '#5B7FDE';
            ctx.beginPath();
            ctx.ellipse(bowlX - 10, bowlY - 2, 30, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#3355B0';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.ellipse(bowlX - 10, bowlY - 2, 30, 10, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Water inside
            ctx.fillStyle = 'rgba(100, 180, 255, 0.6)';
            ctx.beginPath();
            ctx.ellipse(bowlX - 10, bowlY - 3, 24, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            // Water reflection
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.ellipse(bowlX - 15, bowlY - 5, 8, 3, -0.3, 0, Math.PI * 2);
            ctx.fill();
            // Paw print on bowl
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.arc(bowlX - 10, bowlY + 3, 3, 0, Math.PI * 2);
            ctx.fill();
            [[-4,-2],[-2,-5],[2,-5],[4,-2]].forEach(([dx,dy]) => {
                ctx.beginPath();
                ctx.arc(bowlX - 10 + dx, bowlY + 3 + dy, 1.5, 0, Math.PI * 2);
                ctx.fill();
            });

            // Food bowl (right)
            ctx.fillStyle = '#FF6B6B';
            ctx.beginPath();
            ctx.ellipse(bowlX + 60, bowlY, 28, 12, 0, 0, Math.PI);
            ctx.fill();
            ctx.fillStyle = '#FF8585';
            ctx.beginPath();
            ctx.ellipse(bowlX + 60, bowlY - 2, 30, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#CC4444';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.ellipse(bowlX + 60, bowlY - 2, 30, 10, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Kibble pieces
            ctx.fillStyle = '#8B6914';
            const kibblePositions = [
                [0, 0], [-8, -2], [6, -1], [-4, 2], [3, 3],
                [-10, 1], [8, 2], [-2, -4], [5, -3], [-6, 3]
            ];
            kibblePositions.forEach(([kx, ky]) => {
                ctx.beginPath();
                ctx.ellipse(bowlX + 60 + kx, bowlY - 5 + ky, 4, 3, kx * 0.1, 0, Math.PI * 2);
                ctx.fill();
            });
            // Kibble highlight
            ctx.fillStyle = '#A08030';
            kibblePositions.slice(0, 5).forEach(([kx, ky]) => {
                ctx.beginPath();
                ctx.ellipse(bowlX + 60 + kx - 1, bowlY - 6 + ky, 2, 1.5, kx * 0.1, 0, Math.PI * 2);
                ctx.fill();
            });
            // Heart on food bowl
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('â™¥', bowlX + 60, bowlY + 6);

            // ===== LITTER BOX (far right corner) =====
            const litterX = canvas.width - 160;
            const litterY = floorY;

            // Litter box - 3D perspective
            // Back wall
            ctx.fillStyle = '#A8C8A8';
            ctx.beginPath();
            ctx.moveTo(litterX, litterY - 50);
            ctx.lineTo(litterX + 110, litterY - 50);
            ctx.lineTo(litterX + 100, litterY - 35);
            ctx.lineTo(litterX + 10, litterY - 35);
            ctx.closePath();
            ctx.fill();
            // Left side
            ctx.fillStyle = '#8FB88F';
            ctx.beginPath();
            ctx.moveTo(litterX, litterY - 50);
            ctx.lineTo(litterX + 10, litterY - 35);
            ctx.lineTo(litterX + 10, litterY + 10);
            ctx.lineTo(litterX, litterY + 5);
            ctx.closePath();
            ctx.fill();
            // Right side
            ctx.fillStyle = '#8FB88F';
            ctx.beginPath();
            ctx.moveTo(litterX + 110, litterY - 50);
            ctx.lineTo(litterX + 100, litterY - 35);
            ctx.lineTo(litterX + 100, litterY + 10);
            ctx.lineTo(litterX + 110, litterY + 5);
            ctx.closePath();
            ctx.fill();
            // Front
            ctx.fillStyle = '#A8C8A8';
            ctx.fillRect(litterX + 10, litterY - 15, 90, 25);
            // Rim
            ctx.fillStyle = '#7DA87D';
            ctx.fillRect(litterX + 5, litterY - 18, 100, 6);

            // Litter (sandy texture)
            ctx.fillStyle = '#E8D8B8';
            ctx.beginPath();
            ctx.ellipse(litterX + 55, litterY - 22, 42, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            // Litter texture dots
            ctx.fillStyle = '#D4C4A4';
            for (let i = 0; i < 30; i++) {
                const lx = litterX + 20 + (i * 17 + i * i * 3) % 70;
                const ly = litterY - 30 + (i * 13 + i * 7) % 16;
                ctx.beginPath();
                ctx.arc(lx, ly, 1 + (i % 2), 0, Math.PI * 2);
                ctx.fill();
            }
            // Small scoop next to litter box
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.moveTo(litterX + 115, litterY - 5);
            ctx.lineTo(litterX + 118, litterY - 45);
            ctx.lineTo(litterX + 121, litterY - 45);
            ctx.lineTo(litterX + 125, litterY - 5);
            ctx.closePath();
            ctx.fill();
            // Scoop head
            ctx.fillStyle = '#5B7FDE';
            ctx.beginPath();
            ctx.ellipse(litterX + 119, litterY - 47, 8, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            // Holes in scoop
            ctx.fillStyle = '#4169E1';
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(litterX + 116 + i * 4, litterY - 47, 1, 0, Math.PI * 2);
                ctx.fill();
            }

            // ===== TOYS (scattered on floor) =====

            // Ball (bouncy ball with stripes)
            const ballX = canvas.width / 2 + 100;
            const ballY = floorY + 30;
            const ballBounce = Math.abs(Math.sin(interiorAnimationFrame * 0.03)) * 10;
            ctx.save();
            ctx.fillStyle = '#FF4444';
            ctx.beginPath();
            ctx.arc(ballX, ballY - ballBounce, 14, 0, Math.PI * 2);
            ctx.fill();
            // Ball stripe
            ctx.fillStyle = '#FFFF44';
            ctx.beginPath();
            ctx.arc(ballX, ballY - ballBounce, 14, -0.3, 0.3);
            ctx.arc(ballX, ballY - ballBounce, 14, Math.PI - 0.3, Math.PI + 0.3);
            ctx.fill();
            ctx.fillStyle = '#FFFF44';
            ctx.fillRect(ballX - 14, ballY - ballBounce - 3, 28, 6);
            // Ball highlight
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.arc(ballX - 4, ballY - ballBounce - 5, 4, 0, Math.PI * 2);
            ctx.fill();
            // Ball shadow
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath();
            ctx.ellipse(ballX, ballY + 14, 10, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Mouse toy (grey mouse on string)
            const mouseX = canvas.width / 2 - 120;
            const mouseY = floorY + 40;
            // String
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(mouseX + 25, mouseY - 5);
            ctx.quadraticCurveTo(mouseX + 40, mouseY - 20, mouseX + 50, mouseY - 5 + Math.sin(interiorAnimationFrame * 0.04) * 5);
            ctx.stroke();
            // Mouse body
            ctx.fillStyle = '#999';
            ctx.beginPath();
            ctx.ellipse(mouseX, mouseY, 15, 10, 0.1, 0, Math.PI * 2);
            ctx.fill();
            // Belly
            ctx.fillStyle = '#BBB';
            ctx.beginPath();
            ctx.ellipse(mouseX + 2, mouseY + 2, 10, 6, 0.1, 0, Math.PI * 2);
            ctx.fill();
            // Ears
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.arc(mouseX - 8, mouseY - 10, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#999';
            ctx.beginPath();
            ctx.arc(mouseX - 8, mouseY - 10, 6, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.arc(mouseX - 1, mouseY - 10, 5, 0, Math.PI * 2);
            ctx.fill();
            // Eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(mouseX - 8, mouseY - 3, 1.5, 0, Math.PI * 2);
            ctx.fill();
            // Nose
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.arc(mouseX - 14, mouseY - 1, 2, 0, Math.PI * 2);
            ctx.fill();
            // Whiskers
            ctx.strokeStyle = '#777';
            ctx.lineWidth = 0.5;
            [[-1, -3], [0, 0], [1, 3]].forEach(([_, dy]) => {
                ctx.beginPath();
                ctx.moveTo(mouseX - 14, mouseY - 1 + dy);
                ctx.lineTo(mouseX - 25, mouseY - 3 + dy);
                ctx.stroke();
            });
            // Tail
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(mouseX + 14, mouseY);
            ctx.quadraticCurveTo(mouseX + 25, mouseY - 10 + Math.sin(interiorAnimationFrame * 0.06) * 3, mouseX + 28, mouseY - 5);
            ctx.stroke();

            // Yarn ball
            const yarnX = 500;
            const yarnY = floorY + 35;
            ctx.fillStyle = '#9370DB';
            ctx.beginPath();
            ctx.arc(yarnX, yarnY, 12, 0, Math.PI * 2);
            ctx.fill();
            // Yarn threads
            ctx.strokeStyle = '#7B57C4';
            ctx.lineWidth = 1;
            for (let i = 0; i < 6; i++) {
                const a1 = i * 0.9;
                const a2 = a1 + 2;
                ctx.beginPath();
                ctx.arc(yarnX, yarnY, 10, a1, a2);
                ctx.stroke();
            }
            // Yarn highlight
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.arc(yarnX - 3, yarnY - 4, 4, 0, Math.PI * 2);
            ctx.fill();
            // Trailing thread
            ctx.strokeStyle = '#9370DB';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(yarnX + 12, yarnY);
            ctx.quadraticCurveTo(yarnX + 30, yarnY + 15, yarnX + 50, yarnY + 5);
            ctx.quadraticCurveTo(yarnX + 65, yarnY - 5, yarnX + 70, yarnY + 10);
            ctx.stroke();

            // Feather wand toy (leaning against wall)
            const wandX = canvas.width - 50;
            const wandBaseY = floorY;
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(wandX, wandBaseY);
            ctx.lineTo(wandX - 15, floorY - 120);
            ctx.stroke();
            // Feathers
            const featherColors = ['#FF69B4', '#FF4500', '#FFD700', '#9370DB', '#00CED1'];
            featherColors.forEach((col, i) => {
                ctx.fillStyle = col;
                ctx.save();
                ctx.translate(wandX - 15, floorY - 120);
                ctx.rotate(-0.5 + i * 0.25 + Math.sin(interiorAnimationFrame * 0.04 + i) * 0.1);
                ctx.beginPath();
                ctx.ellipse(0, -15, 3, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                // Feather spine
                ctx.strokeStyle = col;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(0, -3);
                ctx.lineTo(0, -25);
                ctx.stroke();
                ctx.restore();
            });

            // ===== EXIT DOOR (right wall, moved left to avoid wardrobe panel) =====
            const doorX = canvas.width - 350;
            const doorY = floorY - 160;
            // Door frame
            ctx.fillStyle = '#DDD';
            ctx.fillRect(doorX - 5, doorY - 5, 75, 165);
            // Door
            const doorGrad = ctx.createLinearGradient(doorX, doorY, doorX + 65, doorY);
            doorGrad.addColorStop(0, '#8B6238');
            doorGrad.addColorStop(0.5, '#A0764B');
            doorGrad.addColorStop(1, '#8B6238');
            ctx.fillStyle = doorGrad;
            ctx.fillRect(doorX, doorY, 65, 155);
            // Door panels
            ctx.strokeStyle = '#704E2E';
            ctx.lineWidth = 2;
            ctx.strokeRect(doorX + 8, doorY + 10, 49, 55);
            ctx.strokeRect(doorX + 8, doorY + 80, 49, 55);
            // Door knob
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(doorX + 55, doorY + 80, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#DAA520';
            ctx.beginPath();
            ctx.arc(doorX + 55, doorY + 80, 3, 0, Math.PI * 2);
            ctx.fill();

            // Exit sign
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            const signW = 140;
            const signH = 28;
            const signX = canvas.width - signW - 15;
            const signY = 12;
            // Rounded sign
            ctx.beginPath();
            ctx.roundRect(signX, signY, signW, signH, 8);
            ctx.fill();
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(signX, signY, signW, signH, 8);
            ctx.stroke();
            ctx.fillStyle = '#FF1493';
            ctx.font = 'bold 15px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('SPACJA - WyjdÅº', signX + signW / 2, signY + 19);

            // ===== WINDOW on wall (between TV and food) =====
            const winX = 320;
            const winY = 60;
            const winW = 100;
            const winH = 80;
            // Window frame
            ctx.fillStyle = '#FFF';
            ctx.fillRect(winX - 5, winY - 5, winW + 10, winH + 10);
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 2;
            ctx.strokeRect(winX - 5, winY - 5, winW + 10, winH + 10);
            // Sky through window
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(winX, winY, winW, winH);
            // Window cross
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(winX + winW / 2, winY);
            ctx.lineTo(winX + winW / 2, winY + winH);
            ctx.moveTo(winX, winY + winH / 2);
            ctx.lineTo(winX + winW, winY + winH / 2);
            ctx.stroke();
            // Curtains
            ctx.fillStyle = '#FFB6C1';
            ctx.globalAlpha = 0.7;
            // Left curtain
            ctx.beginPath();
            ctx.moveTo(winX - 10, winY - 10);
            ctx.quadraticCurveTo(winX + 15, winY + winH / 2, winX - 5, winY + winH + 15);
            ctx.lineTo(winX - 15, winY + winH + 15);
            ctx.lineTo(winX - 15, winY - 10);
            ctx.closePath();
            ctx.fill();
            // Right curtain
            ctx.beginPath();
            ctx.moveTo(winX + winW + 10, winY - 10);
            ctx.quadraticCurveTo(winX + winW - 15, winY + winH / 2, winX + winW + 5, winY + winH + 15);
            ctx.lineTo(winX + winW + 15, winY + winH + 15);
            ctx.lineTo(winX + winW + 15, winY - 10);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1;
            // Curtain rod
            ctx.strokeStyle = '#DAA520';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(winX - 20, winY - 10);
            ctx.lineTo(winX + winW + 20, winY - 10);
            ctx.stroke();
            // Rod ends
            ctx.fillStyle = '#DAA520';
            ctx.beginPath();
            ctx.arc(winX - 20, winY - 10, 4, 0, Math.PI * 2);
            ctx.arc(winX + winW + 20, winY - 10, 4, 0, Math.PI * 2);
            ctx.fill();

            // ===== WALL PICTURE (small framed picture) =====
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(545, 70, 60, 50);
            ctx.fillStyle = '#FFF';
            ctx.fillRect(550, 75, 50, 40);
            // Little heart drawing inside
            ctx.fillStyle = '#FF69B4';
            ctx.font = '25px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('â™¥', 575, 102);

            // ===== BED (upper-left, against back wall) =====
            const bedX = 30;
            const bedY = floorY - 10;
            const bedW = 120;
            const bedH = 50;

            // Bed legs
            ctx.fillStyle = '#5C3D2E';
            ctx.fillRect(bedX + 5, bedY + bedH - 5, 8, 15);
            ctx.fillRect(bedX + bedW - 13, bedY + bedH - 5, 8, 15);
            // Bed frame
            ctx.fillStyle = '#7B5B3A';
            ctx.fillRect(bedX, bedY, bedW, bedH);
            // Headboard
            const hbGrad = ctx.createLinearGradient(bedX, bedY - 40, bedX, bedY);
            hbGrad.addColorStop(0, '#5C3D2E');
            hbGrad.addColorStop(1, '#7B5B3A');
            ctx.fillStyle = hbGrad;
            ctx.beginPath();
            ctx.moveTo(bedX - 5, bedY);
            ctx.lineTo(bedX - 5, bedY - 35);
            ctx.quadraticCurveTo(bedX + 15, bedY - 45, bedX + 35, bedY - 35);
            ctx.lineTo(bedX + 35, bedY);
            ctx.closePath();
            ctx.fill();
            // Mattress
            ctx.fillStyle = '#FFF5EE';
            ctx.fillRect(bedX + 3, bedY + 3, bedW - 6, bedH - 10);
            // Blanket
            const blanketGrad = ctx.createLinearGradient(bedX, bedY, bedX + bedW, bedY);
            blanketGrad.addColorStop(0, '#FF85A2');
            blanketGrad.addColorStop(0.5, '#FFB6C1');
            blanketGrad.addColorStop(1, '#FF85A2');
            ctx.fillStyle = blanketGrad;
            ctx.fillRect(bedX + 35, bedY + 5, bedW - 40, bedH - 12);
            // Blanket fold line
            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(bedX + 35, bedY + 15);
            ctx.lineTo(bedX + bedW - 5, bedY + 15);
            ctx.stroke();
            // Pillow
            ctx.fillStyle = '#FFFAF0';
            ctx.beginPath();
            ctx.ellipse(bedX + 18, bedY + 18, 14, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#EEE';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.ellipse(bedX + 18, bedY + 18, 14, 10, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Footboard
            ctx.fillStyle = '#5C3D2E';
            ctx.fillRect(bedX + bedW - 5, bedY + 5, 5, bedH - 5);

            // ===== TOILET (middle area, visible - not covered by wardrobe) =====
            const toiletX = 450;
            const toiletY = floorY;

            // Bathroom tile floor area
            ctx.fillStyle = 'rgba(200, 220, 240, 0.4)';
            ctx.fillRect(toiletX - 40, floorY, 200, canvas.height - floorY);
            // Tile lines
            ctx.strokeStyle = 'rgba(180, 200, 220, 0.3)';
            ctx.lineWidth = 1;
            for (let ty = floorY; ty < canvas.height; ty += 20) {
                ctx.beginPath();
                ctx.moveTo(toiletX - 40, ty);
                ctx.lineTo(toiletX + 160, ty);
                ctx.stroke();
            }
            for (let tx = toiletX - 40; tx < toiletX + 160; tx += 20) {
                ctx.beginPath();
                ctx.moveTo(tx, floorY);
                ctx.lineTo(tx, canvas.height);
                ctx.stroke();
            }

            // Toilet base
            ctx.fillStyle = '#F5F5F5';
            ctx.beginPath();
            ctx.ellipse(toiletX, toiletY + 10, 22, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            // Toilet bowl
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.moveTo(toiletX - 18, toiletY - 25);
            ctx.lineTo(toiletX + 18, toiletY - 25);
            ctx.quadraticCurveTo(toiletX + 25, toiletY, toiletX + 20, toiletY + 8);
            ctx.lineTo(toiletX - 20, toiletY + 8);
            ctx.quadraticCurveTo(toiletX - 25, toiletY, toiletX - 18, toiletY - 25);
            ctx.fill();
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(toiletX - 18, toiletY - 25);
            ctx.lineTo(toiletX + 18, toiletY - 25);
            ctx.quadraticCurveTo(toiletX + 25, toiletY, toiletX + 20, toiletY + 8);
            ctx.lineTo(toiletX - 20, toiletY + 8);
            ctx.quadraticCurveTo(toiletX - 25, toiletY, toiletX - 18, toiletY - 25);
            ctx.stroke();
            // Seat
            ctx.fillStyle = '#FAFAFA';
            ctx.beginPath();
            ctx.ellipse(toiletX, toiletY - 12, 16, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#E0E0E0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(toiletX, toiletY - 12, 16, 10, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Water inside
            ctx.fillStyle = 'rgba(173, 216, 230, 0.5)';
            ctx.beginPath();
            ctx.ellipse(toiletX, toiletY - 12, 12, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            // Tank
            ctx.fillStyle = '#F0F0F0';
            ctx.fillRect(toiletX - 15, toiletY - 55, 30, 30);
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(toiletX - 15, toiletY - 55, 30, 30);
            // Flush handle
            ctx.strokeStyle = '#CCC';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(toiletX + 10, toiletY - 45);
            ctx.lineTo(toiletX + 20, toiletY - 48);
            ctx.stroke();
            ctx.fillStyle = '#CCC';
            ctx.beginPath();
            ctx.arc(toiletX + 20, toiletY - 48, 3, 0, Math.PI * 2);
            ctx.fill();
            // Toilet paper holder
            ctx.fillStyle = '#CCC';
            ctx.fillRect(toiletX + 30, toiletY - 30, 3, 25);
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(toiletX + 31, toiletY - 30, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#EEE';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(toiletX + 31, toiletY - 30, 10, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(toiletX + 31, toiletY - 30, 4, 0, Math.PI * 2);
            ctx.stroke();

            // ===== SINK (next to toilet) =====
            const sinkX = toiletX + 80;
            const sinkY = floorY - 60;

            // Sink pipe (going to wall)
            ctx.fillStyle = '#CCC';
            ctx.fillRect(sinkX - 3, sinkY + 40, 6, floorY - sinkY - 30);
            // Sink pedestal
            ctx.fillStyle = '#F0F0F0';
            ctx.fillRect(sinkX - 8, sinkY + 30, 16, 35);
            // Sink basin
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.ellipse(sinkX, sinkY + 15, 28, 15, 0, 0, Math.PI);
            ctx.fill();
            ctx.fillStyle = '#FAFAFA';
            ctx.beginPath();
            ctx.ellipse(sinkX, sinkY + 10, 30, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(sinkX, sinkY + 10, 30, 12, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Water in sink
            ctx.fillStyle = 'rgba(173, 216, 230, 0.3)';
            ctx.beginPath();
            ctx.ellipse(sinkX, sinkY + 11, 24, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            // Drain
            ctx.fillStyle = '#AAA';
            ctx.beginPath();
            ctx.arc(sinkX, sinkY + 13, 3, 0, Math.PI * 2);
            ctx.fill();
            // Faucet
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(sinkX - 3, sinkY - 15, 6, 20);
            // Faucet top curve
            ctx.strokeStyle = '#C0C0C0';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(sinkX, sinkY - 15, 10, Math.PI, 0);
            ctx.stroke();
            // Faucet spout
            ctx.fillStyle = '#B0B0B0';
            ctx.fillRect(sinkX + 7, sinkY - 15, 5, 10);
            // Faucet handles
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.arc(sinkX - 15, sinkY - 5, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FF4444';
            ctx.beginPath();
            ctx.arc(sinkX + 15, sinkY - 5, 5, 0, Math.PI * 2);
            ctx.fill();
            // Mirror above sink
            ctx.fillStyle = '#E8E8FF';
            ctx.beginPath();
            ctx.ellipse(sinkX, sinkY - 50, 25, 30, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#DAA520';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(sinkX, sinkY - 50, 25, 30, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Mirror reflection
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.ellipse(sinkX - 8, sinkY - 55, 8, 12, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // ===== BATHTUB (next to sink) =====
            const bathtubX = sinkX + 120;
            const bathtubY = floorY;
            const bathtubW = 100;
            const bathtubH = 50;

            // Bathtub body
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.moveTo(bathtubX - bathtubW / 2 + 10, bathtubY - bathtubH);
            ctx.lineTo(bathtubX + bathtubW / 2 - 10, bathtubY - bathtubH);
            ctx.quadraticCurveTo(bathtubX + bathtubW / 2, bathtubY - bathtubH / 2, bathtubX + bathtubW / 2 - 5, bathtubY - 10);
            ctx.lineTo(bathtubX - bathtubW / 2 + 5, bathtubY - 10);
            ctx.quadraticCurveTo(bathtubX - bathtubW / 2, bathtubY - bathtubH / 2, bathtubX - bathtubW / 2 + 10, bathtubY - bathtubH);
            ctx.fill();
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Bathtub legs
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(bathtubX - bathtubW / 2 + 10, bathtubY - 10, 8, 15);
            ctx.fillRect(bathtubX + bathtubW / 2 - 18, bathtubY - 10, 8, 15);

            // Faucet/tap
            ctx.strokeStyle = '#C0C0C0';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(bathtubX - 20, bathtubY - bathtubH - 5);
            ctx.lineTo(bathtubX - 20, bathtubY - bathtubH - 15);
            ctx.lineTo(bathtubX, bathtubY - bathtubH - 15);
            ctx.stroke();

            // Tap handle (blue)
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.arc(bathtubX - 20, bathtubY - bathtubH - 18, 5, 0, Math.PI * 2);
            ctx.fill();

            // Water level indicator (stored in interiorPlayer for persistence)
            if (!interiorPlayer.bathtubWaterLevel) interiorPlayer.bathtubWaterLevel = 0;
            if (interiorPlayer.bathtubWaterLevel > 0) {
                const waterH = bathtubH * 0.7 * interiorPlayer.bathtubWaterLevel;
                ctx.fillStyle = `rgba(100, 180, 255, ${0.3 + interiorPlayer.bathtubWaterLevel * 0.3})`;
                ctx.beginPath();
                ctx.ellipse(bathtubX, bathtubY - 10 - waterH / 2, bathtubW / 2 - 8, waterH / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                // Water surface reflection
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.ellipse(bathtubX - 15, bathtubY - 10 - waterH, 15, 5, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // ===== TITLE & INFO =====
            ctx.fillStyle = '#8B4513';
            ctx.font = 'bold 28px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('ğŸ  Dom KicioroÅ¼ka ğŸ ', canvas.width / 2, 35);

            ctx.font = 'bold 18px Comic Sans MS';
            ctx.fillStyle = '#A0764B';
            ctx.fillText(`Przyjaciele w domu: ${interiorFriends.length}/${friendTypes.length}`, canvas.width / 2, 60);

            // ===== UPDATE & DRAW FRIENDS =====
            updateInteriorFriends();
            interiorFriends.forEach(friend => {
                drawInteriorFriend(friend);
            });

            // ===== INTERIOR PLAYER MOVEMENT & INTERACTIONS =====
            updateInteriorPlayer(floorY, bedX, bedW, toiletX, sinkX, bathtubX);

            // ===== DRAW PLAYER IN INTERIOR =====
            drawInteriorPlayer(floorY, bedX, bedY, bedW, bedH);

            // ===== INTERACTION HINTS =====
            drawInteriorHints(bedX, bedW, toiletX, sinkX, bathtubX, floorY);
        }

        function updateInteriorFriends() {
            interiorFriends.forEach(friend => {
                friend.activityTimer--;
                friend.animFrame++;

                // Change activity periodically
                if (friend.activityTimer <= 0) {
                    friend.activity = ['walking', 'jumping', 'playing'][Math.floor(Math.random() * 3)];
                    friend.activityTimer = 100 + Math.floor(Math.random() * 100);

                    if (friend.activity === 'jumping') {
                        friend.jumpPower = -10;
                    }
                }

                // Activity behaviors
                if (friend.activity === 'walking') {
                    friend.x += friend.velX;

                    // Bounce off walls
                    if (friend.x < 50 || friend.x > canvas.width - 50) {
                        friend.velX *= -1;
                        friend.x = Math.max(50, Math.min(canvas.width - 50, friend.x));
                    }
                } else if (friend.activity === 'jumping') {
                    friend.velY += 0.6; // gravity
                    friend.y += friend.velY;

                    // Land on floor
                    if (friend.y >= canvas.height - 200) {
                        friend.y = canvas.height - 200;
                        friend.velY = 0;
                        if (friend.jumpPower < 0) {
                            friend.velY = friend.jumpPower;
                            friend.jumpPower = 0;
                        }
                    }
                } else if (friend.activity === 'playing') {
                    // Slight bobbing animation
                    friend.y = canvas.height - 200 + Math.sin(friend.animFrame * 0.1) * 5;
                }
            });
        }

        function drawInteriorFriend(friend) {
            ctx.save();

            // Use the same real graphics as in the world
            const drawFunctions = {
                'ğŸ¶': drawDog,
                'ğŸ°': drawRabbit,
                'ğŸ»': drawBear,
                'ğŸ‘': drawSheep,
                'ğŸ¬': drawDolphin,
                'ğŸ¦Š': drawFox,
                'ğŸ¼': drawPanda,
                'ğŸ¦„': drawUnicorn,
                'ğŸ¸': drawFrog,
                'ğŸ¦‹': drawButterfly
            };

            const drawFunction = drawFunctions[friend.type.emoji] || drawDog;
            drawFunction(friend.x, friend.y, 1);

            ctx.restore();
        }

        // ========== INTERIOR PLAYER SYSTEM ==========

        function updateInteriorPlayer(floorY, bedX, bedW, toiletX, sinkX, bathtubX) {
            // If performing an action, count down the timer
            if (interiorPlayer.action !== 'none') {
                interiorPlayer.actionTimer--;
                if (interiorPlayer.actionTimer <= 0) {
                    if (interiorPlayer.action === 'filling_water') {
                        // Finished filling - increase water level
                        if (!interiorPlayer.bathtubWaterLevel) interiorPlayer.bathtubWaterLevel = 0;
                        interiorPlayer.bathtubWaterLevel = Math.min(1, interiorPlayer.bathtubWaterLevel + 0.34);
                        interiorPlayer.action = 'none';
                    } else if (interiorPlayer.action !== 'sleeping') {
                        interiorPlayer.action = 'none';
                    }
                }
                return; // Don't move while doing an action (except sleeping can be cancelled)
            }

            // Movement with arrow keys / A,D
            const speed = 4;
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                interiorPlayer.x -= speed;
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                interiorPlayer.x += speed;
            }

            // Clamp to room bounds
            interiorPlayer.x = Math.max(30, Math.min(canvas.width - 30, interiorPlayer.x));
            interiorPlayer.y = floorY - 20;
        }

        function drawInteriorPlayer(floorY, bedX, bedY, bedW, bedH) {
            ctx.save();

            if (interiorPlayer.action === 'sleeping') {
                // Draw player lying in bed
                const sleepX = bedX + 50;
                const sleepY = bedY + 10;

                // Draw player horizontally (rotated to left side)
                ctx.save();
                ctx.translate(sleepX, sleepY);
                ctx.rotate(-Math.PI / 2); // Lying on left side (facing down)
                ctx.scale(0.7, 0.7);
                drawPlayer(0, 0);
                ctx.restore();

                // Blanket covering player
                ctx.fillStyle = 'rgba(255, 133, 162, 0.6)';
                ctx.fillRect(bedX + 40, bedY + 15, bedW - 48, bedH - 22);

                // Zzz animation
                const zzzTime = interiorAnimationFrame * 0.03;
                for (let i = 0; i < 3; i++) {
                    const zOffset = ((zzzTime + i * 0.8) % 2.4);
                    const zAlpha = Math.max(0, 1 - zOffset / 2.4);
                    const zSize = 14 + i * 4 + zOffset * 8;
                    const zx = sleepX + 10 + zOffset * 15 + i * 8;
                    const zy = sleepY - 15 - zOffset * 25;

                    ctx.fillStyle = `rgba(100, 100, 200, ${zAlpha * 0.8})`;
                    ctx.font = `bold ${zSize}px Comic Sans MS`;
                    ctx.textAlign = 'center';
                    ctx.fillText('Z', zx, zy);
                }

            } else if (interiorPlayer.action === 'toilet') {
                // Draw player sitting on toilet
                const tx = interiorPlayer.x;
                const ty = interiorPlayer.y - 15;
                ctx.save();
                ctx.scale(0.8, 0.8);
                ctx.translate(tx * 0.25, ty * 0.25 + 5);
                drawPlayer(tx, ty);
                ctx.restore();

                // Reading newspaper
                ctx.fillStyle = '#F5F5DC';
                ctx.fillRect(tx + 15, ty + 5, 20, 25);
                ctx.strokeStyle = '#AAA';
                ctx.lineWidth = 1;
                ctx.strokeRect(tx + 15, ty + 5, 20, 25);
                // Newspaper lines
                ctx.strokeStyle = '#CCC';
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.moveTo(tx + 17, ty + 12 + i * 5);
                    ctx.lineTo(tx + 33, ty + 12 + i * 5);
                    ctx.stroke();
                }

                // Timer indicator
                if (interiorPlayer.actionTimer > 0) {
                    const prog = 1 - interiorPlayer.actionTimer / 120;
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.beginPath();
                    ctx.roundRect(tx - 25, ty - 35, 50, 18, 5);
                    ctx.fill();
                    // Progress bar
                    ctx.fillStyle = '#90EE90';
                    ctx.beginPath();
                    ctx.roundRect(tx - 22, ty - 32, 44 * prog, 12, 3);
                    ctx.fill();
                }

            } else if (interiorPlayer.action === 'washing') {
                // Draw player at sink
                const wx = interiorPlayer.x;
                const wy = interiorPlayer.y;
                drawPlayer(wx, wy);

                // Water splash particles
                for (let i = 0; i < 5; i++) {
                    const splashX = wx + 10 + Math.sin(interiorAnimationFrame * 0.2 + i * 1.5) * 10;
                    const splashY = wy - 10 - Math.abs(Math.sin(interiorAnimationFrame * 0.15 + i)) * 15;
                    ctx.fillStyle = `rgba(100, 180, 255, ${0.5 + Math.sin(interiorAnimationFrame * 0.1 + i) * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(splashX, splashY, 2 + Math.sin(interiorAnimationFrame * 0.1 + i) * 1, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Soap bubbles
                for (let i = 0; i < 4; i++) {
                    const bx = wx + Math.sin(interiorAnimationFrame * 0.04 + i * 2) * 20;
                    const by = wy - 20 - ((interiorAnimationFrame * 0.5 + i * 15) % 40);
                    const br = 3 + Math.sin(i) * 1.5;
                    ctx.strokeStyle = 'rgba(200, 220, 255, 0.6)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(bx, by, br, 0, Math.PI * 2);
                    ctx.stroke();
                    // Bubble highlight
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(bx - 1, by - 1, br * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Timer
                if (interiorPlayer.actionTimer > 0) {
                    const prog = 1 - interiorPlayer.actionTimer / 90;
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.beginPath();
                    ctx.roundRect(wx - 25, wy - 55, 50, 18, 5);
                    ctx.fill();
                    ctx.fillStyle = '#87CEEB';
                    ctx.beginPath();
                    ctx.roundRect(wx - 22, wy - 52, 44 * prog, 12, 3);
                    ctx.fill();
                }

            } else if (interiorPlayer.action === 'filling_water') {
                // Draw player at bathtub filling water
                const fx = interiorPlayer.x;
                const fy = interiorPlayer.y;
                drawPlayer(fx, fy);

                // Water stream from tap
                for (let i = 0; i < 8; i++) {
                    const streamX = fx - 20 + Math.sin(interiorAnimationFrame * 0.3 + i * 0.5) * 2;
                    const streamY = fy - 50 + i * 5;
                    ctx.fillStyle = `rgba(100, 180, 255, ${0.6 - i * 0.05})`;
                    ctx.beginPath();
                    ctx.arc(streamX, streamY, 3 - i * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Splash particles at water surface
                for (let i = 0; i < 5; i++) {
                    const splashX = fx + Math.sin(interiorAnimationFrame * 0.2 + i * 1.3) * 20;
                    const splashY = fy - 10 - Math.abs(Math.sin(interiorAnimationFrame * 0.25 + i)) * 8;
                    ctx.fillStyle = `rgba(100, 180, 255, ${0.5 + Math.sin(interiorAnimationFrame * 0.1 + i) * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(splashX, splashY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Progress indicator
                const waterProgress = 1 - interiorPlayer.actionTimer / 30;
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.beginPath();
                ctx.roundRect(fx - 30, fy - 70, 60, 18, 5);
                ctx.fill();
                ctx.fillStyle = '#87CEEB';
                ctx.beginPath();
                ctx.roundRect(fx - 27, fy - 67, 54 * waterProgress, 12, 3);
                ctx.fill();
                // Water drop icon
                ctx.font = '14px Arial';
                ctx.fillText('ğŸ’§', fx - 10, fy - 58);

            } else if (interiorPlayer.action === 'bathing') {
                // Draw player in bathtub
                const bx = interiorPlayer.x;
                const by = interiorPlayer.y;

                // Player sitting in tub (scaled down)
                ctx.save();
                ctx.translate(bx, by - 15);
                ctx.scale(0.8, 0.8);
                drawPlayer(0, 0);
                ctx.restore();

                // Soap bubbles floating up
                for (let i = 0; i < 8; i++) {
                    const bubbleX = bx + Math.sin(interiorAnimationFrame * 0.05 + i) * 30;
                    const bubbleY = by - 30 - ((interiorAnimationFrame + i * 10) % 50);
                    const bubbleR = 3 + Math.sin(i) * 1.5;
                    ctx.strokeStyle = 'rgba(200, 220, 255, 0.6)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(bubbleX, bubbleY, bubbleR, 0, Math.PI * 2);
                    ctx.stroke();
                    // Highlight
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(bubbleX - 1, bubbleY - 1, bubbleR * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Happy emoji
                ctx.font = '20px Arial';
                ctx.fillText('ğŸ˜Š', bx + 15, by - 35 + Math.sin(interiorAnimationFrame * 0.1) * 3);

                // Timer
                if (interiorPlayer.actionTimer > 0) {
                    const prog = 1 - interiorPlayer.actionTimer / 180;
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.beginPath();
                    ctx.roundRect(bx - 25, by - 65, 50, 18, 5);
                    ctx.fill();
                    ctx.fillStyle = '#87CEEB';
                    ctx.beginPath();
                    ctx.roundRect(bx - 22, by - 62, 44 * prog, 12, 3);
                    ctx.fill();
                }

            } else if (interiorPlayer.action === 'eating') {
                // Draw player eating at food bowls
                const px = interiorPlayer.x;
                const py = interiorPlayer.y;
                drawPlayer(px, py);

                // Eating emoji
                ctx.font = '24px Arial';
                ctx.fillText('ğŸ˜‹', px + 15, py - 30 + Math.sin(interiorAnimationFrame * 0.1) * 3);

                // Yummy particles
                for (let i = 0; i < 3; i++) {
                    const yumX = px + 10 + Math.sin(interiorAnimationFrame * 0.1 + i * 2) * 10;
                    const yumY = py - 15 - ((interiorAnimationFrame * 0.3 + i * 20) % 30);
                    ctx.font = '12px Arial';
                    ctx.globalAlpha = Math.max(0, 1 - ((interiorAnimationFrame * 0.3 + i * 20) % 30) / 30);
                    ctx.fillText('â™¥', yumX, yumY);
                }
                ctx.globalAlpha = 1;

            } else if (interiorPlayer.action === 'playing') {
                // Draw player playing with ball
                const px = interiorPlayer.x;
                const py = interiorPlayer.y;

                // Player jumping
                const jumpY = py + Math.sin(interiorAnimationFrame * 0.2) * 8;
                drawPlayer(px, jumpY);

                // Ball being tossed up and down
                const ballThrowY = py - 40 - Math.abs(Math.sin(interiorAnimationFrame * 0.15)) * 30;
                const ballThrowX = px + Math.sin(interiorAnimationFrame * 0.15) * 15;

                ctx.fillStyle = '#FF4444';
                ctx.beginPath();
                ctx.arc(ballThrowX, ballThrowY, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFFF44';
                ctx.fillRect(ballThrowX - 12, ballThrowY - 2, 24, 4);

                // Happy emoji
                ctx.font = '18px Arial';
                ctx.fillText('ğŸ˜„', px - 25, py - 25);

            } else {
                // Normal standing - draw player at current position
                drawPlayer(interiorPlayer.x, interiorPlayer.y);
            }

            ctx.restore();
        }

        function drawInteriorHints(bedX, bedW, toiletX, sinkX, bathtubX, floorY) {
            if (interiorPlayer.action !== 'none') return;

            const px = interiorPlayer.x;
            ctx.textAlign = 'center';

            // Near bed?
            if (px > bedX - 20 && px < bedX + bedW + 20) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(bedX + bedW / 2 - 55, floorY - 85, 110, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#9370DB';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(bedX + bedW / 2 - 55, floorY - 85, 110, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#6A5ACD';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - Åšpij ğŸ’¤', bedX + bedW / 2, floorY - 67);
            }

            // Near toilet?
            if (Math.abs(px - toiletX) < 40) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(toiletX - 60, floorY - 85, 120, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#4169E1';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(toiletX - 60, floorY - 85, 120, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#4169E1';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - Toaleta ğŸš½', toiletX, floorY - 67);
            }

            // Near sink?
            if (Math.abs(px - sinkX) < 40) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(sinkX - 65, floorY - 85, 130, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#4169E1';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(sinkX - 65, floorY - 85, 130, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#4169E1';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - Umyj rÄ™ce ğŸ§¼', sinkX, floorY - 67);
            }

            // Near bathtub?
            if (Math.abs(px - bathtubX) < 60) {
                const waterLevel = interiorPlayer.bathtubWaterLevel || 0;
                const hintText = waterLevel < 1 ? 'SPACJA - NapuÅ›Ä‡ wodÄ™ ğŸ’§' : 'SPACJA - KÄ…piel ğŸ›';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(bathtubX - 75, floorY - 85, 150, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#87CEEB';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(bathtubX - 75, floorY - 85, 150, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#87CEEB';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText(hintText, bathtubX, floorY - 67);
            }

            // Near food bowls?
            const bowlX = 350;
            if (Math.abs(px - bowlX) < 60) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(bowlX - 55, floorY - 85, 110, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(bowlX - 55, floorY - 85, 110, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#FF6B6B';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - Jedz ğŸ½ï¸', bowlX, floorY - 67);
            }

            // Near ball?
            const ballX = canvas.width / 2 + 100;
            if (Math.abs(px - ballX) < 50) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(ballX - 65, floorY - 85, 130, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#FF4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(ballX - 65, floorY - 85, 130, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#FF4444';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - PodrzuÄ‡ ğŸ¾', ballX, floorY - 67);
            }

            // Near exit door?
            const doorX = canvas.width - 350;
            if (px > doorX - 50) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(doorX - 30, floorY - 85, 110, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#8B6238';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(doorX - 30, floorY - 85, 110, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#8B6238';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - WyjdÅº ğŸšª', doorX + 25, floorY - 67);
            }
        }

        // ========== HYCEL SYSTEM ==========

        // Helper function to draw a single Hycel (zwierzak 2x wiÄ™kszy)
        function drawSingleHycel(x, y, hycel, animFrame) {
            ctx.save();

            // Scale 2x
            const scale = 2;

            // Get the friend type emoji
            const friendEmoji = hycel.friendType ? hycel.friendType.emoji : 'ğŸ¶';

            // Map emoji to draw function
            const drawFunctions = {
                'ğŸ¶': drawDog,
                'ğŸ°': drawRabbit,
                'ğŸ»': drawBear,
                'ğŸ‘': drawSheep,
                'ğŸ¬': drawDolphin,
                'ğŸ¦Š': drawFox,
                'ğŸ¼': drawPanda,
                'ğŸ¦„': drawUnicorn,
                'ğŸ¸': drawFrog,
                'ğŸ¦‹': drawButterfly
            };

            const drawFunction = drawFunctions[friendEmoji] || drawDog;

            // Draw the animal 2x bigger
            drawFunction(x, y, scale);

            // Draw net in hycel's paw/hand
            if (!hycel.defeated) {
                // Position at the right paw of the animal (body center + paw offset, scaled)
                const netX = x + 12 * scale;
                const netY = y + 45 * scale;
                const netR = 10 * scale;
                const swing = Math.sin((animFrame || 0) * 0.05) * 0.15;

                ctx.save();
                ctx.translate(netX, netY);
                ctx.rotate(swing - 0.3); // Tilted slightly as if held

                // Handle/stick (going up from paw into the net)
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2.5 * scale;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -netR * 2.2);
                ctx.stroke();

                // Net ring at the top of the stick
                const ringY = -netR * 2.2;
                ctx.strokeStyle = '#8B6914';
                ctx.lineWidth = 2 * scale;
                ctx.beginPath();
                ctx.arc(0, ringY, netR, 0, Math.PI * 2);
                ctx.stroke();

                // Radial ropes from center
                ctx.lineWidth = 0.8 * scale;
                ctx.strokeStyle = '#A0822A';
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(0, ringY);
                    ctx.lineTo(Math.cos(angle) * netR, ringY + Math.sin(angle) * netR);
                    ctx.stroke();
                }

                // Concentric mesh rings
                ctx.lineWidth = 0.6 * scale;
                for (let r = 1; r <= 2; r++) {
                    ctx.beginPath();
                    ctx.arc(0, ringY, netR * r * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Semi-transparent net fill
                ctx.fillStyle = 'rgba(139, 105, 20, 0.1)';
                ctx.beginPath();
                ctx.arc(0, ringY, netR, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            ctx.restore();
        }

        function drawHycels() {
            hycels.forEach(hycel => {
                const screenX = hycel.x - worldOffset;
                const screenY = hycel.y;

                if (screenX < -100 || screenX > canvas.width + 100) return;

                // Animacja przewracania siÄ™ po pokonaniu
                if (hycel.defeated) {
                    if (!hycel.fallAnimation) hycel.fallAnimation = 0;
                    hycel.fallAnimation++;

                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(Math.min(hycel.fallAnimation * 0.05, Math.PI / 2)); // PrzewrÃ³cenie
                    ctx.translate(-screenX, -screenY);
                    ctx.globalAlpha = Math.max(0, 1 - hycel.fallAnimation * 0.02);
                    drawSingleHycel(screenX, screenY, hycel, animationFrame);
                    ctx.restore();
                    return;
                }

                // Bouncing animation
                hycel.bounceOffset += 0.1;
                const bounce = Math.sin(hycel.bounceOffset) * 5;
                const drawY = screenY + bounce;

                // Draw the Hycel using helper function
                drawSingleHycel(screenX, drawY, hycel, animationFrame);

                // Health indicator (green hearts)
                ctx.save();
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                const hearts = 'ğŸ’š'.repeat(hycel.health);
                ctx.fillText(hearts, screenX, drawY - 80);
                ctx.restore();

                // Distance check
                const distance = Math.sqrt(
                    Math.pow(player.x - hycel.x, 2) +
                    Math.pow(player.y - hycel.y, 2)
                );

                if (distance < 150) {
                    // Attack prompt
                    ctx.fillStyle = 'rgba(255, 105, 180, 0.95)';
                    ctx.strokeStyle = '#FF1493';
                    ctx.lineWidth = 3;
                    ctx.fillRect(screenX - 100, drawY + 70, 200, 40);
                    ctx.strokeRect(screenX - 100, drawY + 70, 200, 40);

                    ctx.fillStyle = '#FF1493';
                    ctx.font = 'bold 18px Comic Sans MS';
                    ctx.textAlign = 'center';
                    ctx.fillText('SPACJA - Walcz!', screenX, drawY + 95);
                }
            });
        }

        // ========== BATTLE SYSTEM ==========
        function startBattle(hycel) {
            previousState = gameState;
            gameState = 'battle';
            currentBattle = hycel;

            battleState.playerHealth = 5;
            battleState.enemyHealth = hycel.health;
            battleState.playerAttackCooldown = 0;
            battleState.enemyAttackCooldown = 60;
            battleState.message = 'Walcz z Hycelem!';
            battleState.victory = false;
            battleState.defeat = false;
            battleState.attackAnimation = 0;
            battleState.hitAnimation = 0;
            battleState.victoryAnimationFrame = 0;
            battleState.defeatAnimationFrame = 0;

            // Play battle cry
            playAnimalSound('cat');
        }

        function updateBattle() {
            // Update cooldowns
            if (battleState.playerAttackCooldown > 0) {
                battleState.playerAttackCooldown--;
            }
            if (battleState.enemyAttackCooldown > 0) {
                battleState.enemyAttackCooldown--;
            }

            // Update animations
            if (battleState.attackAnimation > 0) {
                battleState.attackAnimation--;
            }
            if (battleState.hitAnimation > 0) {
                battleState.hitAnimation--;
            }

            // Check for player attack
            if (keys[' '] && battleState.playerAttackCooldown === 0 && !battleState.victory && !battleState.defeat) {
                playerAttack();
            }

            // Enemy auto-attack
            if (battleState.enemyAttackCooldown === 0 && !battleState.victory && !battleState.defeat) {
                enemyAttack();
                battleState.enemyAttackCooldown = 60; // 1 second
            }

            // Check victory
            if (battleState.enemyHealth <= 0 && !battleState.victory) {
                battleState.victory = true;
                battleState.message = 'ğŸ‰ ZWYCIÄ˜STWO! ğŸ‰';
                battleState.victoryAnimationFrame = 0;
            }

            // Check defeat
            if (battleState.playerHealth <= 0 && !battleState.defeat) {
                battleState.defeat = true;
                battleState.message = 'ğŸ’” Ojej! SprÃ³buj jeszcze raz! ğŸ’”';
                battleState.defeatAnimationFrame = 0;
            }

            // Victory animation counter - auto end after 150 frames (~2.5 seconds)
            if (battleState.victory) {
                battleState.victoryAnimationFrame++;
                if (battleState.victoryAnimationFrame >= 150) {
                    endBattle();
                }
            }

            // Defeat animation counter - auto retry after 90 frames (~1.5 seconds)
            if (battleState.defeat) {
                battleState.defeatAnimationFrame++;
                if (battleState.defeatAnimationFrame >= 90) {
                    endBattle();
                }
            }
        }

        function playerAttack() {
            battleState.enemyHealth--;
            battleState.playerAttackCooldown = 20; // ~0.33s
            battleState.attackAnimation = 10;

            const messages = [
                'Åšwietne uderzenie! ğŸ’ª',
                'Tak trzymaj! ğŸŒŸ',
                'Super atak! âš¡',
                'Doskonale! ğŸ¯',
                'Brawo! ğŸ¦„'
            ];
            battleState.message = messages[Math.floor(Math.random() * messages.length)];

            playAttackSound();
        }

        function enemyAttack() {
            battleState.playerHealth--;
            battleState.hitAnimation = 10;
            battleState.message = 'Hycel zaatakowaÅ‚! Odpieraj siÄ™!';

            playHitSound();
        }

        function endBattle() {
            if (battleState.victory) {
                // Mark hycel as defeated
                currentBattle.defeated = true;
                gameState = 'world';

                dialogBubbles.push({
                    x: player.x,
                    y: player.y,
                    text: 'PokonaÅ‚em Hycela! ğŸ‰',
                    fromLeft: true,
                    startTime: Date.now(),
                    duration: 2500
                });
            } else if (battleState.defeat) {
                // Reset for retry
                battleState.playerHealth = 5;
                battleState.enemyHealth = currentBattle.health;
                battleState.playerAttackCooldown = 0;
                battleState.enemyAttackCooldown = 60;
                battleState.message = 'SprÃ³buj ponownie!';
                battleState.victory = false;
                battleState.defeat = false;
            }
        }

        function drawBattle() {
            updateBattle();

            // Rainbow gradient background
            const rainbowGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            rainbowGradient.addColorStop(0, '#FF0000');
            rainbowGradient.addColorStop(0.17, '#FF7F00');
            rainbowGradient.addColorStop(0.33, '#FFFF00');
            rainbowGradient.addColorStop(0.5, '#00FF00');
            rainbowGradient.addColorStop(0.67, '#0000FF');
            rainbowGradient.addColorStop(0.83, '#4B0082');
            rainbowGradient.addColorStop(1, '#9400D3');
            ctx.fillStyle = rainbowGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Sparkling stars effect
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 3;
                const alpha = Math.sin(animationFrame * 0.05 + i) * 0.5 + 0.5;

                ctx.save();
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Draw KicioroÅ¼ek (left side) - using real graphics!
            const playerBaseX = canvas.width / 3 - 30;
            const playerBaseY = canvas.height / 2;
            const playerX = playerBaseX + (battleState.attackAnimation > 0 ? 30 : 0);
            const playerY = playerBaseY;

            ctx.save();
            if (battleState.hitAnimation > 0 && battleState.hitAnimation % 4 < 2) {
                ctx.globalAlpha = 0.5; // Flash when hit
            }

            // Make player face right for battle
            player.facingRight = true;

            // Draw player
            drawPlayer(playerX, playerY);

            // Attack animation - realistic rainbow beam from horn!
            if (battleState.attackAnimation > 0) {
                const attackProgress = battleState.attackAnimation / 10;

                // Rainbow beam from horn to enemy
                const hornX = playerX + 35;
                const hornY = playerY + 5;
                const targetX = (canvas.width * 2) / 3;
                const targetY = canvas.height / 2;
                const beamDist = Math.sqrt((targetX - hornX) ** 2 + (targetY - hornY) ** 2);

                ctx.save();
                ctx.globalAlpha = attackProgress;

                // Draw each rainbow color as a separate wavy band
                const rainbowColors = [
                    '#FF0000', '#FF4500', '#FF7F00', '#FFD700',
                    '#FFFF00', '#7FFF00', '#00FF00', '#00CED1',
                    '#0000FF', '#4B0082', '#9400D3'
                ];
                const bandWidth = 4;
                const totalWidth = rainbowColors.length * bandWidth;
                const waveAmplitude = 8 + (1 - attackProgress) * 12; // Wave gets stronger as beam extends
                const waveFreq = 0.04;
                const timeOffset = animationFrame * 0.3;

                // Calculate perpendicular direction for band offsets
                const dx = targetX - hornX;
                const dy = targetY - hornY;
                const len = Math.sqrt(dx * dx + dy * dy);
                const perpX = -dy / len;
                const perpY = dx / len;

                // Outer glow
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 30;

                rainbowColors.forEach((color, bandIdx) => {
                    const bandOffset = (bandIdx - rainbowColors.length / 2) * bandWidth;

                    ctx.strokeStyle = color;
                    ctx.lineWidth = bandWidth;
                    ctx.lineCap = 'round';
                    ctx.beginPath();

                    const steps = 40;
                    for (let i = 0; i <= steps; i++) {
                        const t = i / steps;
                        // Base position along the beam
                        const baseX = hornX + dx * t;
                        const baseY = hornY + dy * t;

                        // Sinusoidal wave perpendicular to beam direction
                        const wave = Math.sin(t * beamDist * waveFreq + timeOffset + bandIdx * 0.3) * waveAmplitude * t;

                        // Beam starts narrow at horn, expands toward target
                        const widthScale = 0.3 + t * 0.7;

                        const px = baseX + perpX * (bandOffset * widthScale + wave);
                        const py = baseY + perpY * (bandOffset * widthScale + wave);

                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                });

                ctx.shadowBlur = 0;

                // Bright core beam (white center)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let i = 0; i <= 40; i++) {
                    const t = i / 40;
                    const baseX = hornX + dx * t;
                    const baseY = hornY + dy * t;
                    const wave = Math.sin(t * beamDist * waveFreq + timeOffset) * waveAmplitude * t * 0.3;
                    const px = baseX + perpX * wave;
                    const py = baseY + perpY * wave;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();

                // Sparkles and stars along the beam
                for (let i = 0; i < 15; i++) {
                    const t = (i + Math.sin(animationFrame * 0.1 + i)) / 15;
                    const sparkX = hornX + dx * t + perpX * (Math.sin(animationFrame * 0.2 + i * 2) * 20);
                    const sparkY = hornY + dy * t + perpY * (Math.sin(animationFrame * 0.2 + i * 2) * 20);
                    const sparkSize = 2 + Math.sin(animationFrame * 0.3 + i) * 2;

                    // Star shape
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    for (let s = 0; s < 5; s++) {
                        const angle = (s / 5) * Math.PI * 2 - Math.PI / 2;
                        const outerR = sparkSize;
                        const innerR = sparkSize * 0.4;
                        ctx.lineTo(sparkX + Math.cos(angle) * outerR, sparkY + Math.sin(angle) * outerR);
                        const innerAngle = angle + Math.PI / 5;
                        ctx.lineTo(sparkX + Math.cos(innerAngle) * innerR, sparkY + Math.sin(innerAngle) * innerR);
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                // Impact burst at target
                if (attackProgress > 0.5) {
                    const burstSize = (1 - attackProgress) * 40;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2 + animationFrame * 0.1;
                        ctx.fillStyle = rainbowColors[i % rainbowColors.length];
                        ctx.globalAlpha = attackProgress * 0.7;
                        ctx.beginPath();
                        ctx.arc(
                            targetX + Math.cos(angle) * burstSize,
                            targetY + Math.sin(angle) * burstSize,
                            4, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }

                ctx.restore();
            }
            ctx.restore();

            // Draw Hycel (right side) - using real graphics!
            const enemyX = (canvas.width * 2) / 3;
            const enemyY = canvas.height / 2;

            // Scale up the Hycel for battle
            ctx.save();

            // Hycel falling animation on victory
            if (battleState.victory) {
                const fallProgress = Math.min(battleState.victoryAnimationFrame / 100, 1);

                ctx.translate(enemyX, enemyY);
                // Powolny obrÃ³t (przewracanie siÄ™)
                ctx.rotate(fallProgress * Math.PI / 2);
                // Opadanie w dÃ³Å‚
                ctx.translate(0, fallProgress * 100);
                // Zanikanie
                ctx.globalAlpha = Math.max(0, 1 - fallProgress * 0.8);
                ctx.translate(-enemyX, -enemyY);

                drawSingleHycel(enemyX, enemyY, currentBattle, animationFrame);
            } else {
                // Enemy attack animation - throwing realistic net!
                if (battleState.enemyAttackCooldown > 50 && battleState.enemyAttackCooldown <= 60 && !battleState.defeat) {
                    const throwProgress = (60 - battleState.enemyAttackCooldown) / 10;
                    const netX = enemyX - throwProgress * 200;
                    const netY = enemyY;
                    const netRadius = 45;
                    const rotation = throwProgress * Math.PI * 2; // Net spins as it flies

                    ctx.save();
                    ctx.translate(netX, netY);
                    ctx.rotate(rotation);

                    // Outer ring of the net (thick rope)
                    ctx.strokeStyle = '#8B6914';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, netRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Inner ring
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#A0822A';
                    ctx.beginPath();
                    ctx.arc(0, 0, netRadius * 0.6, 0, Math.PI * 2);
                    ctx.stroke();

                    // Radial ropes from center to outer ring (like a spider web)
                    ctx.strokeStyle = '#8B6914';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * netRadius, Math.sin(angle) * netRadius);
                        ctx.stroke();
                    }

                    // Concentric rope rings (mesh pattern)
                    ctx.lineWidth = 1.5;
                    ctx.strokeStyle = '#A0822A';
                    for (let r = 0; r < 3; r++) {
                        const ringRadius = netRadius * (0.25 + r * 0.2);
                        ctx.beginPath();
                        ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // Weighted knots on outer ring
                    ctx.fillStyle = '#654321';
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.arc(Math.cos(angle) * netRadius, Math.sin(angle) * netRadius, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Semi-transparent fill for net area
                    ctx.fillStyle = 'rgba(139, 105, 20, 0.15)';
                    ctx.beginPath();
                    ctx.arc(0, 0, netRadius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }

                drawSingleHycel(enemyX, enemyY, currentBattle, animationFrame);
            }
            ctx.restore();

            // Health bars at top
            drawHealthBar(50, 50, battleState.playerHealth, 5, '#00FF00', 'KicioroÅ¼ek');
            drawHealthBar(canvas.width - 350, 50, battleState.enemyHealth, currentBattle.health, '#FF0000', 'Hycel');

            // Message box at bottom
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillRect(canvas.width / 2 - 250, canvas.height - 120, 500, 80);
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 5;
            ctx.strokeRect(canvas.width / 2 - 250, canvas.height - 120, 500, 80);

            ctx.fillStyle = '#FF1493';
            ctx.font = 'bold 20px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText(battleState.message, canvas.width / 2, canvas.height - 70);

            // Controls hint
            if (!battleState.victory && !battleState.defeat) {
                ctx.font = 'bold 18px Comic Sans MS';
                ctx.fillText('SPACJA - Atak! ğŸ—¡ï¸', canvas.width / 2, canvas.height - 40);
            }

            // Victory overlay with friend approaching animation
            if (battleState.victory) {
                const victoryProgress = battleState.victoryAnimationFrame / 150;

                // Fade in green overlay
                ctx.fillStyle = `rgba(0, 255, 0, ${Math.min(0.3, victoryProgress * 0.5)})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Victory text
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 60px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('ğŸ‰ ZWYCIÄ˜STWO! ğŸ‰', canvas.width / 2, canvas.height / 2 - 50);

                ctx.font = 'bold 30px Comic Sans MS';
                ctx.fillText('UratowaÅ‚eÅ› przyjaciela!', canvas.width / 2, canvas.height / 2 + 20);

                // Friend approaching from right to player
                if (victoryProgress > 0.3) {
                    const friendProgress = Math.min((victoryProgress - 0.3) / 0.7, 1);
                    const friendX = enemyX - (enemyX - playerX - 80) * friendProgress;
                    const friendY = canvas.height / 2;

                    // Draw the rescued friend using real draw function
                    const friendType = currentBattle.friendType;
                    const drawFunctions = {
                        'ğŸ¶': drawDog, 'ğŸ°': drawRabbit, 'ğŸ»': drawBear, 'ğŸ‘': drawSheep,
                        'ğŸ¬': drawDolphin, 'ğŸ¦Š': drawFox, 'ğŸ¼': drawPanda, 'ğŸ¦„': drawUnicorn,
                        'ğŸ¸': drawFrog, 'ğŸ¦‹': drawButterfly
                    };
                    const drawFn = drawFunctions[friendType.emoji] || drawDog;
                    ctx.save();
                    drawFn(friendX, friendY, 1);
                    ctx.restore();
                }
            }

            // Defeat overlay
            if (battleState.defeat) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 60px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('ğŸ’” Ojej! ğŸ’”', canvas.width / 2, canvas.height / 2 - 50);

                ctx.font = 'bold 30px Comic Sans MS';
                ctx.fillText('SprÃ³buj jeszcze raz!', canvas.width / 2, canvas.height / 2 + 20);
            }
        }

        function drawHealthBar(x, y, current, max, color, label) {
            // Label
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 20px Comic Sans MS';
            ctx.textAlign = 'left';
            ctx.fillText(label, x, y - 10);

            // Bar background
            ctx.fillStyle = '#333';
            ctx.fillRect(x, y, 300, 30);

            // Bar foreground
            ctx.fillStyle = color;
            const width = (current / max) * 300;
            ctx.fillRect(x, y, width, 30);

            // Bar outline
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 3;
            ctx.strokeRect(x, y, 300, 30);

            // Health text
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 18px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText(`${current}/${max}`, x + 150, y + 22);
        }

        // Sound functions
        function playAttackSound() {
            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.connect(gain);
            gain.connect(audioContext.destination);

            osc.frequency.setValueAtTime(800, now);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

            osc.start(now);
            osc.stop(now + 0.1);
        }

        function playHitSound() {
            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.connect(gain);
            gain.connect(audioContext.destination);

            osc.frequency.setValueAtTime(200, now);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

            osc.start(now);
            osc.stop(now + 0.2);
        }

        // PÄ™tla
        function gameLoop() {
            if (!gameRunning) return;

            animationFrame++;
            if (houseCooldown > 0) houseCooldown--;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // State-based rendering
            if (gameState === 'interior') {
                drawInterior();
            } else if (gameState === 'battle') {
                drawBattle();
            } else {
                // Normal world rendering
                drawBackground();
                drawTrees();
                drawFlowers();
                drawGround();
                drawDecorations();
                drawPassingAnimals();
                drawCandies();
                drawItemsToCollect();
                drawHouses(); // Draw houses
                drawHycels(); // Draw hycels
                drawFriendsToFind();
                drawFollowingFriends();
                drawPlayer(player.x - worldOffset, player.y);
                updateAndDrawDialogBubbles();

                updatePlayer();
                updatePassingAnimals();
                checkCollectibles();
            }

            requestAnimationFrame(gameLoop);
        }

        // Kontrolki
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ' || e.key === 'ArrowUp') e.preventDefault();

            // SPACJA - Start game from start screen
            if (e.key === ' ' && !gameRunning && document.getElementById('start-screen').classList.contains('active')) {
                startGame();
                return;
            }

            // SPACJA - Interior interactions
            if (e.key === ' ' && gameState === 'interior') {
                const px = interiorPlayer.x;
                const floorY = canvas.height - 180;

                // If sleeping - wake up
                if (interiorPlayer.action === 'sleeping') {
                    interiorPlayer.action = 'none';
                    return;
                }

                // If doing another action, ignore
                if (interiorPlayer.action !== 'none') return;

                // Bed zone (left side)
                const bedX = 30;
                const bedW = 120;
                if (px > bedX - 20 && px < bedX + bedW + 20) {
                    interiorPlayer.action = 'sleeping';
                    interiorPlayer.actionTimer = -1; // Infinite until SPACE pressed again
                    return;
                }

                // Toilet zone
                const toiletX = 450;
                if (Math.abs(px - toiletX) < 40) {
                    interiorPlayer.action = 'toilet';
                    interiorPlayer.actionTimer = 120; // ~2 seconds
                    return;
                }

                // Sink zone
                const sinkX = toiletX + 80;
                if (Math.abs(px - sinkX) < 40) {
                    interiorPlayer.action = 'washing';
                    interiorPlayer.actionTimer = 90; // ~1.5 seconds
                    return;
                }

                // Bathtub zone
                const bathtubX = toiletX + 200; // sinkX + 120
                if (Math.abs(px - bathtubX) < 60) {
                    if (!interiorPlayer.bathtubWaterLevel) interiorPlayer.bathtubWaterLevel = 0;

                    if (interiorPlayer.bathtubWaterLevel < 1) {
                        // Fill water with animation
                        interiorPlayer.action = 'filling_water';
                        interiorPlayer.actionTimer = 30; // Half second
                        return;
                    } else {
                        // Take bath
                        interiorPlayer.action = 'bathing';
                        interiorPlayer.actionTimer = 180; // ~3 seconds
                        return;
                    }
                }

                // Food bowls zone
                const bowlX = 350;
                if (Math.abs(px - bowlX) < 60) {
                    interiorPlayer.action = 'eating';
                    interiorPlayer.actionTimer = 120; // ~2 seconds
                    return;
                }

                // Ball zone
                const ballX = canvas.width / 2 + 100;
                if (Math.abs(px - ballX) < 50) {
                    interiorPlayer.action = 'playing';
                    interiorPlayer.actionTimer = 90; // ~1.5 seconds
                    return;
                }

                // Exit door zone
                const doorX = canvas.width - 350;
                if (px > doorX - 50) {
                    exitHouse();
                    return;
                }
            }

            // Uruchom muzykÄ™ w tle przy pierwszym klawiszu
            startBackgroundMusic();
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Uruchomienie muzyki takÅ¼e przy klikniÄ™ciu
        document.addEventListener('click', () => {
            startBackgroundMusic();
        });
    </script>
</body>
</html>