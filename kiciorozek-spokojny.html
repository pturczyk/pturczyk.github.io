<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ü¶Ñüò∫ Kicioro≈ºek - Spokojna Przygoda üåà</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', cursive;
            background: #000;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #87CEEB;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 20px;
            border: 4px solid #FF69B4;
            font-size: 1.2em;
            color: #FF1493;
            box-shadow: 0 5px 20px rgba(255, 105, 180, 0.5);
            z-index: 10;
        }

        .friends-parade {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 20px;
            border: 4px solid #FF69B4;
            font-size: 1.1em;
            color: #FF1493;
            box-shadow: 0 5px 20px rgba(255, 105, 180, 0.5);
            z-index: 10;
            max-width: 250px;
        }

        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            padding: 40px;
            border-radius: 30px;
            border: 8px solid #FF69B4;
            text-align: center;
            display: none;
            z-index: 100;
            box-shadow: 0 10px 40px rgba(255, 105, 180, 0.5);
        }

        .message.active {
            display: block;
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        button {
            background: linear-gradient(135deg, #FF69B4, #FF1493);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.3em;
            font-family: 'Comic Sans MS', cursive;
            border-radius: 50px;
            cursor: pointer;
            margin: 10px;
            box-shadow: 0 5px 15px rgba(255, 20, 147, 0.4);
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(255, 20, 147, 0.6);
        }

        .hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 30px;
            border-radius: 15px;
            border: 3px solid #FF69B4;
            color: #FF1493;
            font-size: 1.1em;
            z-index: 10;
            display: none;
        }

        .wardrobe {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 20px;
            border: 4px solid #FF69B4;
            z-index: 10;
            max-width: 250px;
        }

        .wardrobe h3 {
            color: #FF1493;
            margin: 0 0 10px 0;
            font-size: 1.1em;
        }

        .wardrobe-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }

        .wardrobe-item {
            background: linear-gradient(135deg, #FFE5F1, #FFF);
            border: 2px solid #FF69B4;
            border-radius: 10px;
            padding: 8px;
            cursor: pointer;
            font-size: 1.8em;
            transition: all 0.2s;
            position: relative;
        }

        .wardrobe-item:hover {
            transform: scale(1.1);
            border-color: #FF1493;
            box-shadow: 0 3px 10px rgba(255, 105, 180, 0.4);
        }

        .wardrobe-item.equipped {
            background: linear-gradient(135deg, #FF69B4, #FFB6D9);
            border-color: #FF1493;
            box-shadow: 0 0 15px rgba(255, 105, 180, 0.6);
        }

        .wardrobe-item.equipped::after {
            content: '‚úì';
            position: absolute;
            top: -5px;
            right: -5px;
            background: #00FF00;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wardrobe-section {
            margin-bottom: 8px;
        }

        .wardrobe-section-title {
            color: #8B008B;
            font-size: 0.9em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        /* ===== TOUCH CONTROLS ===== */
        .touch-controls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 200;
            pointer-events: none;
            padding: 10px;
        }

        .touch-dpad {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 140px;
            height: 140px;
            pointer-events: auto;
        }

        .touch-btn {
            position: absolute;
            background: rgba(255, 105, 180, 0.45);
            border: 3px solid rgba(255, 105, 180, 0.7);
            border-radius: 50%;
            color: white;
            font-size: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            transition: background 0.1s;
        }

        .touch-btn:active, .touch-btn.pressed {
            background: rgba(255, 20, 147, 0.7);
            border-color: rgba(255, 20, 147, 0.9);
        }

        .touch-btn-left {
            width: 52px;
            height: 52px;
            left: 0;
            top: 44px;
        }

        .touch-btn-right {
            width: 52px;
            height: 52px;
            right: 0;
            top: 44px;
        }

        .touch-btn-up {
            width: 52px;
            height: 52px;
            left: 44px;
            top: 0;
        }

        .touch-action-area {
            position: absolute;
            bottom: 20px;
            right: 20px;
            pointer-events: auto;
        }

        .touch-btn-action {
            width: 72px;
            height: 72px;
            position: relative;
            background: rgba(255, 215, 0, 0.5);
            border: 3px solid rgba(255, 215, 0, 0.8);
            border-radius: 50%;
            color: white;
            font-size: 16px;
            font-weight: bold;
            font-family: 'Comic Sans MS', cursive;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .touch-btn-action:active, .touch-btn-action.pressed {
            background: rgba(255, 215, 0, 0.8);
        }

        .touch-btn-jump {
            width: 64px;
            height: 64px;
            position: relative;
            margin-bottom: 12px;
            background: rgba(100, 200, 255, 0.5);
            border: 3px solid rgba(100, 200, 255, 0.8);
            border-radius: 50%;
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .touch-btn-jump:active, .touch-btn-jump.pressed {
            background: rgba(100, 200, 255, 0.8);
        }

        /* ===== MOBILE RESPONSIVE ===== */
        @media (max-width: 768px) {
            .hud {
                top: 5px;
                left: 5px;
                padding: 8px 12px;
                font-size: 0.75em;
                border-radius: 12px;
                border-width: 2px;
            }

            .friends-parade {
                top: 5px;
                right: 5px;
                padding: 6px 10px;
                font-size: 0.7em;
                border-radius: 12px;
                border-width: 2px;
                max-width: 140px;
            }

            .wardrobe {
                bottom: auto;
                top: 60px;
                right: 5px;
                padding: 6px;
                border-radius: 12px;
                border-width: 2px;
                max-width: 160px;
                font-size: 0.7em;
                max-height: 40vh;
                overflow-y: auto;
            }

            .wardrobe h3 {
                font-size: 0.85em;
                margin: 0 0 4px 0;
            }

            .wardrobe-item {
                font-size: 1.2em;
                padding: 4px;
            }

            .wardrobe-items {
                gap: 4px;
            }

            .hint {
                display: none !important;
            }

            .message {
                padding: 20px;
                border-width: 4px;
                border-radius: 20px;
                width: 90vw;
                max-width: 400px;
            }

            .message h2 {
                font-size: 1.3em !important;
            }

            .message p {
                font-size: 0.9em !important;
            }

            .message button {
                padding: 10px 25px;
                font-size: 1em;
            }
        }

        @media (max-width: 480px) {
            .hud {
                padding: 5px 8px;
                font-size: 0.65em;
            }

            .friends-parade {
                max-width: 110px;
                font-size: 0.6em;
            }

            .wardrobe {
                max-width: 120px;
                font-size: 0.6em;
            }
        }

        /* Show touch controls on touch devices */
        @media (hover: none) and (pointer: coarse) {
            .touch-controls {
                display: block !important;
            }

            .hint {
                display: none !important;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div class="hud">
        üç¨ Cukierki: <span id="score">0</span><br>
        üìç Pozycja: <span id="position">0</span>m<br>
        üéµ <span id="mood">Miau! üò∫</span>
    </div>

    <div class="friends-parade">
        <strong>Parada przyjaci√≥≈Ç:</strong><br>
        <div id="friends-list" style="margin-top: 10px; font-size: 1.5em;">
            (czeka na przyjaci√≥≈Ç)
        </div>
    </div>

    <div class="wardrobe">
        <h3>üëó Garderoba ü¶Ñ</h3>

        <div class="wardrobe-section">
            <div class="wardrobe-section-title">R√≥g:</div>
            <div class="wardrobe-items" id="horn-items"></div>
        </div>

        <div class="wardrobe-section">
            <div class="wardrobe-section-title">Ubranka:</div>
            <div class="wardrobe-items" id="outfit-items"></div>
        </div>

        <div class="wardrobe-section">
            <div class="wardrobe-section-title">Akcesoria:</div>
            <div class="wardrobe-items" id="accessory-items"></div>
        </div>

        <div class="wardrobe-section">
            <div class="wardrobe-section-title">Kolor futerka:</div>
            <div class="wardrobe-items" id="color-items"></div>
        </div>
    </div>

    <div class="hint">
        ‚¨ÖÔ∏è‚û°Ô∏è A/D lub strza≈Çki - Spacer | ‚¨ÜÔ∏è SPACJA - Skocz / Walcz / Wejd≈∫ do domu üè† | Odkrywaj spokojny ≈õwiat! üå∏
    </div>

    <!-- Touch controls for mobile/tablet -->
    <div class="touch-controls" id="touch-controls">
        <div class="touch-dpad">
            <div class="touch-btn touch-btn-left" data-key="ArrowLeft">‚óÄ</div>
            <div class="touch-btn touch-btn-right" data-key="ArrowRight">‚ñ∂</div>
            <div class="touch-btn touch-btn-up" data-key="ArrowUp">‚ñ≤</div>
        </div>
        <div class="touch-action-area">
            <div class="touch-btn-jump" data-key="ArrowUp">‚¨Ü</div>
            <div class="touch-btn-action" data-key=" ">SPACJA</div>
        </div>
    </div>

    <div class="message active" id="start-screen">
        <h2 style="color: #FF1493; font-size: 2em; margin-bottom: 20px;">
            ü¶Ñüò∫ Witaj w Candy Krainie! üåà‚ú®
        </h2>
        <p style="color: #8B008B; font-size: 1.2em; margin: 20px 0; line-height: 1.6;">
            Jestem Kicioro≈ºek! üê±ü¶Ñ<br><br>
            Wyruszam w spokojnƒÖ podr√≥≈º po piƒôknej krainie! üíñ<br>
            Zbiorƒô cukierki i znajdƒô przyjaci√≥≈Ç! üç≠<br><br>
            <strong>üå∏ To spokojna przygoda bez niebezpiecze≈Ñstw!</strong><br>
            Spaceruj, eksploruj i ciesz siƒô podr√≥≈ºƒÖ! ‚ú®<br>
            Mo≈ºesz skakaƒá je≈õli chcesz, ale nie musisz! üòä<br><br>
            Ka≈ºdy znaleziony przyjaciel bƒôdzie za TobƒÖ podƒÖ≈ºa≈Ç! üíï
        </p>
        <button onclick="startGame()" ontouchend="startGame()">Dotknij lub naci≈õnij SPACJƒò - Zacznij podr√≥≈º! üöÄ‚ú®</button>
    </div>

    <div class="message" id="victory-screen">
        <h2 style="color: #FF1493; font-size: 2.5em;">Wspania≈Ça przygoda! üéâüåà</h2>
        <p style="color: #8B008B; font-size: 1.3em; margin: 20px 0; line-height: 1.6;">
            Znalaz≈Çe≈õ wszystkich 10 przyjaci√≥≈Ç! üéä<br>
            Twoja parada jest kompletna! üíï‚ú®<br><br>
            Zebrane cukierki: <strong id="final-score">0</strong> üç¨<br>
            Przebyta droga: <strong id="final-distance">0</strong>m üó∫Ô∏è<br><br>
            <span style="font-size: 2em;">üê±ü¶Ñüê∂üê∞üêªüêëüê¨ü¶äüêºü¶Ñüê∏ü¶ã</span><br><br>
            Mo≈ºesz dalej eksplorowaƒá lub zagraƒá ponownie! üòä
        </p>
        <button onclick="closeFriendMessage()">Dalej zwiedzaj! üåç</button>
        <button onclick="location.reload()">Nowa przygoda! üéÆ</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Stan gry
        let gameRunning = false;
        let score = 0;
        let keys = {};
        let worldOffset = 0;
        let animationFrame = 0;

        // Pogoda i pora dnia
        let gameTimeStart = 0; // set on game start
        let raindrops = []; // active raindrops

        // Kicioro≈ºek
        const player = {
            x: 300,
            y: canvas.height - 150,
            width: 60,
            height: 80,
            speed: 8,
            velY: 0,
            jumping: false,
            gravity: 0.6,
            jumpPower: -12,
            facingRight: true,
            walkCycle: 0,
            tailSwing: 0,
            // Garderoba
            equippedHorn: 'gold',
            equippedOutfit: null,
            equippedAccessory: null,
            equippedColor: 'pink' // Domy≈õlny r√≥≈ºowy
        };

        // Dostƒôpne przedmioty
        let collectedItems = {
            horns: ['gold'], // Z≈Çoty domy≈õlnie
            outfits: [],
            accessories: [],
            colors: ['pink'] // R√≥≈ºowy domy≈õlnie
        };

        // Przedmioty do zbierania w ≈õwiecie
        let itemsToCollect = [];

        // Definicje przedmiot√≥w
        const itemDefinitions = {
            horns: [
                { id: 'gold', emoji: 'üåü', color: '#FFD700', name: 'Z≈Çoty r√≥g' },
                { id: 'rainbow', emoji: 'üåà', color: null, name: 'Tƒôczowy r√≥g' },
                { id: 'pink', emoji: 'üíñ', color: '#FF69B4', name: 'R√≥≈ºowy r√≥g' },
                { id: 'blue', emoji: 'üíé', color: '#87CEEB', name: 'Niebieski r√≥g' },
                { id: 'purple', emoji: 'üíú', color: '#9370DB', name: 'Fioletowy r√≥g' },
                { id: 'green', emoji: 'üíö', color: '#90EE90', name: 'Zielony r√≥g' }
            ],
            outfits: [
                { id: 'cape', emoji: 'ü¶∏', name: 'Peleryna' },
                { id: 'dress', emoji: 'üëó', name: 'Sukienka' },
                { id: 'scarf', emoji: 'üß£', name: 'Szalik' },
                { id: 'shirt', emoji: 'üëï', name: 'Koszulka' },
                { id: 'sweater', emoji: 'üß•', name: 'Sweterek' }
            ],
            accessories: [
                { id: 'crown', emoji: 'üëë', name: 'Korona' },
                { id: 'bow', emoji: 'üéÄ', name: 'Kokarda' },
                { id: 'glasses', emoji: 'üëì', name: 'Okulary' },
                { id: 'hat', emoji: 'üé©', name: 'Kapelusz' },
                { id: 'flower', emoji: 'üå∏', name: 'Kwiatek' }
            ],
            colors: [
                { id: 'pink', emoji: 'ü©∑', name: 'R√≥≈ºowy', bodyColor: '#FFC0CB', shadeColor: '#FFB6D9' },
                { id: 'white', emoji: 'ü§ç', name: 'Bia≈Çy', bodyColor: '#FFF', shadeColor: '#F5F5F5' },
                { id: 'orange', emoji: 'üß°', name: 'Pomara≈Ñczowy', bodyColor: '#FFA500', shadeColor: '#FF8C00' },
                { id: 'yellow', emoji: 'üíõ', name: '≈ª√≥≈Çty', bodyColor: '#FFD700', shadeColor: '#FFA500' },
                { id: 'green', emoji: 'üíö', name: 'Zielony', bodyColor: '#90EE90', shadeColor: '#7FBF7F' },
                { id: 'blue', emoji: 'üíô', name: 'Niebieski', bodyColor: '#87CEEB', shadeColor: '#6CA6CD' },
                { id: 'purple', emoji: 'üíú', name: 'Fioletowy', bodyColor: '#DDA0DD', shadeColor: '#BA7FBA' },
                { id: 'brown', emoji: 'ü§é', name: 'BrƒÖzowy', bodyColor: '#CD853F', shadeColor: '#8B4513' },
                { id: 'gray', emoji: 'ü©∂', name: 'Szary', bodyColor: '#C0C0C0', shadeColor: '#A9A9A9' },
                { id: 'black', emoji: 'üñ§', name: 'Czarny', bodyColor: '#696969', shadeColor: '#000' }
            ]
        };

        // Przyjaciele
        let followingFriends = [];
        const friendTypes = [
            { emoji: 'üê∂', name: 'Tƒôczowy Piesek', sound: 'HAU HAU! Uwielbiam spacery!', color: '#FFD700' },
            { emoji: 'üê∞', name: 'R√≥≈ºowy Kr√≥liczek', sound: 'Hopsasa! Tak siƒô cieszƒô!', color: '#FF69B4' },
            { emoji: 'üêª', name: 'Gwiazdkowy Misiek', sound: 'Mi≈õkowe u≈õciski dla wszystkich!', color: '#DDA0DD' },
            { emoji: 'üêë', name: 'Chmurka Baranek', sound: 'Beeee! P≈Çynƒô jak chmurka!', color: '#E0C3FC' },
            { emoji: 'üê¨', name: 'Magiczny Delfinek', sound: 'P≈Çum p≈Çum! Weso≈Ço!', color: '#87CEEB' },
            { emoji: 'ü¶ä', name: 'Ognisty Lisek', sound: 'Yip yip! Przygoda!', color: '#FF8C00' },
            { emoji: 'üêº', name: 'Pandu≈õ', sound: 'Nom nom bambus√≥w!', color: '#98FB98' },
            { emoji: 'ü¶Ñ', name: 'Siostrzyczka Jednoro≈ºec', sound: 'Ihaha! Jeste≈õmy rodzinƒÖ!', color: '#E0B0FF' },
            { emoji: 'üê∏', name: '≈ªabka Skoczek', sound: 'Kwa kwa! Super zabawa!', color: '#90EE90' },
            { emoji: 'ü¶ã', name: 'Motyl B≈Çyszczek', sound: 'Fru fru! Piƒôkny dzie≈Ñ!', color: '#FFB6D9' }
        ];

        let playerHistory = [];
        const historyLength = 40;

        // ≈öwiat
        let ground = [];
        let candies = [];
        let friendsToFind = [];
        let decorations = [];
        let flowers = [];
        let trees = [];
        let passingAnimals = []; // Zwierzƒôta kt√≥re mijajƒÖ
        let dialogBubbles = []; // Chmurki dialogowe
        const chunkSize = 1000;
        let generatedChunks = new Set();
        let furthestPosition = 0;

        // State Management System
        let gameState = 'world'; // 'world' | 'interior' | 'battle'
        let previousState = 'world';

        // House System
        let houses = []; // Dynamically generated houses

        // Interior State
        let interiorFriends = [];
        let interiorAnimationFrame = 0;
        let interiorOffset = 0; // Camera offset for scrolling interior
        let interiorPlayer = {
            x: 200, // World position
            y: 0, // set on enter based on floorY
            action: 'none', // 'none' | 'sleeping' | 'toilet' | 'washing' | 'eating' | 'playing' | 'bathing'
            actionTimer: 0,
            actionObject: null, // Which object player is interacting with
            bathFoam: false, // Toggle foam on head while bathing
            bathtubWaterLevel: 0
        };
        let interiorLightLevel = 1.0; // 1.0 = fully lit, 0.15 = sleeping darkness
        let tvChannel = 0; // 0 = bajka, 1 = wiadomo≈õci, 2 = pi≈Çka no≈ºna

        // Conversation system
        let activeConversation = null; // { friend, messages, currentMsg, timer, phase }

        // Photo system
        let wallPhoto = null; // Image data URL of captured photo
        let photoFlashTimer = 0; // Flash effect when taking photo

        // Cat needs system - values 0-100, need shows when >= 70
        // Needs grow every 50 steps walked
        let catNeeds = {
            hunger: 0,
            sleep: 0,
            toilet: 0,
            hygiene: 0
        };
        let catStepCounter = 0; // Total steps walked
        let interiorObjects = []; // Procedurally placed furniture

        // Slide System
        let slideState = {
            active: false,       // Is player on the slide?
            climbStep: 0,        // 0-3 (3 = at top, ready to slide)
            sliding: false,      // Currently sliding down?
            slideProgress: 0,    // 0-1 slide down progress
            slideHouseX: 0       // Which house's slide
        };

        // Hycel System
        let hycels = [];

        // Battle System
        let currentBattle = null;
        let battleState = {
            playerHealth: 5,
            enemyHealth: 3,
            playerAttackCooldown: 0,
            enemyAttackCooldown: 60,
            message: '',
            victory: false,
            defeat: false,
            attackAnimation: 0,
            hitAnimation: 0,
            victoryAnimationFrame: 0,
            defeatAnimationFrame: 0
        };

        // System d≈∫wiƒôk√≥w - Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Funkcja pomocnicza do tworzenia envelope
        function createEnvelope(gainNode, attackTime, decayTime, sustainLevel, releaseTime, startTime) {
            gainNode.gain.setValueAtTime(0, startTime);
            gainNode.gain.linearRampToValueAtTime(1, startTime + attackTime);
            gainNode.gain.linearRampToValueAtTime(sustainLevel, startTime + attackTime + decayTime);
            gainNode.gain.setValueAtTime(sustainLevel, startTime + attackTime + decayTime + releaseTime);
            gainNode.gain.linearRampToValueAtTime(0, startTime + attackTime + decayTime + releaseTime + 0.1);
        }

        // Funkcja do odtwarzania d≈∫wiƒôku zwierzƒÖtka
        function playAnimalSound(animalType) {
            const now = audioContext.currentTime;

            switch(animalType) {
                case 'cat': // Miauczenie - formant synthesis
                    {
                        const meowCount = Math.floor(Math.random() * 2) + 1;
                        for (let i = 0; i < meowCount; i++) {
                            const t = now + i * 0.55;
                            // Main vocal cord oscillator
                            const osc1 = audioContext.createOscillator();
                            const osc2 = audioContext.createOscillator();
                            const gain = audioContext.createGain();
                            const filter1 = audioContext.createBiquadFilter();
                            const filter2 = audioContext.createBiquadFilter();

                            osc1.type = 'sawtooth';
                            osc1.frequency.setValueAtTime(340, t);
                            osc1.frequency.linearRampToValueAtTime(600, t + 0.08);
                            osc1.frequency.linearRampToValueAtTime(480, t + 0.2);
                            osc1.frequency.exponentialRampToValueAtTime(350, t + 0.4);

                            osc2.type = 'sawtooth';
                            osc2.frequency.setValueAtTime(345, t);
                            osc2.frequency.linearRampToValueAtTime(605, t + 0.08);
                            osc2.frequency.linearRampToValueAtTime(485, t + 0.2);
                            osc2.frequency.exponentialRampToValueAtTime(355, t + 0.4);

                            // Vowel formants for "miaow"
                            filter1.type = 'bandpass';
                            filter1.frequency.setValueAtTime(800, t); // "m"
                            filter1.frequency.linearRampToValueAtTime(1200, t + 0.1); // "ia"
                            filter1.frequency.linearRampToValueAtTime(600, t + 0.3); // "ow"
                            filter1.Q.value = 8;

                            filter2.type = 'bandpass';
                            filter2.frequency.setValueAtTime(1800, t);
                            filter2.frequency.linearRampToValueAtTime(2400, t + 0.1);
                            filter2.frequency.linearRampToValueAtTime(1000, t + 0.3);
                            filter2.Q.value = 4;

                            const merge = audioContext.createGain();
                            merge.gain.value = 0.5;

                            osc1.connect(filter1);
                            osc2.connect(filter1);
                            osc1.connect(filter2);
                            osc2.connect(filter2);
                            filter1.connect(merge);
                            filter2.connect(merge);
                            merge.connect(gain);
                            gain.connect(audioContext.destination);

                            gain.gain.setValueAtTime(0, t);
                            gain.gain.linearRampToValueAtTime(0.3, t + 0.04);
                            gain.gain.setValueAtTime(0.3, t + 0.15);
                            gain.gain.linearRampToValueAtTime(0.2, t + 0.3);
                            gain.gain.linearRampToValueAtTime(0, t + 0.45);

                            osc1.start(t); osc1.stop(t + 0.45);
                            osc2.start(t); osc2.stop(t + 0.45);
                        }
                    }
                    break;

                case 'dog': // Szczekanie - 2 kr√≥tkie barki
                    {
                        for (let b = 0; b < 2; b++) {
                            const t = now + b * 0.2;
                            const osc = audioContext.createOscillator();
                            const gain = audioContext.createGain();
                            const filter = audioContext.createBiquadFilter();
                            const noise = audioContext.createBufferSource();
                            const noiseGain = audioContext.createGain();
                            const noiseFilter = audioContext.createBiquadFilter();

                            const bufSize = audioContext.sampleRate * 0.15;
                            const buf = audioContext.createBuffer(1, bufSize, audioContext.sampleRate);
                            const d = buf.getChannelData(0);
                            for (let i = 0; i < bufSize; i++) d[i] = Math.random() * 2 - 1;
                            noise.buffer = buf;

                            osc.type = 'sawtooth';
                            osc.frequency.setValueAtTime(280, t);
                            osc.frequency.exponentialRampToValueAtTime(200, t + 0.04);
                            osc.frequency.exponentialRampToValueAtTime(160, t + 0.1);

                            filter.type = 'lowpass';
                            filter.frequency.value = 1200;
                            filter.Q.value = 2;

                            noiseFilter.type = 'bandpass';
                            noiseFilter.frequency.value = 800;
                            noiseFilter.Q.value = 1;

                            osc.connect(filter);
                            filter.connect(gain);
                            noise.connect(noiseFilter);
                            noiseFilter.connect(noiseGain);
                            noiseGain.connect(audioContext.destination);
                            gain.connect(audioContext.destination);

                            gain.gain.setValueAtTime(0, t);
                            gain.gain.linearRampToValueAtTime(0.35, t + 0.01);
                            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.12);

                            noiseGain.gain.setValueAtTime(0.15, t);
                            noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.08);

                            osc.start(t); osc.stop(t + 0.12);
                            noise.start(t); noise.stop(t + 0.12);
                        }
                    }
                    break;

                case 'rabbit': // Cichy pisk/squeak
                    {
                        const osc = audioContext.createOscillator();
                        const osc2 = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        const filter = audioContext.createBiquadFilter();

                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(1800, now);
                        osc.frequency.exponentialRampToValueAtTime(2400, now + 0.03);
                        osc.frequency.exponentialRampToValueAtTime(1600, now + 0.12);

                        osc2.type = 'sine';
                        osc2.frequency.setValueAtTime(2600, now);
                        osc2.frequency.exponentialRampToValueAtTime(3200, now + 0.03);
                        osc2.frequency.exponentialRampToValueAtTime(2000, now + 0.12);

                        filter.type = 'highpass';
                        filter.frequency.value = 1500;

                        osc.connect(filter);
                        osc2.connect(filter);
                        filter.connect(gain);
                        gain.connect(audioContext.destination);

                        gain.gain.setValueAtTime(0, now);
                        gain.gain.linearRampToValueAtTime(0.2, now + 0.01);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                        osc.start(now); osc.stop(now + 0.15);
                        osc2.start(now); osc2.stop(now + 0.15);
                    }
                    break;

                case 'bear': // G≈Çƒôboki ryk/growl
                    {
                        const osc1 = audioContext.createOscillator();
                        const osc2 = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        const filter = audioContext.createBiquadFilter();
                        const noise = audioContext.createBufferSource();
                        const noiseGain = audioContext.createGain();
                        const noiseFilter = audioContext.createBiquadFilter();

                        const bufSize = audioContext.sampleRate * 0.6;
                        const buf = audioContext.createBuffer(1, bufSize, audioContext.sampleRate);
                        const d = buf.getChannelData(0);
                        for (let i = 0; i < bufSize; i++) d[i] = Math.random() * 2 - 1;
                        noise.buffer = buf;

                        osc1.type = 'sawtooth';
                        osc1.frequency.setValueAtTime(85, now);
                        osc1.frequency.linearRampToValueAtTime(110, now + 0.1);
                        osc1.frequency.exponentialRampToValueAtTime(65, now + 0.5);

                        osc2.type = 'sawtooth';
                        osc2.frequency.setValueAtTime(87, now);
                        osc2.frequency.linearRampToValueAtTime(112, now + 0.1);
                        osc2.frequency.exponentialRampToValueAtTime(67, now + 0.5);

                        filter.type = 'lowpass';
                        filter.frequency.setValueAtTime(400, now);
                        filter.frequency.linearRampToValueAtTime(600, now + 0.1);
                        filter.frequency.linearRampToValueAtTime(300, now + 0.5);
                        filter.Q.value = 3;

                        noiseFilter.type = 'bandpass';
                        noiseFilter.frequency.value = 300;
                        noiseFilter.Q.value = 0.5;

                        osc1.connect(filter); osc2.connect(filter);
                        filter.connect(gain);
                        noise.connect(noiseFilter);
                        noiseFilter.connect(noiseGain);
                        noiseGain.connect(audioContext.destination);
                        gain.connect(audioContext.destination);

                        gain.gain.setValueAtTime(0, now);
                        gain.gain.linearRampToValueAtTime(0.4, now + 0.05);
                        gain.gain.setValueAtTime(0.35, now + 0.15);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.55);

                        noiseGain.gain.setValueAtTime(0.12, now);
                        noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);

                        osc1.start(now); osc1.stop(now + 0.55);
                        osc2.start(now); osc2.stop(now + 0.55);
                        noise.start(now); noise.stop(now + 0.55);
                    }
                    break;

                case 'sheep': // Beczenie "baa" z wibrato
                    {
                        const osc = audioContext.createOscillator();
                        const vibrato = audioContext.createOscillator();
                        const vibratoGain = audioContext.createGain();
                        const gain = audioContext.createGain();
                        const filter = audioContext.createBiquadFilter();

                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(220, now);
                        osc.frequency.linearRampToValueAtTime(300, now + 0.05);
                        osc.frequency.setValueAtTime(300, now + 0.3);
                        osc.frequency.linearRampToValueAtTime(250, now + 0.5);

                        vibrato.type = 'sine';
                        vibrato.frequency.value = 30; // Tremolo for bleating
                        vibratoGain.gain.value = 25;
                        vibrato.connect(vibratoGain);
                        vibratoGain.connect(osc.frequency);

                        filter.type = 'bandpass';
                        filter.frequency.setValueAtTime(600, now);
                        filter.frequency.linearRampToValueAtTime(900, now + 0.05);
                        filter.frequency.linearRampToValueAtTime(700, now + 0.5);
                        filter.Q.value = 3;

                        osc.connect(filter);
                        filter.connect(gain);
                        gain.connect(audioContext.destination);

                        gain.gain.setValueAtTime(0, now);
                        gain.gain.linearRampToValueAtTime(0.3, now + 0.03);
                        gain.gain.setValueAtTime(0.28, now + 0.3);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.55);

                        osc.start(now); osc.stop(now + 0.55);
                        vibrato.start(now); vibrato.stop(now + 0.55);
                    }
                    break;

                case 'dolphin': // Klikniƒôcia i gwizdy delfina
                    {
                        // Series of clicks then a whistle
                        for (let c = 0; c < 4; c++) {
                            const ct = now + c * 0.04;
                            const click = audioContext.createOscillator();
                            const cGain = audioContext.createGain();
                            click.type = 'sine';
                            click.frequency.setValueAtTime(4000 + c * 200, ct);
                            click.connect(cGain);
                            cGain.connect(audioContext.destination);
                            cGain.gain.setValueAtTime(0.15, ct);
                            cGain.gain.exponentialRampToValueAtTime(0.01, ct + 0.02);
                            click.start(ct); click.stop(ct + 0.02);
                        }
                        // Rising whistle
                        const whistle = audioContext.createOscillator();
                        const wGain = audioContext.createGain();
                        whistle.type = 'sine';
                        whistle.frequency.setValueAtTime(2000, now + 0.18);
                        whistle.frequency.exponentialRampToValueAtTime(4500, now + 0.3);
                        whistle.frequency.exponentialRampToValueAtTime(3000, now + 0.4);
                        whistle.connect(wGain);
                        wGain.connect(audioContext.destination);
                        wGain.gain.setValueAtTime(0, now + 0.18);
                        wGain.gain.linearRampToValueAtTime(0.2, now + 0.22);
                        wGain.gain.exponentialRampToValueAtTime(0.01, now + 0.42);
                        whistle.start(now + 0.18); whistle.stop(now + 0.42);
                    }
                    break;

                case 'fox': // Yip! - kr√≥tki, ostry
                    {
                        for (let y = 0; y < 2; y++) {
                            const t = now + y * 0.25;
                            const osc = audioContext.createOscillator();
                            const gain = audioContext.createGain();
                            const filter = audioContext.createBiquadFilter();

                            osc.type = 'sawtooth';
                            osc.frequency.setValueAtTime(500, t);
                            osc.frequency.exponentialRampToValueAtTime(900, t + 0.03);
                            osc.frequency.exponentialRampToValueAtTime(600, t + 0.12);

                            filter.type = 'bandpass';
                            filter.frequency.value = 1200;
                            filter.Q.value = 4;

                            osc.connect(filter);
                            filter.connect(gain);
                            gain.connect(audioContext.destination);

                            gain.gain.setValueAtTime(0, t);
                            gain.gain.linearRampToValueAtTime(0.3, t + 0.01);
                            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);

                            osc.start(t); osc.stop(t + 0.15);
                        }
                    }
                    break;

                case 'panda': // Miƒôkki pisk/bleat pandy
                    {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        const filter = audioContext.createBiquadFilter();

                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(350, now);
                        osc.frequency.linearRampToValueAtTime(500, now + 0.05);
                        osc.frequency.linearRampToValueAtTime(400, now + 0.2);
                        osc.frequency.exponentialRampToValueAtTime(300, now + 0.35);

                        filter.type = 'bandpass';
                        filter.frequency.value = 800;
                        filter.Q.value = 2;

                        osc.connect(filter);
                        filter.connect(gain);
                        gain.connect(audioContext.destination);

                        gain.gain.setValueAtTime(0, now);
                        gain.gain.linearRampToValueAtTime(0.25, now + 0.03);
                        gain.gain.setValueAtTime(0.2, now + 0.15);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

                        osc.start(now); osc.stop(now + 0.4);
                    }
                    break;

                case 'unicorn': // Magiczne r≈ºenie + sparkle
                    {
                        // Horse-like whinny
                        const osc = audioContext.createOscillator();
                        const vibrato = audioContext.createOscillator();
                        const vibratoGain = audioContext.createGain();
                        const gain = audioContext.createGain();
                        const filter = audioContext.createBiquadFilter();

                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(300, now);
                        osc.frequency.linearRampToValueAtTime(600, now + 0.1);
                        osc.frequency.linearRampToValueAtTime(500, now + 0.3);
                        osc.frequency.exponentialRampToValueAtTime(250, now + 0.5);

                        vibrato.type = 'sine';
                        vibrato.frequency.value = 12;
                        vibratoGain.gain.value = 20;
                        vibrato.connect(vibratoGain);
                        vibratoGain.connect(osc.frequency);

                        filter.type = 'bandpass';
                        filter.frequency.value = 1000;
                        filter.Q.value = 2;

                        osc.connect(filter);
                        filter.connect(gain);
                        gain.connect(audioContext.destination);

                        gain.gain.setValueAtTime(0, now);
                        gain.gain.linearRampToValueAtTime(0.25, now + 0.05);
                        gain.gain.setValueAtTime(0.2, now + 0.25);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);

                        osc.start(now); osc.stop(now + 0.5);
                        vibrato.start(now); vibrato.stop(now + 0.5);

                        // Sparkle overlay
                        for (let i = 0; i < 4; i++) {
                            const sp = audioContext.createOscillator();
                            const spGain = audioContext.createGain();
                            sp.type = 'sine';
                            const freq = 1200 + i * 500;
                            sp.frequency.setValueAtTime(freq, now + 0.1 + i * 0.08);
                            sp.connect(spGain);
                            spGain.connect(audioContext.destination);
                            spGain.gain.setValueAtTime(0.08, now + 0.1 + i * 0.08);
                            spGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2 + i * 0.08);
                            sp.start(now + 0.1 + i * 0.08);
                            sp.stop(now + 0.2 + i * 0.08);
                        }
                    }
                    break;

                case 'frog': // Rechot z wieloma klikniƒôciami
                    {
                        const croakCount = 3;
                        for (let c = 0; c < croakCount; c++) {
                            const t = now + c * 0.1;
                            const osc = audioContext.createOscillator();
                            const gain = audioContext.createGain();
                            const filter = audioContext.createBiquadFilter();

                            osc.type = 'square';
                            osc.frequency.setValueAtTime(180, t);
                            osc.frequency.exponentialRampToValueAtTime(280, t + 0.02);
                            osc.frequency.exponentialRampToValueAtTime(160, t + 0.07);

                            filter.type = 'lowpass';
                            filter.frequency.value = 800;
                            filter.Q.value = 5;

                            osc.connect(filter);
                            filter.connect(gain);
                            gain.connect(audioContext.destination);

                            gain.gain.setValueAtTime(0, t);
                            gain.gain.linearRampToValueAtTime(0.3, t + 0.005);
                            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.08);

                            osc.start(t); osc.stop(t + 0.08);
                        }
                    }
                    break;

                case 'butterfly': // Delikatne trzepotanie skrzyde≈Ç
                    {
                        const noise = audioContext.createBufferSource();
                        const noiseGain = audioContext.createGain();
                        const filter = audioContext.createBiquadFilter();

                        const bufSize = audioContext.sampleRate * 0.3;
                        const buf = audioContext.createBuffer(1, bufSize, audioContext.sampleRate);
                        const d = buf.getChannelData(0);
                        for (let i = 0; i < bufSize; i++) d[i] = Math.random() * 2 - 1;
                        noise.buffer = buf;

                        filter.type = 'bandpass';
                        filter.frequency.value = 3000;
                        filter.Q.value = 3;

                        // Flutter modulation
                        const lfo = audioContext.createOscillator();
                        const lfoGain = audioContext.createGain();
                        lfo.type = 'sine';
                        lfo.frequency.value = 25; // Wing beat rate
                        lfoGain.gain.value = 0.08;

                        noise.connect(filter);
                        filter.connect(noiseGain);
                        lfo.connect(lfoGain);
                        lfoGain.connect(noiseGain.gain);
                        noiseGain.connect(audioContext.destination);

                        noiseGain.gain.setValueAtTime(0.06, now);
                        noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);

                        noise.start(now); noise.stop(now + 0.25);
                        lfo.start(now); lfo.stop(now + 0.25);
                    }
                    break;
            }
        }

        // Muzyka w tle - delikatna melodyjka
        let musicOscillators = [];
        let musicStarted = false;

        function startBackgroundMusic() {
            if (!musicStarted && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            if (!musicStarted) {
                // Melodia wy≈ÇƒÖczona
                // playBackgroundMelody();
                musicStarted = true;
            }
        }

        function playBackgroundMelody() {
            // Prosta, radosna melodia w pƒôtli
            const melody = [
                {note: 523.25, duration: 0.3}, // C5
                {note: 587.33, duration: 0.3}, // D5
                {note: 659.25, duration: 0.3}, // E5
                {note: 698.46, duration: 0.3}, // F5
                {note: 783.99, duration: 0.6}, // G5
                {note: 659.25, duration: 0.3}, // E5
                {note: 698.46, duration: 0.6}, // F5
                {note: 523.25, duration: 0.6}, // C5
            ];

            let time = audioContext.currentTime;

            function playNote(frequency, duration, startTime) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.type = 'sine';
                osc.frequency.value = frequency;

                osc.connect(gain);
                gain.connect(audioContext.destination);

                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(0.04, startTime + 0.02);
                gain.gain.linearRampToValueAtTime(0.025, startTime + duration - 0.05);
                gain.gain.linearRampToValueAtTime(0, startTime + duration);

                osc.start(startTime);
                osc.stop(startTime + duration);
            }

            function scheduleMelody() {
                time = audioContext.currentTime + 0.1;
                melody.forEach(note => {
                    playNote(note.note, note.duration, time);
                    time += note.duration + 0.1;
                });

                // Powt√≥rz melodiƒô
                setTimeout(scheduleMelody, (time - audioContext.currentTime) * 1000);
            }

            scheduleMelody();
        }

        const candyColors = ['#FF69B4', '#FFB6D9', '#E0C3FC', '#FFF4E0', '#D4F1F9', '#FF1493', '#DDA0DD', '#F0E68C'];

        // Generowanie chunka
        function generateChunk(chunkX) {
            if (generatedChunks.has(chunkX)) return;
            generatedChunks.add(chunkX);

            const startX = chunkX * chunkSize;

            // P≈Çaski grunt (opcjonalnie z delikatnymi wzg√≥rzami)
            const groundY = canvas.height - 100;
            ground.push({
                x: startX,
                y: groundY,
                width: chunkSize,
                height: 100
            });

            // Cukierki na ziemi
            const numCandies = 15 + Math.floor(Math.random() * 10);
            for (let i = 0; i < numCandies; i++) {
                candies.push({
                    x: startX + Math.random() * chunkSize,
                    y: groundY - 20,
                    collected: false,
                    type: Math.floor(Math.random() * 5)
                });
            }

            // Przyjaciel (co 2-3 chunki)
            if (chunkX > 0 && chunkX % 2 === 0) {
                const friendType = friendTypes[friendsToFind.length % friendTypes.length];
                const friendX = startX + chunkSize / 2;
                const hasHycel = (friendsToFind.length % 2 === 1); // Indices 1, 3, 5, 7, 9

                friendsToFind.push({
                    x: friendX,
                    y: groundY - 60,
                    type: friendType,
                    found: false,
                    bounceOffset: Math.random() * Math.PI * 2,
                    hasHycel: hasHycel
                });

                // Spawn hycel if needed
                if (hasHycel) {
                    hycels.push({
                        x: friendX - 100,
                        y: groundY - 80,
                        width: 70,
                        height: 80,
                        health: 3,
                        defeated: false,
                        friendIndex: friendsToFind.length - 1,
                        bounceOffset: 0,
                        angry: false,
                        friendType: friendType // Store which animal costume
                    });
                }

                // Domek (co 2-3 zwierzƒÖtko)
                if (friendsToFind.length % 3 === 0 || friendsToFind.length % 2 === 0) {
                    houses.push({
                        x: friendX + 150, // Obok zwierzƒÖtka
                        y: groundY,
                        width: 250,
                        height: 200
                    });
                }
            }

            // Kwiaty
            for (let i = 0; i < 20; i++) {
                flowers.push({
                    x: startX + Math.random() * chunkSize,
                    y: groundY - 10,
                    color: candyColors[Math.floor(Math.random() * candyColors.length)],
                    size: 15 + Math.random() * 10,
                    swayOffset: Math.random() * Math.PI * 2
                });
            }

            // Drzewa
            for (let i = 0; i < 5; i++) {
                trees.push({
                    x: startX + Math.random() * chunkSize,
                    y: groundY,
                    height: 80 + Math.random() * 60,
                    width: 40 + Math.random() * 30
                });
            }

            // Dekoracje (motyle, ptaszki)
            for (let i = 0; i < 8; i++) {
                decorations.push({
                    x: startX + Math.random() * chunkSize,
                    y: 100 + Math.random() * 200,
                    type: Math.random() > 0.5 ? 'butterfly' : 'bird',
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.5 + Math.random()
                });
            }

            // Zwierzƒôta mijajƒÖce (pszczo≈Çy, ≈ºuki, inne)
            const groundYForAnimals = canvas.height - 100;
            const animalTypes = [
                { emoji: 'üêù', speed: 1.5, flying: true, height: 150 }, // Pszczo≈Ça
                { emoji: 'üêû', speed: 0.8, flying: true, height: 200 }, // Biedronka
                { emoji: 'ü¶ó', speed: 0.5, flying: false, height: 30 }, // ≈öwierszcz
                { emoji: 'üêõ', speed: 0.3, flying: false, height: 20 }, // GƒÖsienica
                { emoji: 'ü¶ü', speed: 2, flying: true, height: 180 }, // Komarek
                { emoji: 'üïäÔ∏è', speed: 1.2, flying: true, height: 120 }, // Go≈ÇƒÖbek
                { emoji: 'ü¶Ö', speed: 1.8, flying: true, height: 80 }, // Orze≈Ç
                { emoji: 'üêøÔ∏è', speed: 1, flying: false, height: 35 }, // Wiewi√≥rka
                { emoji: 'üêÅ', speed: 0.7, flying: false, height: 25 }, // Myszka
                { emoji: 'üê¢', speed: 0.2, flying: false, height: 25 }, // ≈ª√≥≈Çw
            ];

            for (let i = 0; i < 10; i++) {
                const animalType = animalTypes[Math.floor(Math.random() * animalTypes.length)];
                passingAnimals.push({
                    x: startX + Math.random() * chunkSize,
                    y: animalType.flying ? animalType.height : groundYForAnimals - animalType.height,
                    emoji: animalType.emoji,
                    speed: animalType.speed,
                    direction: Math.random() > 0.5 ? 1 : -1,
                    flying: animalType.flying,
                    phase: Math.random() * Math.PI * 2,
                    minX: startX - 200,
                    maxX: startX + chunkSize + 200
                });
            }

            // Przedmioty do zbierania (rogi, ubranka, akcesoria)
            if (chunkX > 0) {
                // R√≥g (rzadko, co 5 chunk√≥w)
                if (chunkX % 5 === 0 && Math.random() > 0.3) {
                    const availableHorns = itemDefinitions.horns.filter(h => !collectedItems.horns.includes(h.id));
                    if (availableHorns.length > 0) {
                        const horn = availableHorns[Math.floor(Math.random() * availableHorns.length)];
                        itemsToCollect.push({
                            x: startX + chunkSize / 2 + (Math.random() - 0.5) * 300,
                            y: groundY - 40,
                            type: 'horn',
                            item: horn,
                            collected: false
                        });
                    }
                }

                // Ubranka (co 3 chunki)
                if (chunkX % 3 === 0 && Math.random() > 0.2) {
                    const availableOutfits = itemDefinitions.outfits.filter(o => !collectedItems.outfits.includes(o.id));
                    if (availableOutfits.length > 0) {
                        const outfit = availableOutfits[Math.floor(Math.random() * availableOutfits.length)];
                        itemsToCollect.push({
                            x: startX + chunkSize / 2 + (Math.random() - 0.5) * 400,
                            y: groundY - 35,
                            type: 'outfit',
                            item: outfit,
                            collected: false
                        });
                    }
                }

                // Akcesoria (co 4 chunki)
                if (chunkX % 4 === 0 && Math.random() > 0.3) {
                    const availableAccessories = itemDefinitions.accessories.filter(a => !collectedItems.accessories.includes(a.id));
                    if (availableAccessories.length > 0) {
                        const accessory = availableAccessories[Math.floor(Math.random() * availableAccessories.length)];
                        itemsToCollect.push({
                            x: startX + chunkSize / 2 + (Math.random() - 0.5) * 350,
                            y: groundY - 38,
                            type: 'accessory',
                            item: accessory,
                            collected: false
                        });
                    }
                }

                // Kolory (co 6 chunk√≥w)
                if (chunkX % 6 === 0 && Math.random() > 0.4) {
                    const availableColors = itemDefinitions.colors.filter(c => !collectedItems.colors.includes(c.id));
                    if (availableColors.length > 0) {
                        const colorItem = availableColors[Math.floor(Math.random() * availableColors.length)];
                        itemsToCollect.push({
                            x: startX + chunkSize / 2 + (Math.random() - 0.5) * 450,
                            y: groundY - 42,
                            type: 'color',
                            item: colorItem,
                            collected: false
                        });
                    }
                }
            }
        }

        function startGame() {
            document.getElementById('start-screen').classList.remove('active');
            gameRunning = true;
            score = 0;
            worldOffset = 0;
            gameTimeStart = Date.now();
            raindrops = [];
            followingFriends = [];
            playerHistory = [];
            ground = [];
            candies = [];
            friendsToFind = [];
            decorations = [];
            flowers = [];
            trees = [];
            passingAnimals = [];
            dialogBubbles = [];
            itemsToCollect = [];
            generatedChunks.clear();

            player.x = 300;
            player.y = canvas.height - 150;
            player.velY = 0;

            for (let i = -1; i <= 3; i++) {
                generateChunk(i);
            }

            updateFriendsList();
            updateWardrobe();
            gameLoop();
        }

        function closeFriendMessage() {
            document.getElementById('victory-screen').classList.remove('active');
            if (!gameRunning) {
                gameRunning = true;
                gameLoop();
            }
        }

        // Rysowanie chmurki dialogowej
        function drawDialogBubble(x, y, text, fromLeft = true) {
            const padding = 15;
            const lineHeight = 20;
            const maxWidth = 200;

            // Podziel tekst na linie
            ctx.font = '16px Comic Sans MS';
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';

            words.forEach(word => {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            });
            if (currentLine) lines.push(currentLine);

            const bubbleWidth = maxWidth + padding * 2;
            const bubbleHeight = lines.length * lineHeight + padding * 2;
            const bubbleX = fromLeft ? x + 50 : x - bubbleWidth - 50;
            const bubbleY = y - bubbleHeight - 40;

            // Chmurka (bia≈Çe t≈Ço)
            ctx.fillStyle = '#FFF';
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(bubbleX, bubbleY, bubbleWidth, bubbleHeight, 15);
            ctx.fill();
            ctx.stroke();

            // Ogon chmurki (tr√≥jkƒÖcik)
            ctx.fillStyle = '#FFF';
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 3;
            ctx.beginPath();
            if (fromLeft) {
                ctx.moveTo(bubbleX + 20, bubbleY + bubbleHeight);
                ctx.lineTo(x + 30, y - 20);
                ctx.lineTo(bubbleX + 40, bubbleY + bubbleHeight);
            } else {
                ctx.moveTo(bubbleX + bubbleWidth - 40, bubbleY + bubbleHeight);
                ctx.lineTo(x - 30, y - 20);
                ctx.lineTo(bubbleX + bubbleWidth - 20, bubbleY + bubbleHeight);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Tekst
            ctx.fillStyle = '#FF1493';
            ctx.font = 'bold 16px Comic Sans MS';
            lines.forEach((line, i) => {
                ctx.fillText(line, bubbleX + padding, bubbleY + padding + (i + 1) * lineHeight);
            });
        }

        // Aktualizuj i rysuj chmurki dialogowe
        function updateAndDrawDialogBubbles() {
            const currentTime = Date.now();
            dialogBubbles = dialogBubbles.filter(bubble => currentTime - bubble.startTime < bubble.duration);

            dialogBubbles.forEach(bubble => {
                const screenX = bubble.x - worldOffset;
                if (screenX > -300 && screenX < canvas.width + 300) {
                    drawDialogBubble(screenX, bubble.y, bubble.text, bubble.fromLeft);
                }
            });
        }

        // Rysowanie realistycznego Kicioro≈ºka
        function drawPlayer(x, y) {
            ctx.save();

            // Odbicie lustrzane gdy idzie w lewo
            if (!player.facingRight) {
                ctx.translate(x + player.width / 2, y + player.height / 2);
                ctx.scale(-1, 1);
                ctx.translate(-x - player.width / 2, -y - player.height / 2);
            }

            const walkOffset = Math.sin(player.walkCycle) * 3;
            player.tailSwing += 0.1;

            // Kolory z wybranego koloru futerka
            const colorDef = itemDefinitions.colors.find(c => c.id === player.equippedColor);
            const bodyColor = colorDef.bodyColor;
            const shadeColor = colorDef.shadeColor;

            // Cie≈Ñ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.ellipse(x + 30, y + 75, 25, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Ogon (d≈Çugi i puszyty)
            ctx.strokeStyle = shadeColor;
            ctx.lineWidth = 12;
            ctx.lineCap = 'round';
            const tailX = x + 10;
            const tailY = y + 40;
            const tailCurve = Math.sin(player.tailSwing) * 20;
            ctx.beginPath();
            ctx.moveTo(tailX, tailY);
            ctx.quadraticCurveTo(
                tailX - 30 + tailCurve, tailY - 20,
                tailX - 40, tailY - 40
            );
            ctx.stroke();

            // Koniec ogona (puszysty)
            ctx.fillStyle = shadeColor;
            ctx.beginPath();
            ctx.arc(tailX - 40, tailY - 40, 8, 0, Math.PI * 2);
            ctx.fill();

            // PELERYNA (rysowana ZA PLECAMI!)
            if (player.equippedOutfit === 'cape') {
                ctx.fillStyle = '#DC143C';
                ctx.beginPath();
                ctx.moveTo(x + 20, y + 30);
                ctx.lineTo(x, y + 70);
                ctx.lineTo(x + 40, y + 70);
                ctx.lineTo(x + 40, y + 30);
                ctx.fill();
                // Z≈Çoty ko≈Çnierz
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(x + 15, y + 28, 30, 6);
            }

            // Tylne ≈Çapki
            ctx.fillStyle = bodyColor;
            // Lewa tylna
            ctx.beginPath();
            ctx.ellipse(x + 15, y + 60 + walkOffset, 10, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            // Prawa tylna
            ctx.beginPath();
            ctx.ellipse(x + 35, y + 60 - walkOffset, 10, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Cia≈Ço (wiƒôksze, bardziej kocie)
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.ellipse(x + 30, y + 45, 28, 35, 0, 0, Math.PI * 2);
            ctx.fill();

            // Gradient na brzuszku (ja≈õniejszy odcie≈Ñ)
            const gradient = ctx.createRadialGradient(x + 30, y + 50, 5, x + 30, y + 50, 25);
            // Ja≈õniejszy odcie≈Ñ koloru cia≈Ça
            const lighterColor = bodyColor + (bodyColor.length === 4 ? 'E' : 'EE');
            gradient.addColorStop(0, lighterColor);
            gradient.addColorStop(1, bodyColor + '00');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.ellipse(x + 30, y + 50, 18, 25, 0, 0, Math.PI * 2);
            ctx.fill();

            // Przednie ≈Çapki
            ctx.fillStyle = bodyColor;
            // Lewa przednia
            ctx.beginPath();
            ctx.ellipse(x + 20, y + 65 - walkOffset, 8, 18, 0, 0, Math.PI * 2);
            ctx.fill();
            // Prawa przednia
            ctx.beginPath();
            ctx.ellipse(x + 40, y + 65 + walkOffset, 8, 18, 0, 0, Math.PI * 2);
            ctx.fill();

            // Paluszki na ≈Çapkach (ciemniejszy odcie≈Ñ)
            ctx.fillStyle = shadeColor;
            [20, 40].forEach(offsetX => {
                for (let i = -1; i <= 1; i++) {
                    ctx.beginPath();
                    ctx.arc(x + offsetX + i * 3, y + 75, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // G≈Çowa (wiƒôksza, bardziej szczeg√≥≈Çowa)
            ctx.fillStyle = shadeColor;
            ctx.beginPath();
            ctx.arc(x + 35, y + 25, 22, 0, Math.PI * 2);
            ctx.fill();

            // Policzki (rumie≈Ñce - zawsze r√≥≈ºowe)
            ctx.fillStyle = 'rgba(255, 105, 180, 0.3)';
            ctx.beginPath();
            ctx.arc(x + 20, y + 30, 8, 0, Math.PI * 2);
            ctx.arc(x + 50, y + 30, 8, 0, Math.PI * 2);
            ctx.fill();

            // Uszy (wiƒôksze)
            ctx.fillStyle = shadeColor;
            // Lewe ucho
            ctx.beginPath();
            ctx.moveTo(x + 20, y + 15);
            ctx.lineTo(x + 15, y);
            ctx.lineTo(x + 25, y + 10);
            ctx.fill();
            // ≈örodek lewego ucha (ja≈õniejszy)
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.moveTo(x + 20, y + 13);
            ctx.lineTo(x + 18, y + 5);
            ctx.lineTo(x + 23, y + 11);
            ctx.fill();

            // Prawe ucho
            ctx.fillStyle = shadeColor;
            ctx.beginPath();
            ctx.moveTo(x + 50, y + 15);
            ctx.lineTo(x + 55, y);
            ctx.lineTo(x + 45, y + 10);
            ctx.fill();
            // ≈örodek prawego ucha (ja≈õniejszy)
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.moveTo(x + 50, y + 13);
            ctx.lineTo(x + 52, y + 5);
            ctx.lineTo(x + 47, y + 11);
            ctx.fill();

            // R√≥g jednoro≈ºca (piƒôkny, spiralny, w wybranym kolorze! DU≈ªO WIƒòKSZY - 2x!)
            const hornDef = itemDefinitions.horns.find(h => h.id === player.equippedHorn);

            if (hornDef.id === 'rainbow') {
                // Tƒôczowy r√≥g (gradient) - 2x wiƒôkszy, na czole
                const rainbowGradient = ctx.createLinearGradient(x + 29, y - 20, x + 41, y + 10);
                rainbowGradient.addColorStop(0, '#FF0000');
                rainbowGradient.addColorStop(0.17, '#FF7F00');
                rainbowGradient.addColorStop(0.33, '#FFFF00');
                rainbowGradient.addColorStop(0.5, '#00FF00');
                rainbowGradient.addColorStop(0.67, '#0000FF');
                rainbowGradient.addColorStop(0.83, '#4B0082');
                rainbowGradient.addColorStop(1, '#9400D3');
                ctx.fillStyle = rainbowGradient;
            } else {
                ctx.fillStyle = hornDef.color;
            }

            // Wiƒôkszy tr√≥jkƒÖt rogu - na czole zamiast na nosie
            ctx.beginPath();
            ctx.moveTo(x + 35, y - 20);  // G√≥ra znacznie wy≈ºej (na czole)
            ctx.lineTo(x + 29, y + 10);  // Lewa krawƒôd≈∫ - podstawa na czole
            ctx.lineTo(x + 41, y + 10);  // Prawa krawƒôd≈∫ - podstawa na czole
            ctx.fill();

            // Spirala na rogu (ciemniejszy odcie≈Ñ) - wiƒôksza
            if (hornDef.id === 'rainbow') {
                ctx.strokeStyle = '#9400D3';
            } else if (hornDef.color) {
                // Ciemniejszy odcie≈Ñ koloru rogu
                ctx.strokeStyle = hornDef.color.replace(/[0-9A-F]{2}([0-9A-F]{2})([0-9A-F]{2})/i, (match, p1, p2) => {
                    return match.slice(0, -6) +
                           Math.max(0, parseInt(p1, 16) - 30).toString(16).padStart(2, '0') +
                           Math.max(0, parseInt(p2, 16) - 30).toString(16).padStart(2, '0');
                });
            } else {
                ctx.strokeStyle = '#FFA500';
            }

            ctx.lineWidth = 3;  // Grubsza spirala
            for (let i = 0; i < 5; i++) {  // Wiƒôcej spiral (5 zamiast 3)
                ctx.beginPath();
                ctx.arc(x + 35, y - 15 + i * 6, 5, 0, Math.PI);  // Spirale wy≈ºej, na czole
                ctx.stroke();
            }

            // Blask na rogu - wiƒôkszy i wy≈ºej
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(x + 37, y - 13, 4, 0, Math.PI * 2);
            ctx.fill();

            // Oczy (du≈ºe, s≈Çodkie)
            ctx.fillStyle = '#000';
            // Lewe oko
            ctx.beginPath();
            ctx.ellipse(x + 26, y + 23, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            // Prawe oko
            ctx.beginPath();
            ctx.ellipse(x + 44, y + 23, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // B≈Çyski w oczach
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x + 27, y + 22, 2, 0, Math.PI * 2);
            ctx.arc(x + 45, y + 22, 2, 0, Math.PI * 2);
            ctx.fill();

            // Nosek (tr√≥jkƒÖcik)
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.moveTo(x + 35, y + 28);
            ctx.lineTo(x + 33, y + 32);
            ctx.lineTo(x + 37, y + 32);
            ctx.fill();

            // Buzia (u≈õmiech)
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(x + 35, y + 32, 6, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // WƒÖsy (d≈Çugie)
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            // Lewe wƒÖsy
            ctx.beginPath();
            ctx.moveTo(x + 35, y + 30);
            ctx.lineTo(x + 15, y + 26);
            ctx.moveTo(x + 35, y + 30);
            ctx.lineTo(x + 15, y + 32);
            ctx.stroke();
            // Prawe wƒÖsy
            ctx.beginPath();
            ctx.moveTo(x + 35, y + 30);
            ctx.lineTo(x + 55, y + 26);
            ctx.moveTo(x + 35, y + 30);
            ctx.lineTo(x + 55, y + 32);
            ctx.stroke();

            // Ubranka NA CIELE (WIƒòKSZE I BARDZIEJ WIDOCZNE!)
            if (player.equippedOutfit) {
                const outfitDef = itemDefinitions.outfits.find(o => o.id === player.equippedOutfit);

                if (outfitDef.id === 'cape') {
                    // Gwiazda na pelerynie (peleryna ju≈º narysowana wcze≈õniej)
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText('‚≠ê', x + 20, y + 52);
                } else if (outfitDef.id === 'dress') {
                    // Sukienka ksiƒô≈ºniczki (R√ì≈ªOWA, ROZKLOSZOWANA!)
                    // G√≥ra sukienki (dopasowana)
                    ctx.fillStyle = '#FF1493';
                    ctx.fillRect(x + 15, y + 38, 30, 15);

                    // D√≥≈Ç sukienki (rozkloszowany trapez)
                    ctx.beginPath();
                    ctx.moveTo(x + 15, y + 53); // lewy g√≥rny r√≥g
                    ctx.lineTo(x + 5, y + 72);  // lewy dolny r√≥g (szerszy)
                    ctx.lineTo(x + 55, y + 72); // prawy dolny r√≥g (szerszy)
                    ctx.lineTo(x + 45, y + 53); // prawy g√≥rny r√≥g
                    ctx.closePath();
                    ctx.fill();

                    // Wzorki - bia≈Çe kropki na sukience
                    ctx.fillStyle = '#FFF';
                    for (let i = 0; i < 8; i++) {
                        for (let j = 0; j < 2; j++) {
                            ctx.beginPath();
                            ctx.arc(x + 12 + i * 6, y + 58 + j * 8, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Pasek (z≈Çoty)
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(x + 14, y + 52, 32, 4);

                    // Kokarda na pasku
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(x + 25, y + 54, 4, 0, Math.PI * 2);
                    ctx.arc(x + 35, y + 54, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + 30, y + 54, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (outfitDef.id === 'scarf') {
                    // Szalik (GRUBY I KOLOROWY!)
                    ctx.strokeStyle = '#FF1493';
                    ctx.lineWidth = 12;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(x + 15, y + 32);
                    ctx.lineTo(x + 50, y + 35);
                    ctx.stroke();
                    // Paski na szaliku
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(x + 20 + i * 10, y + 30);
                        ctx.lineTo(x + 25 + i * 10, y + 36);
                        ctx.stroke();
                    }
                    // Frƒôdzle
                    ctx.strokeStyle = '#FF1493';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(x + 48, y + 36);
                    ctx.lineTo(x + 52, y + 46);
                    ctx.moveTo(x + 52, y + 36);
                    ctx.lineTo(x + 56, y + 48);
                    ctx.stroke();
                } else if (outfitDef.id === 'shirt') {
                    // Koszulka (NIEBIESKA!)
                    ctx.fillStyle = '#1E90FF';
                    ctx.fillRect(x + 12, y + 38, 36, 28);
                    // Ko≈Çnierzyk
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.moveTo(x + 25, y + 38);
                    ctx.lineTo(x + 20, y + 42);
                    ctx.lineTo(x + 30, y + 42);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(x + 35, y + 38);
                    ctx.lineTo(x + 40, y + 42);
                    ctx.lineTo(x + 30, y + 42);
                    ctx.fill();
                    // Kieszonka
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x + 22, y + 50, 8, 8);
                } else if (outfitDef.id === 'sweater') {
                    // Sweterek (FIOLETOWY!)
                    ctx.fillStyle = '#9370DB';
                    ctx.fillRect(x + 10, y + 36, 40, 32);
                    // Paski
                    ctx.fillStyle = '#E6E6FA';
                    ctx.fillRect(x + 10, y + 44, 40, 4);
                    ctx.fillRect(x + 10, y + 56, 40, 4);
                    // Guziki (DU≈ªE!)
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(x + 30, y + 42, 3, 0, Math.PI * 2);
                    ctx.arc(x + 30, y + 51, 3, 0, Math.PI * 2);
                    ctx.arc(x + 30, y + 60, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Akcesoria (WIƒòKSZE I WYRA≈πNIEJSZE!)
            if (player.equippedAccessory) {
                const accessoryDef = itemDefinitions.accessories.find(a => a.id === player.equippedAccessory);

                if (accessoryDef.id === 'crown') {
                    // Korona (DU≈ªA!)
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.moveTo(x + 20, y + 3);
                    ctx.lineTo(x + 22, y - 8);
                    ctx.lineTo(x + 27, y);
                    ctx.lineTo(x + 30, y - 10);
                    ctx.lineTo(x + 33, y);
                    ctx.lineTo(x + 38, y - 8);
                    ctx.lineTo(x + 40, y + 3);
                    ctx.lineTo(x + 35, y + 6);
                    ctx.lineTo(x + 25, y + 6);
                    ctx.closePath();
                    ctx.fill();
                    // Klejnoty (DU≈ªE!)
                    ctx.fillStyle = '#FF1493';
                    ctx.beginPath();
                    ctx.arc(x + 27, y - 2, 3, 0, Math.PI * 2);
                    ctx.arc(x + 33, y - 2, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#00FF00';
                    ctx.beginPath();
                    ctx.arc(x + 30, y - 5, 4, 0, Math.PI * 2);
                    ctx.fill();
                    // Obw√≥dka
                    ctx.strokeStyle = '#B8860B';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + 20, y + 3);
                    ctx.lineTo(x + 40, y + 3);
                    ctx.stroke();
                } else if (accessoryDef.id === 'bow') {
                    // Kokarda (DU≈ªA!)
                    ctx.fillStyle = '#FF1493';
                    ctx.beginPath();
                    ctx.arc(x + 24, y + 6, 9, 0, Math.PI * 2);
                    ctx.arc(x + 46, y + 6, 9, 0, Math.PI * 2);
                    ctx.fill();
                    // ≈örodek kokardy
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(x + 30, y + 2, 10, 8);
                    // Wzory kropki
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(x + 24, y + 4, 2, 0, Math.PI * 2);
                    ctx.arc(x + 46, y + 4, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (accessoryDef.id === 'glasses') {
                    // Okulary (WIƒòKSZE!)
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    // Lewe szk≈Ço
                    ctx.beginPath();
                    ctx.arc(x + 24, y + 23, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    // Prawe szk≈Ço
                    ctx.beginPath();
                    ctx.arc(x + 46, y + 23, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    // Mostek
                    ctx.beginPath();
                    ctx.moveTo(x + 32, y + 23);
                    ctx.lineTo(x + 38, y + 23);
                    ctx.stroke();
                    // Zauszniki
                    ctx.beginPath();
                    ctx.moveTo(x + 16, y + 23);
                    ctx.lineTo(x + 12, y + 25);
                    ctx.moveTo(x + 54, y + 23);
                    ctx.lineTo(x + 58, y + 25);
                    ctx.stroke();
                    // B≈Çysk na szk≈Çach
                    ctx.fillStyle = 'rgba(135, 206, 250, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x + 24, y + 23, 7, 0, Math.PI * 2);
                    ctx.arc(x + 46, y + 23, 7, 0, Math.PI * 2);
                    ctx.fill();
                } else if (accessoryDef.id === 'hat') {
                    // Kapelusz (WIƒòKSZY!)
                    ctx.fillStyle = '#654321';
                    // Korpus
                    ctx.fillRect(x + 20, y - 4, 30, 12);
                    // Rondo
                    ctx.beginPath();
                    ctx.ellipse(x + 35, y + 8, 24, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // WstƒÖ≈ºka
                    ctx.fillStyle = '#8B0000';
                    ctx.fillRect(x + 20, y + 4, 30, 4);
                } else if (accessoryDef.id === 'flower') {
                    // Kwiatek (DU≈ªY!)
                    ctx.fillStyle = '#FF69B4';
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const px = x + 24 + Math.cos(angle) * 9;
                        const py = y + 6 + Math.sin(angle) * 9;
                        ctx.beginPath();
                        ctx.arc(px, py, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // ≈örodek kwiatka
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(x + 24, y + 6, 5, 0, Math.PI * 2);
                    ctx.fill();
                    // ≈Åody≈ºka
                    ctx.strokeStyle = '#228B22';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x + 24, y + 11);
                    ctx.lineTo(x + 24, y + 18);
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        // Rysowanie psa (Tƒôczowy Piesek)
        function drawDog(x, y, scale = 1) {
            const s = scale;
            // Ogon
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x - 15 * s, y + 30 * s, 12 * s, 0, Math.PI * 2);
            ctx.fill();

            // Cia≈Ço
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.ellipse(x, y + 30 * s, 18 * s, 25 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // ≈Åapki
            ctx.fillStyle = '#FFA500';
            ctx.fillRect(x - 12 * s, y + 50 * s, 8 * s, 18 * s);
            ctx.fillRect(x + 4 * s, y + 50 * s, 8 * s, 18 * s);

            // G≈Ç√≥wka
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x, y + 10 * s, 15 * s, 0, Math.PI * 2);
            ctx.fill();

            // Uszy
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.ellipse(x - 12 * s, y + 8 * s, 6 * s, 12 * s, -0.3, 0, Math.PI * 2);
            ctx.ellipse(x + 12 * s, y + 8 * s, 6 * s, 12 * s, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 5 * s, y + 8 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(x + 5 * s, y + 8 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // B≈Çysk w oczach
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 4 * s, y + 7 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.arc(x + 6 * s, y + 7 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y + 15 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // Jƒôzyk
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.ellipse(x, y + 20 * s, 3 * s, 5 * s, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie kr√≥liczka
        function drawRabbit(x, y, scale = 1) {
            const s = scale;
            // Ogon (puszek)
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.arc(x - 12 * s, y + 40 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();

            // Cia≈Ço
            ctx.fillStyle = '#FFC0CB';
            ctx.beginPath();
            ctx.ellipse(x, y + 35 * s, 16 * s, 22 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // ≈Åapki
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.ellipse(x - 10 * s, y + 55 * s, 7 * s, 10 * s, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 10 * s, y + 55 * s, 7 * s, 10 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // G≈Ç√≥wka
            ctx.fillStyle = '#FFC0CB';
            ctx.beginPath();
            ctx.arc(x, y + 15 * s, 13 * s, 0, Math.PI * 2);
            ctx.fill();

            // D≈Çugie uszy
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.ellipse(x - 8 * s, y - 5 * s, 5 * s, 20 * s, -0.2, 0, Math.PI * 2);
            ctx.ellipse(x + 8 * s, y - 5 * s, 5 * s, 20 * s, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // ≈örodek ucha
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.ellipse(x - 8 * s, y - 5 * s, 3 * s, 15 * s, -0.2, 0, Math.PI * 2);
            ctx.ellipse(x + 8 * s, y - 5 * s, 3 * s, 15 * s, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 5 * s, y + 13 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(x + 5 * s, y + 13 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.moveTo(x, y + 18 * s);
            ctx.lineTo(x - 2 * s, y + 21 * s);
            ctx.lineTo(x + 2 * s, y + 21 * s);
            ctx.fill();
        }

        // Rysowanie misia
        function drawBear(x, y, scale = 1) {
            const s = scale;
            // Cia≈Ço
            ctx.fillStyle = '#DDA0DD';
            ctx.beginPath();
            ctx.ellipse(x, y + 35 * s, 20 * s, 28 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek
            ctx.fillStyle = '#E6B8E6';
            ctx.beginPath();
            ctx.ellipse(x, y + 40 * s, 14 * s, 20 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // ≈Åapki
            ctx.fillStyle = '#DDA0DD';
            ctx.beginPath();
            ctx.ellipse(x - 18 * s, y + 30 * s, 8 * s, 12 * s, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 18 * s, y + 30 * s, 8 * s, 12 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nogi
            ctx.fillStyle = '#DDA0DD';
            ctx.fillRect(x - 12 * s, y + 58 * s, 10 * s, 12 * s);
            ctx.fillRect(x + 2 * s, y + 58 * s, 10 * s, 12 * s);

            // G≈Ç√≥wka
            ctx.fillStyle = '#DDA0DD';
            ctx.beginPath();
            ctx.arc(x, y + 12 * s, 16 * s, 0, Math.PI * 2);
            ctx.fill();

            // Uszy (okrƒÖg≈Çe)
            ctx.fillStyle = '#BA7FBA';
            ctx.beginPath();
            ctx.arc(x - 12 * s, y + 2 * s, 8 * s, 0, Math.PI * 2);
            ctx.arc(x + 12 * s, y + 2 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();

            // Pysk
            ctx.fillStyle = '#E6B8E6';
            ctx.beginPath();
            ctx.ellipse(x, y + 16 * s, 10 * s, 8 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 6 * s, y + 10 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(x + 6 * s, y + 10 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y + 18 * s, 4 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie baranka
        function drawSheep(x, y, scale = 1) {
            const s = scale;
            // We≈Çniane kulki na ciele
            ctx.fillStyle = '#E0C3FC';
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const rx = Math.cos(angle) * 15 * s;
                const ry = Math.sin(angle) * 18 * s;
                ctx.beginPath();
                ctx.arc(x + rx, y + 35 * s + ry, 10 * s, 0, Math.PI * 2);
                ctx.fill();
            }

            // G≈Ç√≥wne cia≈Ço
            ctx.fillStyle = '#E0C3FC';
            ctx.beginPath();
            ctx.ellipse(x, y + 35 * s, 18 * s, 22 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nogi
            ctx.fillStyle = '#D8BFD8';
            ctx.fillRect(x - 14 * s, y + 52 * s, 7 * s, 16 * s);
            ctx.fillRect(x - 3 * s, y + 52 * s, 7 * s, 16 * s);
            ctx.fillRect(x + 8 * s, y + 52 * s, 7 * s, 16 * s);

            // G≈Ç√≥wka
            ctx.fillStyle = '#F0E6FF';
            ctx.beginPath();
            ctx.ellipse(x, y + 12 * s, 12 * s, 14 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // We≈Çniane kulki na g≈Çowie
            ctx.fillStyle = '#E0C3FC';
            ctx.beginPath();
            ctx.arc(x - 8 * s, y + 5 * s, 7 * s, 0, Math.PI * 2);
            ctx.arc(x + 8 * s, y + 5 * s, 7 * s, 0, Math.PI * 2);
            ctx.arc(x, y + 0, 7 * s, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 4 * s, y + 12 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(x + 4 * s, y + 12 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y + 18 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie delfina
        function drawDolphin(x, y, scale = 1) {
            const s = scale;
            // Cia≈Ço
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.ellipse(x, y + 30 * s, 15 * s, 25 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek
            ctx.fillStyle = '#B0E0E6';
            ctx.beginPath();
            ctx.ellipse(x, y + 35 * s, 10 * s, 18 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // P≈Çetwy boczne
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.ellipse(x - 15 * s, y + 30 * s, 10 * s, 6 * s, -0.5, 0, Math.PI * 2);
            ctx.ellipse(x + 15 * s, y + 30 * s, 10 * s, 6 * s, 0.5, 0, Math.PI * 2);
            ctx.fill();

            // G≈Ç√≥wka z dziobem
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.arc(x, y + 10 * s, 13 * s, 0, Math.PI * 2);
            ctx.fill();

            // Dzi√≥b
            ctx.fillStyle = '#6CA6CD';
            ctx.beginPath();
            ctx.ellipse(x, y + 2 * s, 8 * s, 6 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 5 * s, y + 8 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(x + 5 * s, y + 8 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // B≈Çysk w oczach
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 4 * s, y + 7 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.arc(x + 6 * s, y + 7 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.fill();

            // Ogon
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.moveTo(x - 10 * s, y + 55 * s);
            ctx.lineTo(x, y + 50 * s);
            ctx.lineTo(x + 10 * s, y + 55 * s);
            ctx.fill();

            // P≈Çetwa grzbietowa
            ctx.fillStyle = '#6CA6CD';
            ctx.beginPath();
            ctx.moveTo(x - 5 * s, y + 25 * s);
            ctx.lineTo(x, y + 15 * s);
            ctx.lineTo(x + 5 * s, y + 25 * s);
            ctx.fill();
        }

        // Rysowanie lisa
        function drawFox(x, y, scale = 1) {
            const s = scale;
            // Puszysty ogon
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.arc(x - 18 * s, y + 40 * s, 20 * s, 0, Math.PI * 2);
            ctx.fill();

            // Bia≈Çy czubek ogona
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 22 * s, y + 35 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();

            // Cia≈Ço
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.ellipse(x, y + 35 * s, 18 * s, 25 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek (bia≈Çe)
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.ellipse(x, y + 40 * s, 12 * s, 18 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nogi
            ctx.fillStyle = '#FF8C00';
            ctx.fillRect(x - 12 * s, y + 55 * s, 8 * s, 14 * s);
            ctx.fillRect(x + 4 * s, y + 55 * s, 8 * s, 14 * s);

            // Bia≈Çe ≈Çapki
            ctx.fillStyle = '#FFF';
            ctx.fillRect(x - 12 * s, y + 65 * s, 8 * s, 4 * s);
            ctx.fillRect(x + 4 * s, y + 65 * s, 8 * s, 4 * s);

            // G≈Ç√≥wka
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.arc(x, y + 12 * s, 14 * s, 0, Math.PI * 2);
            ctx.fill();

            // Bia≈Çe policzki/pysk
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.ellipse(x, y + 18 * s, 10 * s, 8 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Uszy (tr√≥jkƒÖtne)
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.moveTo(x - 10 * s, y + 5 * s);
            ctx.lineTo(x - 14 * s, y - 8 * s);
            ctx.lineTo(x - 6 * s, y + 2 * s);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x + 10 * s, y + 5 * s);
            ctx.lineTo(x + 14 * s, y - 8 * s);
            ctx.lineTo(x + 6 * s, y + 2 * s);
            ctx.fill();

            // Bia≈Çe ≈õrodki uszu
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.moveTo(x - 10 * s, y + 3 * s);
            ctx.lineTo(x - 12 * s, y - 4 * s);
            ctx.lineTo(x - 8 * s, y + 1 * s);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x + 10 * s, y + 3 * s);
            ctx.lineTo(x + 12 * s, y - 4 * s);
            ctx.lineTo(x + 8 * s, y + 1 * s);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 5 * s, y + 10 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(x + 5 * s, y + 10 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // B≈Çysk w oczach
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 4 * s, y + 9 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.arc(x + 6 * s, y + 9 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y + 17 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie pandy
        function drawPanda(x, y, scale = 1) {
            const s = scale;
            // Cia≈Ço (bia≈Çe)
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.ellipse(x, y + 38 * s, 20 * s, 28 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Czarna ≈Çata na brzuchu
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(x, y + 45 * s, 12 * s, 15 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // ≈Åapy (czarne)
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(x - 18 * s, y + 32 * s, 9 * s, 14 * s, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 18 * s, y + 32 * s, 9 * s, 14 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nogi (czarne)
            ctx.fillStyle = '#000';
            ctx.fillRect(x - 14 * s, y + 60 * s, 11 * s, 12 * s);
            ctx.fillRect(x + 3 * s, y + 60 * s, 11 * s, 12 * s);

            // G≈Ç√≥wka (bia≈Ça)
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x, y + 14 * s, 17 * s, 0, Math.PI * 2);
            ctx.fill();

            // Uszy (czarne, okrƒÖg≈Çe)
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 13 * s, y + 3 * s, 9 * s, 0, Math.PI * 2);
            ctx.arc(x + 13 * s, y + 3 * s, 9 * s, 0, Math.PI * 2);
            ctx.fill();

            // Oczy z czarnymi plamami
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(x - 7 * s, y + 12 * s, 8 * s, 10 * s, -0.2, 0, Math.PI * 2);
            ctx.ellipse(x + 7 * s, y + 12 * s, 8 * s, 10 * s, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Bia≈Çe ga≈Çki oczne
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 7 * s, y + 13 * s, 4 * s, 0, Math.PI * 2);
            ctx.arc(x + 7 * s, y + 13 * s, 4 * s, 0, Math.PI * 2);
            ctx.fill();

            // ≈πrenice
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 6 * s, y + 13 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(x + 8 * s, y + 13 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y + 20 * s, 4 * s, 0, Math.PI * 2);
            ctx.fill();

            // U≈õmiech
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.arc(x, y + 22 * s, 6 * s, 0.2, Math.PI - 0.2);
            ctx.stroke();
        }

        // Rysowanie jednoro≈ºca (siostrzyczka)
        function drawUnicorn(x, y, scale = 1) {
            const s = scale;
            // Ogon (tƒôczowy!)
            const tailGradient = ctx.createLinearGradient(x - 25 * s, y + 30 * s, x - 35 * s, y + 50 * s);
            tailGradient.addColorStop(0, '#FF69B4');
            tailGradient.addColorStop(0.5, '#E0C3FC');
            tailGradient.addColorStop(1, '#87CEEB');
            ctx.strokeStyle = tailGradient;
            ctx.lineWidth = 15 * s;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x - 10 * s, y + 40 * s);
            ctx.quadraticCurveTo(x - 25 * s, y + 35 * s, x - 35 * s, y + 50 * s);
            ctx.stroke();

            // Cia≈Ço
            ctx.fillStyle = '#E0B0FF';
            ctx.beginPath();
            ctx.ellipse(x, y + 38 * s, 20 * s, 28 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek (ja≈õniejszy)
            ctx.fillStyle = '#F0E0FF';
            ctx.beginPath();
            ctx.ellipse(x, y + 42 * s, 14 * s, 20 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nogi
            ctx.fillStyle = '#E0B0FF';
            ctx.fillRect(x - 14 * s, y + 60 * s, 10 * s, 16 * s);
            ctx.fillRect(x + 4 * s, y + 60 * s, 10 * s, 16 * s);

            // Kopytka (z≈Çote)
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(x - 14 * s, y + 72 * s, 10 * s, 4 * s);
            ctx.fillRect(x + 4 * s, y + 72 * s, 10 * s, 4 * s);

            // G≈Ç√≥wka
            ctx.fillStyle = '#E0B0FF';
            ctx.beginPath();
            ctx.arc(x, y + 14 * s, 16 * s, 0, Math.PI * 2);
            ctx.fill();

            // Grzywka (tƒôczowa!)
            const maneGradient = ctx.createLinearGradient(x - 15 * s, y, x + 15 * s, y + 20 * s);
            maneGradient.addColorStop(0, '#FF69B4');
            maneGradient.addColorStop(0.33, '#FFD700');
            maneGradient.addColorStop(0.67, '#87CEEB');
            maneGradient.addColorStop(1, '#E0C3FC');
            ctx.fillStyle = maneGradient;
            ctx.beginPath();
            ctx.arc(x - 12 * s, y + 5 * s, 10 * s, 0, Math.PI * 2);
            ctx.arc(x - 5 * s, y + 2 * s, 10 * s, 0, Math.PI * 2);
            ctx.arc(x + 5 * s, y + 2 * s, 10 * s, 0, Math.PI * 2);
            ctx.arc(x + 12 * s, y + 5 * s, 10 * s, 0, Math.PI * 2);
            ctx.fill();

            // R√≥g (tƒôczowy gradient)
            const hornGradient = ctx.createLinearGradient(x - 2 * s, y - 10 * s, x + 2 * s, y + 10 * s);
            hornGradient.addColorStop(0, '#FFD700');
            hornGradient.addColorStop(0.5, '#FF69B4');
            hornGradient.addColorStop(1, '#E0C3FC');
            ctx.fillStyle = hornGradient;
            ctx.beginPath();
            ctx.moveTo(x, y - 10 * s);
            ctx.lineTo(x - 4 * s, y + 5 * s);
            ctx.lineTo(x + 4 * s, y + 5 * s);
            ctx.fill();

            // Spirala na rogu
            ctx.strokeStyle = '#9370DB';
            ctx.lineWidth = 2 * s;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(x, y - 5 * s + i * 4 * s, 3 * s, 0, Math.PI);
                ctx.stroke();
            }

            // Oczy (du≈ºe, bajkowe)
            ctx.fillStyle = '#8B008B';
            ctx.beginPath();
            ctx.arc(x - 6 * s, y + 13 * s, 4 * s, 0, Math.PI * 2);
            ctx.arc(x + 6 * s, y + 13 * s, 4 * s, 0, Math.PI * 2);
            ctx.fill();

            // B≈Çyski w oczach
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 5 * s, y + 12 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(x + 7 * s, y + 12 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.arc(x, y + 20 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // Gwiazdki wok√≥≈Ç (magiczne!)
            ctx.fillStyle = '#FFD700';
            [[x - 22 * s, y + 10 * s], [x + 22 * s, y + 10 * s], [x, y - 15 * s]].forEach(([sx, sy]) => {
                ctx.beginPath();
                for (let j = 0; j < 5; j++) {
                    const angle = (j * 2 * Math.PI / 5) - Math.PI / 2;
                    const r = j % 2 === 0 ? 4 * s : 2 * s;
                    const px = sx + Math.cos(angle) * r;
                    const py = sy + Math.sin(angle) * r;
                    if (j === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
            });
        }

        // Rysowanie ≈ºabki
        function drawFrog(x, y, scale = 1) {
            const s = scale;
            // Cia≈Ço (zielone)
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.ellipse(x, y + 40 * s, 20 * s, 22 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek (ja≈õniejszy)
            ctx.fillStyle = '#B0FFB0';
            ctx.beginPath();
            ctx.ellipse(x, y + 45 * s, 14 * s, 16 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tylne nogi (du≈ºe, ≈ºabie)
            ctx.fillStyle = '#90EE90';
            // Lewa noga
            ctx.beginPath();
            ctx.ellipse(x - 20 * s, y + 55 * s, 12 * s, 8 * s, -0.5, 0, Math.PI * 2);
            ctx.fill();
            // Stopa lewa
            ctx.beginPath();
            ctx.ellipse(x - 28 * s, y + 62 * s, 10 * s, 6 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Prawa noga
            ctx.beginPath();
            ctx.ellipse(x + 20 * s, y + 55 * s, 12 * s, 8 * s, 0.5, 0, Math.PI * 2);
            ctx.fill();
            // Stopa prawa
            ctx.beginPath();
            ctx.ellipse(x + 28 * s, y + 62 * s, 10 * s, 6 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Palce na stopach
            ctx.fillStyle = '#7FBF7F';
            for (let i = -1; i <= 1; i++) {
                ctx.beginPath();
                ctx.ellipse(x - 28 * s + i * 5 * s, y + 66 * s, 2 * s, 4 * s, 0, 0, Math.PI * 2);
                ctx.ellipse(x + 28 * s + i * 5 * s, y + 66 * s, 2 * s, 4 * s, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Przednie ≈Çapki (ma≈Çe)
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.ellipse(x - 15 * s, y + 38 * s, 6 * s, 10 * s, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 15 * s, y + 38 * s, 6 * s, 10 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // G≈Ç√≥wka (szeroka)
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.ellipse(x, y + 18 * s, 18 * s, 16 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Oczy (wypuk≈Çe!)
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x - 10 * s, y + 12 * s, 8 * s, 0, Math.PI * 2);
            ctx.arc(x + 10 * s, y + 12 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();

            // ≈πrenice
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(x - 10 * s, y + 13 * s, 3 * s, 5 * s, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 10 * s, y + 13 * s, 3 * s, 5 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // B≈Çyski w oczach
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 9 * s, y + 11 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(x + 11 * s, y + 11 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Buzia (szeroki u≈õmiech)
            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.arc(x, y + 22 * s, 12 * s, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // Policzki (r√≥≈ºowe)
            ctx.fillStyle = 'rgba(255, 192, 203, 0.4)';
            ctx.beginPath();
            ctx.arc(x - 16 * s, y + 20 * s, 5 * s, 0, Math.PI * 2);
            ctx.arc(x + 16 * s, y + 20 * s, 5 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie motyla (jako przyjaciel - wiƒôkszy)
        function drawButterflyFriend(x, y, scale = 1) {
            const s = scale;
            // G√≥rne skrzyd≈Ça (du≈ºe, kolorowe)
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.ellipse(x - 18 * s, y + 20 * s, 22 * s, 28 * s, -0.3, 0, Math.PI * 2);
            ctx.ellipse(x + 18 * s, y + 20 * s, 22 * s, 28 * s, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Dolne skrzyd≈Ça
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.ellipse(x - 15 * s, y + 50 * s, 18 * s, 22 * s, -0.2, 0, Math.PI * 2);
            ctx.ellipse(x + 15 * s, y + 50 * s, 18 * s, 22 * s, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Wzory na g√≥rnych skrzyd≈Çach
            ctx.fillStyle = '#FFF';
            [[x - 18 * s, y + 15 * s], [x + 18 * s, y + 15 * s]].forEach(([px, py]) => {
                ctx.beginPath();
                ctx.arc(px, py, 6 * s, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.fillStyle = '#FFD700';
            [[x - 18 * s, y + 28 * s], [x + 18 * s, y + 28 * s]].forEach(([px, py]) => {
                ctx.beginPath();
                ctx.arc(px, py, 5 * s, 0, Math.PI * 2);
                ctx.fill();
            });

            // Wzory na dolnych skrzyd≈Çach
            ctx.fillStyle = '#E0C3FC';
            [[x - 15 * s, y + 50 * s], [x + 15 * s, y + 50 * s]].forEach(([px, py]) => {
                ctx.beginPath();
                ctx.arc(px, py, 4 * s, 0, Math.PI * 2);
                ctx.fill();
            });

            // Cia≈Ço (grube, puszyste)
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - 5 * s, y + 10 * s, 10 * s, 50 * s, 0, 0, Math.PI * 2);

            // G≈Ç√≥wka
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y + 5 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();

            // Oczka
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 3 * s, y + 5 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(x + 3 * s, y + 5 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Czu≈Çki (d≈Çugie, z kulkami)
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.moveTo(x - 4 * s, y);
            ctx.lineTo(x - 10 * s, y - 15 * s);
            ctx.moveTo(x + 4 * s, y);
            ctx.lineTo(x + 10 * s, y - 15 * s);
            ctx.stroke();

            // Kulki na czu≈Çkach
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.arc(x - 10 * s, y - 15 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(x + 10 * s, y - 15 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            // B≈Çysk na skrzyd≈Çach (magiczny efekt)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            [[x - 22 * s, y + 12 * s], [x + 22 * s, y + 12 * s]].forEach(([px, py]) => {
                ctx.beginPath();
                ctx.arc(px, py, 4 * s, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Funkcja wyboru rysowania przyjaciela
        function drawFriend(friend, x, y, scale = 1) {
            ctx.save();

            switch(friend.emoji) {
                case 'üê∂':
                    drawDog(x, y, scale);
                    break;
                case 'üê∞':
                    drawRabbit(x, y, scale);
                    break;
                case 'üêª':
                    drawBear(x, y, scale);
                    break;
                case 'üêë':
                    drawSheep(x, y, scale);
                    break;
                case 'üê¨':
                    drawDolphin(x, y, scale);
                    break;
                case 'ü¶ä':
                    drawFox(x, y, scale);
                    break;
                case 'üêº':
                    drawPanda(x, y, scale);
                    break;
                case 'ü¶Ñ':
                    drawUnicorn(x, y, scale);
                    break;
                case 'üê∏':
                    drawFrog(x, y, scale);
                    break;
                case 'ü¶ã':
                    drawButterflyFriend(x, y, scale);
                    break;
                default:
                    // Dla pozosta≈Çych u≈ºyj prostego kszta≈Çtu
                    ctx.fillStyle = friend.color;
                    ctx.beginPath();
                    ctx.ellipse(x, y + 30 * scale, 18 * scale, 25 * scale, 0, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = friend.color;
                    ctx.beginPath();
                    ctx.arc(x, y + 10 * scale, 15 * scale, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(x - 5 * scale, y + 10 * scale, 2 * scale, 0, Math.PI * 2);
                    ctx.arc(x + 5 * scale, y + 10 * scale, 2 * scale, 0, Math.PI * 2);
                    ctx.fill();
            }

            ctx.restore();
        }

        // T≈Ço
        function drawBackground() {
            // Time of day cycle: 1 minute = full day cycle (0..1)
            const elapsed = (Date.now() - gameTimeStart) / 1000; // seconds
            const dayCycle = (elapsed % 60) / 60; // 0..1 over 60 seconds

            // dayCycle phases: 0-0.25 = dawn->day, 0.25-0.5 = day, 0.5-0.75 = dusk, 0.75-1.0 = night
            let skyTop, skyMid, skyBot, sunAlpha, darkness;
            if (dayCycle < 0.2) {
                // Dawn
                const t = dayCycle / 0.2;
                skyTop = lerpColor('#1a1a3e', '#87CEEB', t);
                skyMid = lerpColor('#2d1b4e', '#FFE5F1', t);
                skyBot = lerpColor('#4a2040', '#FFF4E0', t);
                sunAlpha = t;
                darkness = (1 - t) * 0.4;
            } else if (dayCycle < 0.5) {
                // Full day
                skyTop = '#87CEEB';
                skyMid = '#FFE5F1';
                skyBot = '#FFF4E0';
                sunAlpha = 1;
                darkness = 0;
            } else if (dayCycle < 0.7) {
                // Dusk
                const t = (dayCycle - 0.5) / 0.2;
                skyTop = lerpColor('#87CEEB', '#FF6B35', t);
                skyMid = lerpColor('#FFE5F1', '#FF4500', t);
                skyBot = lerpColor('#FFF4E0', '#8B0000', t);
                sunAlpha = 1 - t * 0.5;
                darkness = t * 0.15;
            } else {
                // Night
                const t = Math.min(1, (dayCycle - 0.7) / 0.15);
                skyTop = lerpColor('#FF6B35', '#0a0a2e', t);
                skyMid = lerpColor('#FF4500', '#1a1a3e', t);
                skyBot = lerpColor('#8B0000', '#1a1040', t);
                sunAlpha = Math.max(0, 0.5 - t);
                darkness = 0.15 + t * 0.35;
            }

            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, skyTop);
            gradient.addColorStop(0.6, skyMid);
            gradient.addColorStop(1, skyBot);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Stars (only at night)
            if (darkness > 0.2) {
                const starAlpha = Math.min(1, (darkness - 0.2) * 3);
                ctx.fillStyle = `rgba(255, 255, 220, ${starAlpha})`;
                for (let i = 0; i < 30; i++) {
                    // Deterministic star positions
                    const sx = ((i * 137 + 50) % canvas.width);
                    const sy = ((i * 97 + 20) % (canvas.height * 0.4));
                    const twinkle = Math.sin(elapsed * 2 + i * 0.7) * 0.3 + 0.7;
                    ctx.globalAlpha = starAlpha * twinkle;
                    ctx.beginPath();
                    ctx.arc(sx, sy, 1 + (i % 3) * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                // Moon (at night)
                if (darkness > 0.3) {
                    const moonAlpha = Math.min(1, (darkness - 0.3) * 3);
                    const moonX = canvas.width - 120 - worldOffset * 0.05;
                    ctx.globalAlpha = moonAlpha;
                    ctx.fillStyle = '#FFFDE7';
                    ctx.beginPath();
                    ctx.arc(moonX, 70, 30, 0, Math.PI * 2);
                    ctx.fill();
                    // Crescent shadow
                    ctx.fillStyle = skyTop;
                    ctx.beginPath();
                    ctx.arc(moonX + 10, 65, 25, 0, Math.PI * 2);
                    ctx.fill();
                    // Moon glow
                    const moonGlow = ctx.createRadialGradient(moonX, 70, 20, moonX, 70, 60);
                    moonGlow.addColorStop(0, `rgba(255, 253, 231, ${0.15 * moonAlpha})`);
                    moonGlow.addColorStop(1, 'rgba(255, 253, 231, 0)');
                    ctx.fillStyle = moonGlow;
                    ctx.beginPath();
                    ctx.arc(moonX, 70, 60, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            }

            // Sun (during day, fades at night)
            if (sunAlpha > 0) {
                const sunX = 200 - worldOffset * 0.1;
                // Sun position follows day arc
                const sunArc = Math.sin(dayCycle * Math.PI); // 0 at start/end, 1 at midday
                const sunY = 200 - sunArc * 120;
                if (sunX > -100 && sunX < canvas.width + 100) {
                    ctx.globalAlpha = sunAlpha * 0.6;
                    ctx.fillStyle = '#FFFF66';
                    ctx.beginPath();
                    ctx.arc(sunX, sunY, 60, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = sunAlpha;
                    ctx.fillStyle = '#FFFF00';
                    ctx.beginPath();
                    ctx.arc(sunX, sunY, 50, 0, Math.PI * 2);
                    ctx.fill();
                    // Sunset tint
                    if (dayCycle > 0.5 && dayCycle < 0.75) {
                        ctx.fillStyle = `rgba(255, 100, 0, ${(dayCycle - 0.5) * 2})`;
                        ctx.beginPath();
                        ctx.arc(sunX, sunY, 50, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }
            }

            // Rainbow
            const rainbowX = 600 - worldOffset * 0.2;
            if (rainbowX > -500 && rainbowX < canvas.width + 500) {
                const rainbowColors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
                ctx.globalAlpha = 0.5 * (1 - darkness);
                rainbowColors.forEach((color, i) => {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 12;
                    ctx.beginPath();
                    ctx.arc(rainbowX, canvas.height, 400 - i * 30, Math.PI, 0);
                    ctx.stroke();
                });
                ctx.globalAlpha = 1;
            }

            // Clouds (darker when rainy/night)
            // Rain cycle: every 3 minutes, rain for 30 seconds
            const rainCycle = elapsed % 600; // 10 minutes
            const isRaining = rainCycle > 550; // rain for last 30 seconds of cycle
            const rainIntensity = isRaining ? Math.min(1, (rainCycle - 150) / 5) : 0; // fade in over 5 seconds

            const time = Date.now() / 1000;
            const cloudCount = isRaining ? 6 : 3;
            for (let i = 0; i < cloudCount; i++) {
                const cloudBaseX = 300 + i * (isRaining ? 200 : 400);
                const cloudX = cloudBaseX + (time * 5) - (worldOffset * 0.1);
                const screenCloudX = cloudX % (canvas.width + 200);
                const cloudY = 60 + (i % 3) * 40;

                if (isRaining) {
                    // Dark rain clouds
                    ctx.fillStyle = `rgba(80, 80, 100, ${0.7 + rainIntensity * 0.2})`;
                } else {
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.8 - darkness * 0.4})`;
                }
                ctx.beginPath();
                ctx.arc(screenCloudX, cloudY, 30 + (isRaining ? 10 : 0), 0, Math.PI * 2);
                ctx.arc(screenCloudX + 35, cloudY, 40 + (isRaining ? 10 : 0), 0, Math.PI * 2);
                ctx.arc(screenCloudX + 70, cloudY, 30 + (isRaining ? 10 : 0), 0, Math.PI * 2);
                ctx.fill();
            }

            // Darkness overlay
            if (darkness > 0) {
                ctx.fillStyle = `rgba(0, 0, 20, ${darkness})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Rain overlay
            if (isRaining) {
                // Rain darkening
                ctx.fillStyle = `rgba(30, 30, 50, ${rainIntensity * 0.2})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        function lerpColor(a, b, t) {
            const ah = parseInt(a.replace('#', ''), 16);
            const bh = parseInt(b.replace('#', ''), 16);
            const ar = (ah >> 16) & 0xFF, ag = (ah >> 8) & 0xFF, ab = ah & 0xFF;
            const br = (bh >> 16) & 0xFF, bg = (bh >> 8) & 0xFF, bb = bh & 0xFF;
            const rr = Math.round(ar + (br - ar) * t);
            const rg = Math.round(ag + (bg - ag) * t);
            const rb = Math.round(ab + (bb - ab) * t);
            return `rgb(${rr},${rg},${rb})`;
        }

        function drawRain() {
            const elapsed = (Date.now() - gameTimeStart) / 1000;
            const rainCycle = elapsed % 180;
            const isRaining = rainCycle > 150;
            if (!isRaining) { raindrops = []; return; }

            const rainIntensity = Math.min(1, (rainCycle - 150) / 5);

            // Add new raindrops
            const dropsPerFrame = Math.floor(rainIntensity * 15);
            for (let i = 0; i < dropsPerFrame; i++) {
                raindrops.push({
                    x: Math.random() * (canvas.width + 100) - 50,
                    y: -10 - Math.random() * 20,
                    speed: 8 + Math.random() * 6,
                    length: 10 + Math.random() * 10,
                    opacity: 0.2 + Math.random() * 0.4
                });
            }

            // Draw and update raindrops
            ctx.strokeStyle = 'rgba(150, 180, 255, 0.5)';
            ctx.lineWidth = 1;
            for (let i = raindrops.length - 1; i >= 0; i--) {
                const drop = raindrops[i];
                ctx.globalAlpha = drop.opacity * rainIntensity;
                ctx.beginPath();
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x - 2, drop.y + drop.length);
                ctx.stroke();

                drop.y += drop.speed;
                drop.x -= 1; // slight wind

                // Splash on ground
                if (drop.y > canvas.height - 150) {
                    // Draw splash
                    ctx.fillStyle = 'rgba(150, 180, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(drop.x, canvas.height - 150, 2, 0, Math.PI * 2);
                    ctx.fill();
                    raindrops.splice(i, 1);
                }
            }
            ctx.globalAlpha = 1;

            // Limit raindrop count
            if (raindrops.length > 300) raindrops.splice(0, raindrops.length - 300);
        }

        // Drzewa
        function drawTrees() {
            trees.forEach(tree => {
                const screenX = tree.x - worldOffset;
                if (screenX < -100 || screenX > canvas.width + 100) return;

                // Pie≈Ñ
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(screenX - tree.width/4, tree.y - tree.height, tree.width/2, tree.height);

                // Korona (r√≥≈ºowa/fioletowa candy)
                const crownColors = ['#FF69B4', '#E0C3FC', '#FFB6D9'];
                crownColors.forEach((color, i) => {
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(
                        screenX + (i - 1) * tree.width/4,
                        tree.y - tree.height + 10,
                        tree.width/2,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                });
            });
        }

        // Kwiaty
        function drawFlowers() {
            const time = Date.now() / 1000;
            flowers.forEach(flower => {
                const screenX = flower.x - worldOffset;
                if (screenX < -50 || screenX > canvas.width + 50) return;

                const sway = Math.sin(time + flower.swayOffset) * 2;

                // ≈Åodyga
                ctx.strokeStyle = '#90EE90';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(screenX, flower.y);
                ctx.quadraticCurveTo(screenX + sway, flower.y - flower.size/2, screenX + sway, flower.y - flower.size);
                ctx.stroke();

                // P≈Çatki
                ctx.fillStyle = flower.color;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const px = screenX + sway + Math.cos(angle) * flower.size/3;
                    const py = flower.y - flower.size + Math.sin(angle) * flower.size/3;
                    ctx.beginPath();
                    ctx.arc(px, py, flower.size/4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ≈örodek
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(screenX + sway, flower.y - flower.size, flower.size/5, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Grunt
        function drawGround() {
            ground.forEach(g => {
                const screenX = g.x - worldOffset;
                if (screenX + g.width < -100 || screenX > canvas.width + 100) return;

                // Trawa
                const grassGradient = ctx.createLinearGradient(screenX, g.y, screenX, g.y + g.height);
                grassGradient.addColorStop(0, '#90EE90');
                grassGradient.addColorStop(1, '#228B22');
                ctx.fillStyle = grassGradient;
                ctx.fillRect(screenX, g.y, g.width, g.height);

                // Trawka (detale)
                ctx.strokeStyle = '#7FBF7F';
                ctx.lineWidth = 2;
                for (let i = 0; i < g.width; i += 20) {
                    ctx.beginPath();
                    ctx.moveTo(screenX + i, g.y);
                    ctx.lineTo(screenX + i - 2, g.y - 8);
                    ctx.moveTo(screenX + i, g.y);
                    ctx.lineTo(screenX + i + 2, g.y - 6);
                    ctx.stroke();
                }
            });
        }

        // Cukierki
        function drawCandies() {
            const time = Date.now() / 1000;
            candies.forEach(candy => {
                if (candy.collected) return;

                const screenX = candy.x - worldOffset;
                if (screenX < -50 || screenX > canvas.width + 50) return;

                const bounce = Math.sin(time * 3 + candy.x) * 3;
                const candyTypes = ['üç¨', 'üç≠', 'üç∞', 'üßÅ', 'üç©'];

                ctx.font = '25px Arial';
                ctx.fillText(candyTypes[candy.type], screenX - 12, candy.y + bounce);

                // B≈Çysk
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(screenX, candy.y + bounce - 8, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Rysowanie przedmiot√≥w do zbierania
        function drawItemsToCollect() {
            const time = Date.now() / 1000;
            itemsToCollect.forEach(item => {
                if (item.collected) return;

                const screenX = item.x - worldOffset;
                if (screenX < -70 || screenX > canvas.width + 70) return;

                const bounce = Math.sin(time * 2 + item.x) * 8;
                const y = item.y + bounce;

                // ≈öwiecƒÖca aureola
                ctx.fillStyle = '#FFD700' + '30';
                ctx.beginPath();
                ctx.arc(screenX, y, 35, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#FFD700' + '50';
                ctx.beginPath();
                ctx.arc(screenX, y, 25, 0, Math.PI * 2);
                ctx.fill();

                // Gwiazdki wok√≥≈Ç
                for (let i = 0; i < 3; i++) {
                    const angle = time * 3 + i * (Math.PI * 2 / 3);
                    const sx = screenX + Math.cos(angle) * 30;
                    const sy = y + Math.sin(angle) * 30;

                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    for (let j = 0; j < 5; j++) {
                        const starAngle = (j * 2 * Math.PI / 5) - Math.PI / 2;
                        const r = j % 2 === 0 ? 5 : 2;
                        const px = sx + Math.cos(starAngle) * r;
                        const py = sy + Math.sin(starAngle) * r;
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                // Przedmiot (emoji)
                ctx.font = '40px Arial';
                ctx.fillText(item.item.emoji, screenX - 20, y + 15);

                // Nazwa przedmiotu
                ctx.fillStyle = '#FF1493';
                ctx.font = 'bold 14px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText(item.item.name, screenX, y + 35);
                ctx.textAlign = 'left';
            });
        }

        // Przyjaciele do znalezienia
        function drawFriendsToFind() {
            const time = Date.now() / 1000;
            friendsToFind.forEach(friend => {
                if (friend.found) return;

                const screenX = friend.x - worldOffset;
                if (screenX < -100 || screenX > canvas.width + 100) return;

                const bounce = Math.sin(time * 2 + friend.bounceOffset) * 15;

                // Du≈ºa ≈õwiecƒÖca aureola
                for (let r = 80; r > 20; r -= 12) {
                    ctx.fillStyle = friend.type.color + Math.floor((1 - r/80) * 50).toString(16).padStart(2, '0');
                    ctx.beginPath();
                    ctx.arc(screenX, friend.y + bounce + 20, r, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Rysuj przyjaciela realistycznie
                ctx.save();
                drawFriend(friend.type, screenX, friend.y + bounce, 1);
                ctx.restore();

                // Gwiazdy wok√≥≈Ç (narysowane)
                for (let i = 0; i < 4; i++) {
                    const angle = time * 2 + i * Math.PI / 2;
                    const sx = screenX + Math.cos(angle) * 65;
                    const sy = friend.y + bounce + 20 + Math.sin(angle) * 65;

                    // Gwiazdka rysowana
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    for (let j = 0; j < 5; j++) {
                        const starAngle = (j * 2 * Math.PI / 5) - Math.PI / 2;
                        const r = j % 2 === 0 ? 12 : 5;
                        const px = sx + Math.cos(starAngle) * r;
                        const py = sy + Math.sin(starAngle) * r;
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                // Serduszka (narysowane)
                const drawHeart = (hx, hy) => {
                    ctx.fillStyle = '#FF69B4';
                    ctx.beginPath();
                    ctx.moveTo(hx, hy + 5);
                    ctx.bezierCurveTo(hx, hy, hx - 8, hy - 8, hx - 12, hy - 5);
                    ctx.bezierCurveTo(hx - 16, hy, hx - 16, hy + 5, hx - 16, hy + 8);
                    ctx.bezierCurveTo(hx - 16, hy + 12, hx - 12, hy + 18, hx, hy + 25);
                    ctx.bezierCurveTo(hx + 12, hy + 18, hx + 16, hy + 12, hx + 16, hy + 8);
                    ctx.bezierCurveTo(hx + 16, hy + 5, hx + 16, hy, hx + 12, hy - 5);
                    ctx.bezierCurveTo(hx + 8, hy - 8, hx, hy, hx, hy + 5);
                    ctx.fill();
                };

                drawHeart(screenX - 45, friend.y + bounce - 40);
                drawHeart(screenX + 35, friend.y + bounce - 40);
            });
        }

        // Dekoracje (motyle, ptaszki)
        function drawDecorations() {
            const time = Date.now() / 1000;
            decorations.forEach(deco => {
                const screenX = deco.x - worldOffset * 0.5 + Math.sin(time * deco.speed + deco.phase) * 50;
                const screenY = deco.y + Math.cos(time * deco.speed + deco.phase) * 30;

                if (screenX < -50 || screenX > canvas.width + 50) return;

                ctx.save();
                if (deco.type === 'butterfly') {
                    drawButterfly(screenX, screenY);
                } else {
                    drawBird(screenX, screenY);
                }
                ctx.restore();
            });
        }

        // Rysowanie pszczo≈Çy
        function drawBee(x, y) {
            // Cie≈Ñ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.beginPath();
            ctx.ellipse(x, canvas.height - 95, 12, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Skrzyd≈Ça
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.ellipse(x - 8, y - 5, 8, 12, -0.3, 0, Math.PI * 2);
            ctx.ellipse(x + 8, y - 5, 8, 12, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Cia≈Ço (paski)
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.ellipse(x, y, 10, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Czarne paski
            ctx.fillStyle = '#000';
            ctx.fillRect(x - 10, y - 5, 20, 3);
            ctx.fillRect(x - 10, y + 3, 20, 3);

            // G≈Ç√≥wka
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y - 12, 6, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 2, y - 12, 2, 0, Math.PI * 2);
            ctx.arc(x + 2, y - 12, 2, 0, Math.PI * 2);
            ctx.fill();

            // Czu≈Çki
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x - 3, y - 16);
            ctx.lineTo(x - 6, y - 20);
            ctx.moveTo(x + 3, y - 16);
            ctx.lineTo(x + 6, y - 20);
            ctx.stroke();
        }

        // Rysowanie biedronki
        function drawLadybug(x, y) {
            // Cie≈Ñ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.beginPath();
            ctx.ellipse(x, canvas.height - 95, 10, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Cia≈Ço
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.ellipse(x, y, 12, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Linia ≈õrodkowa
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y - 15);
            ctx.lineTo(x, y + 15);
            ctx.stroke();

            // Kropki
            ctx.fillStyle = '#000';
            const dots = [[-4, -5], [4, -5], [-5, 3], [5, 3], [-3, 10], [3, 10]];
            dots.forEach(([dx, dy]) => {
                ctx.beginPath();
                ctx.arc(x + dx, y + dy, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // G≈Ç√≥wka
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y - 18, 5, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(x - 2, y - 18, 1.5, 0, Math.PI * 2);
            ctx.arc(x + 2, y - 18, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie ptaka
        function drawBird(x, y) {
            // Cie≈Ñ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.beginPath();
            ctx.ellipse(x, canvas.height - 95, 15, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Skrzyd≈Ça
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.ellipse(x - 12, y, 15, 8, -0.5, 0, Math.PI * 2);
            ctx.ellipse(x + 12, y, 15, 8, 0.5, 0, Math.PI * 2);
            ctx.fill();

            // Cia≈Ço
            ctx.fillStyle = '#ADD8E6';
            ctx.beginPath();
            ctx.ellipse(x, y, 12, 18, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek
            ctx.fillStyle = '#E6F3FF';
            ctx.beginPath();
            ctx.ellipse(x, y + 5, 8, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // G≈Ç√≥wka
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.arc(x, y - 15, 8, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 3, y - 15, 2, 0, Math.PI * 2);
            ctx.arc(x + 3, y - 15, 2, 0, Math.PI * 2);
            ctx.fill();

            // Dzi√≥b
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.moveTo(x, y - 13);
            ctx.lineTo(x - 2, y - 10);
            ctx.lineTo(x + 2, y - 10);
            ctx.fill();

            // Ogon
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.moveTo(x, y + 18);
            ctx.lineTo(x - 8, y + 25);
            ctx.lineTo(x + 8, y + 25);
            ctx.fill();
        }

        // Rysowanie motyla
        function drawButterfly(x, y) {
            // Cie≈Ñ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.beginPath();
            ctx.ellipse(x, canvas.height - 95, 12, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // G√≥rne skrzyd≈Ça
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.ellipse(x - 10, y - 8, 12, 15, -0.4, 0, Math.PI * 2);
            ctx.ellipse(x + 10, y - 8, 12, 15, 0.4, 0, Math.PI * 2);
            ctx.fill();

            // Dolne skrzyd≈Ça
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.ellipse(x - 8, y + 8, 10, 12, -0.3, 0, Math.PI * 2);
            ctx.ellipse(x + 8, y + 8, 10, 12, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Wzory na skrzyd≈Çach
            ctx.fillStyle = '#FFF';
            [[x - 10, y - 8], [x + 10, y - 8], [x - 8, y + 8], [x + 8, y + 8]].forEach(([px, py]) => {
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // Cia≈Ço
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - 2, y - 15, 4, 30);

            // G≈Ç√≥wka
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y - 17, 3, 0, Math.PI * 2);
            ctx.fill();

            // Czu≈Çki
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x - 2, y - 18);
            ctx.lineTo(x - 5, y - 22);
            ctx.moveTo(x + 2, y - 18);
            ctx.lineTo(x + 5, y - 22);
            ctx.stroke();

            // Kulki na czu≈Çkach
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 5, y - 22, 1.5, 0, Math.PI * 2);
            ctx.arc(x + 5, y - 22, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie wiewi√≥rki
        function drawSquirrel(x, y) {
            // Puszysty ogon
            ctx.fillStyle = '#D2691E';
            ctx.beginPath();
            ctx.arc(x - 15, y - 20, 18, 0, Math.PI * 2);
            ctx.fill();

            // Cia≈Ço
            ctx.fillStyle = '#CD853F';
            ctx.beginPath();
            ctx.ellipse(x, y, 12, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Brzuszek
            ctx.fillStyle = '#F4A460';
            ctx.beginPath();
            ctx.ellipse(x, y + 3, 8, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // G≈Ç√≥wka
            ctx.fillStyle = '#CD853F';
            ctx.beginPath();
            ctx.arc(x, y - 12, 8, 0, Math.PI * 2);
            ctx.fill();

            // Uszy
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.moveTo(x - 5, y - 16);
            ctx.lineTo(x - 7, y - 22);
            ctx.lineTo(x - 3, y - 18);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x + 5, y - 16);
            ctx.lineTo(x + 7, y - 22);
            ctx.lineTo(x + 3, y - 18);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 3, y - 12, 2, 0, Math.PI * 2);
            ctx.arc(x + 3, y - 12, 2, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(x, y - 9, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // ≈Åapki
            ctx.fillStyle = '#CD853F';
            ctx.beginPath();
            ctx.ellipse(x - 8, y + 12, 4, 6, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 8, y + 12, 4, 6, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // Rysowanie myszki
        function drawMouse(x, y) {
            // Ogon
            ctx.strokeStyle = '#FFB6D9';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + 10, y);
            ctx.quadraticCurveTo(x + 20, y - 5, x + 25, y + 5);
            ctx.stroke();

            // Cia≈Ço
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.ellipse(x, y, 10, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // G≈Ç√≥wka
            ctx.fillStyle = '#FFB6D9';
            ctx.beginPath();
            ctx.arc(x - 8, y - 5, 7, 0, Math.PI * 2);
            ctx.fill();

            // Uszy
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.arc(x - 10, y - 10, 5, 0, Math.PI * 2);
            ctx.arc(x - 6, y - 10, 5, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 10, y - 5, 2, 0, Math.PI * 2);
            ctx.fill();

            // Nosek
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.arc(x - 12, y - 3, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // WƒÖsy
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x - 12, y - 3);
            ctx.lineTo(x - 18, y - 5);
            ctx.moveTo(x - 12, y - 3);
            ctx.lineTo(x - 18, y - 1);
            ctx.stroke();
        }

        // Rysowanie ≈º√≥≈Çwia
        function drawTurtle(x, y) {
            // Skorupa
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.ellipse(x, y - 5, 15, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Wz√≥r na skorupie
            ctx.strokeStyle = '#006400';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - 10, y - 5);
            ctx.lineTo(x + 10, y - 5);
            ctx.moveTo(x, y - 15);
            ctx.lineTo(x - 7, y);
            ctx.moveTo(x, y - 15);
            ctx.lineTo(x + 7, y);
            ctx.stroke();

            // G≈Ç√≥wka
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.arc(x - 12, y - 3, 5, 0, Math.PI * 2);
            ctx.fill();

            // Oczy
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 13, y - 4, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // ≈Åapki
            ctx.fillStyle = '#90EE90';
            ctx.beginPath();
            ctx.ellipse(x - 10, y + 5, 4, 3, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 10, y + 5, 4, 3, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // Zwierzƒôta mijajƒÖce
        function drawPassingAnimals() {
            const time = Date.now() / 1000;
            passingAnimals.forEach(animal => {
                const screenX = animal.x - worldOffset;
                if (screenX < -100 || screenX > canvas.width + 100) return;

                let displayY = animal.y;

                // Animacja latania (ko≈Çysanie)
                if (animal.flying) {
                    displayY += Math.sin(time * 2 + animal.phase) * 10;
                }

                ctx.save();

                // Odbicie lustrzane gdy idzie w lewo
                if (animal.direction < 0 && !animal.flying) {
                    ctx.translate(screenX, displayY);
                    ctx.scale(-1, 1);
                    ctx.translate(-screenX, -displayY);
                }

                // Rysuj odpowiednie zwierzƒô
                switch(animal.emoji) {
                    case 'üêù':
                        drawBee(screenX, displayY);
                        break;
                    case 'üêû':
                        drawLadybug(screenX, displayY);
                        break;
                    case 'üïäÔ∏è':
                    case 'ü¶Ö':
                    case 'üê¶':
                        drawBird(screenX, displayY);
                        break;
                    case 'ü¶ã':
                        drawButterfly(screenX, displayY);
                        break;
                    case 'üêøÔ∏è':
                        drawSquirrel(screenX, displayY);
                        break;
                    case 'üêÅ':
                        drawMouse(screenX, displayY);
                        break;
                    case 'üê¢':
                        drawTurtle(screenX, displayY);
                        break;
                }

                ctx.restore();
            });
        }

        // Aktualizacja zwierzƒÖt mijajƒÖcych
        function updatePassingAnimals() {
            passingAnimals.forEach(animal => {
                animal.x += animal.speed * animal.direction;

                // Odbicie od granic
                if (animal.x <= animal.minX || animal.x >= animal.maxX) {
                    animal.direction *= -1;
                }
            });
        }

        // Parada przyjaci√≥≈Ç
        function drawFollowingFriends() {
            followingFriends.forEach((friend, index) => {
                if (friend.historyIndex < playerHistory.length) {
                    const pos = playerHistory[friend.historyIndex];
                    if (pos) {
                        drawFriend(friend.type, pos.x - worldOffset - 30, pos.y - 10, 0.9);
                    }
                }
            });
        }

        // Update
        function updatePlayer() {
            // Update slide animation
            if (slideState.active && slideState.sliding) {
                slideState.slideProgress += 0.025;
                if (slideState.slideProgress >= 1) {
                    // Finished sliding - return to normal
                    slideState.active = false;
                    slideState.sliding = false;
                    slideState.slideProgress = 0;
                    slideState.climbStep = 0;
                    // Position player at bottom of slide
                    houses.forEach(house => {
                        if (Math.abs(slideState.slideHouseX - house.x) < 10) {
                            player.x = house.x + house.width + 80 + 35 + 100 + 30;
                        }
                    });
                }
                return; // Don't move while on slide
            }
            if (slideState.active) return; // Climbing - don't move

            let moving = false;

            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                player.x -= player.speed;
                player.facingRight = false;
                moving = true;
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                player.x += player.speed;
                player.facingRight = true;
                moving = true;
            }

            // Opcjonalne skakanie
            if ((keys[' '] || keys['ArrowUp'] || keys['w'] || keys['W']) && !player.jumping) {
                player.velY = player.jumpPower;
                player.jumping = true;
            }

            // Grawitacja (≈Çagodna)
            if (player.jumping) {
                player.velY += player.gravity;
                player.y += player.velY;

                // LƒÖdowanie
                const groundY = canvas.height - 150;
                if (player.y >= groundY) {
                    player.y = groundY;
                    player.velY = 0;
                    player.jumping = false;
                }
            }

            // Animacja chodzenia + licznik krok√≥w
            if (moving) {
                player.walkCycle += 0.2;
                catStepCounter++;
                if (catStepCounter % 50 === 0) {
                    // Co 50 krok√≥w rosnƒÖ potrzeby
                    catNeeds.hunger = Math.min(100, catNeeds.hunger + 8);
                    catNeeds.sleep = Math.min(100, catNeeds.sleep + 5);
                    catNeeds.toilet = Math.min(100, catNeeds.toilet + 10);
                    catNeeds.hygiene = Math.min(100, catNeeds.hygiene + 6);
                }
            }

            // Kamera
            const targetOffset = player.x - canvas.width / 3;
            worldOffset += (targetOffset - worldOffset) * 0.08;

            // Generuj chunki
            const currentChunk = Math.floor(player.x / chunkSize);
            for (let i = currentChunk - 1; i <= currentChunk + 2; i++) {
                generateChunk(i);
            }

            // Historia
            playerHistory.unshift({ x: player.x, y: player.y });
            if (playerHistory.length > historyLength * (followingFriends.length + 2)) {
                playerHistory.pop();
            }

            // Pozycja
            if (player.x > furthestPosition) {
                furthestPosition = player.x;
                document.getElementById('position').textContent = Math.floor(furthestPosition / 100);
            }

            // Nastr√≥j
            const moods = ['Miau! üò∫', 'Mrrr üíï', 'Purr~ ‚ú®', 'Miuu üåà'];
            if (animationFrame % 180 === 0) {
                document.getElementById('mood').textContent = moods[Math.floor(Math.random() * moods.length)];
            }
        }

        // Zbieranie
        function checkCollectibles() {
            candies.forEach(candy => {
                if (!candy.collected &&
                    Math.abs(player.x - candy.x) < 40 &&
                    Math.abs(player.y - candy.y) < 50) {
                    candy.collected = true;
                    score++;
                    document.getElementById('score').textContent = score;
                }
            });

            // Zbieranie przedmiot√≥w (ubranka, rogi, akcesoria)
            itemsToCollect.forEach(item => {
                if (!item.collected &&
                    Math.abs(player.x - item.x) < 50 &&
                    Math.abs(player.y - item.y) < 60) {
                    item.collected = true;

                    // Dodaj do kolekcji
                    if (item.type === 'horn') {
                        if (!collectedItems.horns.includes(item.item.id)) {
                            collectedItems.horns.push(item.item.id);
                        }
                    } else if (item.type === 'outfit') {
                        if (!collectedItems.outfits.includes(item.item.id)) {
                            collectedItems.outfits.push(item.item.id);
                        }
                    } else if (item.type === 'accessory') {
                        if (!collectedItems.accessories.includes(item.item.id)) {
                            collectedItems.accessories.push(item.item.id);
                        }
                    } else if (item.type === 'color') {
                        if (!collectedItems.colors.includes(item.item.id)) {
                            collectedItems.colors.push(item.item.id);
                        }
                    }

                    updateWardrobe();

                    // Chmurka z wiadomo≈õciƒÖ
                    dialogBubbles.push({
                        x: player.x,
                        y: player.y,
                        text: `Znalaz≈Çem ${item.item.name}! ‚ú®`,
                        fromLeft: true,
                        startTime: Date.now(),
                        duration: 2500
                    });
                }
            });

            // Check house door collision (SPACJA to enter) and slide
            let enteredHouse = false;
            houses.forEach(house => {
                // Slide interaction
                const slideInteractX = house.x + house.width + 87;
                const slideDist = Math.abs(player.x - slideInteractX);
                if (slideDist < 60 && keys[' '] && !slideState.active && !enteredHouse) {
                    slideState.active = true;
                    slideState.climbStep = 0;
                    slideState.sliding = false;
                    slideState.slideProgress = 0;
                    slideState.slideHouseX = house.x;
                    keys[' '] = false; // Consume key
                    enteredHouse = true;
                    return;
                }

                const houseDoorX = house.x + 125;
                const horizontalDistance = Math.abs(player.x - houseDoorX);

                if (horizontalDistance < 150 && keys[' '] && !enteredHouse && !slideState.active) {
                    enterHouse();
                    enteredHouse = true;
                }
            });

            // Check hycel collision (only if didn't enter house)
            if (!enteredHouse) {
                hycels.forEach(hycel => {
                    if (!hycel.defeated) {
                        const distance = Math.sqrt(
                            Math.pow(player.x - hycel.x, 2) +
                            Math.pow(player.y - hycel.y, 2)
                        );

                        if (distance < 150 && keys[' ']) {
                            startBattle(hycel);
                        }
                    }
                });
            }

            friendsToFind.forEach(friend => {
                if (!friend.found &&
                    Math.abs(player.x - friend.x) < 70 &&
                    Math.abs(player.y - friend.y) < 70) {

                    // Check if friend has an active hycel guarding them
                    if (friend.hasHycel) {
                        const friendHycel = hycels.find(h => h.friendIndex === friendsToFind.indexOf(friend));
                        if (friendHycel && !friendHycel.defeated) {
                            // Show friend's cry for help
                            dialogBubbles.push({
                                x: friend.x,
                                y: friend.y,
                                text: 'üò± Hycel mnie strze≈ºe! Pom√≥≈º mi!',
                                fromLeft: false,
                                startTime: Date.now(),
                                duration: 2500
                            });
                            return; // Don't collect friend yet
                        }
                    }

                    friend.found = true;

                    // Dodaj chmurki dialogowe (r√≥≈ºnorodne rozmowy!)
                    const conversations = [
                        ['Piƒôkny dzie≈Ñ, prawda? üåû', 'O tak! Idealna pogoda!'],
                        ['Widzia≈Çe≈õ te chmurki? ‚òÅÔ∏è', 'Tak! Takie puszyste!'],
                        ['Uwielbiam cukierki! üç¨', 'Ja te≈º! SƒÖ przepyszne!'],
                        ['DokƒÖd idziesz? üó∫Ô∏è', 'Na przygodƒô! Idziesz?'],
                        ['Co za piƒôkna tƒôcza! üåà', 'Magiczna, prawda?'],
                        ['Hej! Zgubi≈Çe≈õ siƒô? üíï', 'Nie! Zwiedzam ≈õwiat!'],
                        ['≈Åadny masz r√≥g! ‚ú®', 'Dziƒôkujƒô! Jeste≈õ super!'],
                        ['Trawa jest taka zielona! üå±', 'I kwiaty ≈õliczne!'],
                        ['S≈Çyszysz ptaki? üê¶', 'Tak! ≈öpiewajƒÖ piƒôknie!'],
                        ['Witaj przyjacielu! üíñ', 'Witaj! Idƒô z TobƒÖ!'],
                        ['Lubisz przygody? üéí', 'Uwielbiam! Chod≈∫my!'],
                        ['Jestem trochƒô g≈Çodny... üç∞', 'Poszukajmy cukierk√≥w!'],
                        ['Wieje dzi≈õ wiatr! üí®', 'Ale przyjemnie!'],
                        ['S≈Ço≈Ñce tak grzeje! ‚òÄÔ∏è', 'Cudownie ciep≈Ço!'],
                        ['Co tam za g√≥rkƒÖ? üèîÔ∏è', 'Sprawd≈∫my razem!'],
                        ['Nie boisz siƒô? üòä', 'Z TobƒÖ siƒô nie bojƒô!'],
                        ['Miau! Hej tam! üò∫', 'Cze≈õƒá kiciusiu!'],
                        ['To bƒôdzie super! üéâ', 'Najlepsza przygoda!'],
                        ['Gdzie sƒÖ inni? üë•', 'Razem ich znajdziemy!'],
                        ['Jest tak kolorowo! üé®', 'Jak w bajce!']
                    ];
                    const randomConversation = conversations[Math.floor(Math.random() * conversations.length)];

                    // Mapowanie emoji na typy d≈∫wiƒôk√≥w
                    const soundMap = {
                        'üê∂': 'dog',
                        'üê∞': 'rabbit',
                        'üêª': 'bear',
                        'üêë': 'sheep',
                        'üê¨': 'dolphin',
                        'ü¶ä': 'fox',
                        'üêº': 'panda',
                        'ü¶Ñ': 'unicorn',
                        'üê∏': 'frog',
                        'ü¶ã': 'butterfly'
                    };

                    // Chmurka Kicioro≈ºka
                    playAnimalSound('cat'); // Miauczenie!
                    dialogBubbles.push({
                        x: player.x,
                        y: player.y,
                        text: randomConversation[0],
                        fromLeft: true,
                        startTime: Date.now(),
                        duration: 3500
                    });

                    // Chmurka przyjaciela (pojawia siƒô po chwili)
                    setTimeout(() => {
                        const friendSoundType = soundMap[friend.type.emoji] || 'dog';
                        playAnimalSound(friendSoundType); // D≈∫wiƒôk przyjaciela!
                        dialogBubbles.push({
                            x: friend.x,
                            y: friend.y,
                            text: randomConversation[1],
                            fromLeft: false,
                            startTime: Date.now(),
                            duration: 3500
                        });
                    }, 1000);

                    followingFriends.push({
                        type: friend.type,
                        historyIndex: historyLength * followingFriends.length + historyLength
                    });

                    updateFriendsList();
                }
            });
        }

        function updateFriendsList() {
            const list = document.getElementById('friends-list');
            if (followingFriends.length === 0) {
                list.textContent = '(czeka na przyjaci√≥≈Ç)';
            } else {
                list.innerHTML = followingFriends.map(f => f.type.emoji).join(' ') +
                    `<br><small style="font-size: 0.7em;">${followingFriends.length}</small>`;
            }
        }

        // Aktualizacja garderoby
        function updateWardrobe() {
            // Rogi
            const hornItems = document.getElementById('horn-items');
            hornItems.innerHTML = '';
            collectedItems.horns.forEach(hornId => {
                const horn = itemDefinitions.horns.find(h => h.id === hornId);
                const div = document.createElement('div');
                div.className = 'wardrobe-item' + (player.equippedHorn === hornId ? ' equipped' : '');
                div.textContent = horn.emoji;
                div.title = horn.name;
                div.onclick = () => equipItem('horn', hornId);
                hornItems.appendChild(div);
            });

            // Ubranka
            const outfitItems = document.getElementById('outfit-items');
            outfitItems.innerHTML = '';
            // Opcja "Bez ubranka"
            const noneOutfit = document.createElement('div');
            noneOutfit.className = 'wardrobe-item' + (player.equippedOutfit === null ? ' equipped' : '');
            noneOutfit.textContent = 'üö´';
            noneOutfit.title = 'Bez ubranka';
            noneOutfit.onclick = () => equipItem('outfit', null);
            outfitItems.appendChild(noneOutfit);

            collectedItems.outfits.forEach(outfitId => {
                const outfit = itemDefinitions.outfits.find(o => o.id === outfitId);
                const div = document.createElement('div');
                div.className = 'wardrobe-item' + (player.equippedOutfit === outfitId ? ' equipped' : '');
                div.textContent = outfit.emoji;
                div.title = outfit.name;
                div.onclick = () => equipItem('outfit', outfitId);
                outfitItems.appendChild(div);
            });

            // Akcesoria
            const accessoryItems = document.getElementById('accessory-items');
            accessoryItems.innerHTML = '';
            // Opcja "Bez akcesorium"
            const noneAccessory = document.createElement('div');
            noneAccessory.className = 'wardrobe-item' + (player.equippedAccessory === null ? ' equipped' : '');
            noneAccessory.textContent = 'üö´';
            noneAccessory.title = 'Bez akcesorium';
            noneAccessory.onclick = () => equipItem('accessory', null);
            accessoryItems.appendChild(noneAccessory);

            collectedItems.accessories.forEach(accessoryId => {
                const accessory = itemDefinitions.accessories.find(a => a.id === accessoryId);
                const div = document.createElement('div');
                div.className = 'wardrobe-item' + (player.equippedAccessory === accessoryId ? ' equipped' : '');
                div.textContent = accessory.emoji;
                div.title = accessory.name;
                div.onclick = () => equipItem('accessory', accessoryId);
                accessoryItems.appendChild(div);
            });

            // Kolory
            const colorItems = document.getElementById('color-items');
            colorItems.innerHTML = '';
            collectedItems.colors.forEach(colorId => {
                const colorDef = itemDefinitions.colors.find(c => c.id === colorId);
                const div = document.createElement('div');
                div.className = 'wardrobe-item' + (player.equippedColor === colorId ? ' equipped' : '');
                div.textContent = colorDef.emoji;
                div.title = colorDef.name;
                div.style.backgroundColor = colorDef.bodyColor;
                div.onclick = () => equipItem('color', colorId);
                colorItems.appendChild(div);
            });
        }

        // Zak≈Çadanie przedmiotu
        function equipItem(type, itemId) {
            if (type === 'horn') {
                player.equippedHorn = itemId;
            } else if (type === 'outfit') {
                player.equippedOutfit = itemId;
            } else if (type === 'accessory') {
                player.equippedAccessory = itemId;
            } else if (type === 'color') {
                player.equippedColor = itemId;
            }
            updateWardrobe();
        }

        // ========== HOUSE SYSTEM ==========

        function drawHouses() {
            const groundY = canvas.height - 100;

            houses.forEach(house => {
                const screenX = house.x - worldOffset;
                const screenY = groundY - house.height; // On ground level

                if (screenX < -300 || screenX > canvas.width + 100) return;

                ctx.save();

            // House body (light blue)
            ctx.fillStyle = '#ADD8E6';
            ctx.fillRect(screenX, screenY, house.width, house.height);

            // Roof (rainbow gradient)
            const roofGradient = ctx.createLinearGradient(screenX, screenY - 80, screenX + house.width, screenY);
            roofGradient.addColorStop(0, '#FF0000');
            roofGradient.addColorStop(0.2, '#FF7F00');
            roofGradient.addColorStop(0.4, '#FFFF00');
            roofGradient.addColorStop(0.6, '#00FF00');
            roofGradient.addColorStop(0.8, '#0000FF');
            roofGradient.addColorStop(1, '#8B00FF');
            ctx.fillStyle = roofGradient;
            ctx.beginPath();
            ctx.moveTo(screenX - 30, screenY);
            ctx.lineTo(screenX + house.width / 2, screenY - 80);
            ctx.lineTo(screenX + house.width + 30, screenY);
            ctx.closePath();
            ctx.fill();

            // Windows
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(screenX + 40, screenY + 50, 50, 50);
            ctx.fillRect(screenX + 160, screenY + 50, 50, 50);

            // Window crosses (purple)
            ctx.strokeStyle = '#8B00FF';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(screenX + 65, screenY + 50);
            ctx.lineTo(screenX + 65, screenY + 100);
            ctx.moveTo(screenX + 40, screenY + 75);
            ctx.lineTo(screenX + 90, screenY + 75);
            ctx.moveTo(screenX + 185, screenY + 50);
            ctx.lineTo(screenX + 185, screenY + 100);
            ctx.moveTo(screenX + 160, screenY + 75);
            ctx.lineTo(screenX + 210, screenY + 75);
            ctx.stroke();

            // Door (purple)
            ctx.fillStyle = '#8B00FF';
            ctx.fillRect(screenX + 95, screenY + 120, 60, 80);

            // Door knob (gold)
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(screenX + 135, screenY + 160, 5, 0, Math.PI * 2);
            ctx.fill();

            // ===== SLIDE behind the house =====
            const slideX = screenX + house.width + 80; // Right side of house, well separated
            const slideTopY = screenY + 20; // Top of slide platform
            const slideBottomY = groundY; // Bottom of slide
            const slideW = 100; // Horizontal length of slide
            const slideH = slideBottomY - slideTopY;
            const platformW = 35;
            const platformH = slideH;

            // Ladder (vertical, left side)
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 4;
            // Left rail
            ctx.beginPath();
            ctx.moveTo(slideX, slideBottomY);
            ctx.lineTo(slideX, slideTopY);
            ctx.stroke();
            // Right rail
            ctx.beginPath();
            ctx.moveTo(slideX + 15, slideBottomY);
            ctx.lineTo(slideX + 15, slideTopY);
            ctx.stroke();
            // Rungs
            ctx.lineWidth = 3;
            const rungCount = 6;
            for (let r = 0; r < rungCount; r++) {
                const ry = slideTopY + (slideH / rungCount) * (r + 0.5);
                ctx.beginPath();
                ctx.moveTo(slideX, ry);
                ctx.lineTo(slideX + 15, ry);
                ctx.stroke();
            }

            // Platform at top
            ctx.fillStyle = '#A0522D';
            ctx.fillRect(slideX - 5, slideTopY - 5, platformW + 10, 8);
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(slideX - 5, slideTopY - 5, platformW + 10, 3);

            // Slide surface (diagonal from platform to ground)
            const slideStartX = slideX + platformW;
            const slideEndX = slideStartX + slideW;
            ctx.fillStyle = '#FF6B6B';
            ctx.beginPath();
            ctx.moveTo(slideStartX, slideTopY);
            ctx.lineTo(slideEndX + 15, slideBottomY - 5);
            ctx.lineTo(slideEndX + 15, slideBottomY);
            ctx.lineTo(slideStartX, slideTopY + 5);
            ctx.closePath();
            ctx.fill();
            // Slide edge highlight
            ctx.strokeStyle = '#FF4444';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(slideStartX, slideTopY);
            ctx.lineTo(slideEndX + 15, slideBottomY - 5);
            ctx.stroke();
            // Slide rails
            ctx.strokeStyle = '#CC3333';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(slideStartX - 2, slideTopY - 5);
            ctx.lineTo(slideEndX + 13, slideBottomY - 10);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(slideStartX, slideTopY + 8);
            ctx.lineTo(slideEndX + 17, slideBottomY + 3);
            ctx.stroke();

            // Bottom curve
            ctx.strokeStyle = '#FF4444';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(slideEndX + 15, slideBottomY - 5);
            ctx.quadraticCurveTo(slideEndX + 25, slideBottomY + 5, slideEndX + 30, slideBottomY);
            ctx.stroke();

            // Draw player on slide if active for this house
            if (slideState.active && Math.abs(slideState.slideHouseX - house.x) < 10) {
                let playerSlideX, playerSlideY;
                if (!slideState.sliding) {
                    // Climbing ladder
                    const climbProgress = slideState.climbStep / 3;
                    playerSlideX = slideX + 7;
                    playerSlideY = slideBottomY - climbProgress * slideH - 40;
                } else {
                    // Sliding down
                    const t = slideState.slideProgress;
                    playerSlideX = slideStartX + t * slideW;
                    playerSlideY = slideTopY + t * (slideBottomY - slideTopY) - 40;
                }
                drawPlayer(playerSlideX - 30, playerSlideY);
            }

            // Slide hint
            const slideInteractX = house.x + house.width + 87; // World coords
            const slideDistance = Math.abs(player.x - slideInteractX);
            if (slideDistance < 60 && !slideState.active) {
                const hintText2 = 'SPACJA - Wejd≈∫ na zje≈ºd≈ºalniƒô!';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.font = 'bold 14px Comic Sans MS';
                ctx.textAlign = 'center';
                const hw2 = ctx.measureText(hintText2).width + 20;
                ctx.fillRect(slideX + platformW / 2 - hw2 / 2, slideTopY - 45, hw2, 28);
                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 2;
                ctx.strokeRect(slideX + platformW / 2 - hw2 / 2, slideTopY - 45, hw2, 28);
                ctx.fillStyle = '#FF4444';
                ctx.fillText(hintText2, slideX + platformW / 2, slideTopY - 26);
            }

            // Show climb progress if on ladder
            if (slideState.active && !slideState.sliding && Math.abs(slideState.slideHouseX - house.x) < 10) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.font = 'bold 14px Comic Sans MS';
                ctx.textAlign = 'center';
                const climbText = slideState.climbStep < 3 ? `SPACJA - Wspinaj siƒô! (${slideState.climbStep}/3)` : 'SPACJA - Zje≈ºd≈ºaj!';
                const hw3 = ctx.measureText(climbText).width + 20;
                ctx.fillRect(slideX + platformW / 2 - hw3 / 2, slideTopY - 45, hw3, 28);
                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 2;
                ctx.strokeRect(slideX + platformW / 2 - hw3 / 2, slideTopY - 45, hw3, 28);
                ctx.fillStyle = '#FF4444';
                ctx.fillText(climbText, slideX + platformW / 2, slideTopY - 26);
            }

            // Show hint when player is near house door
            const houseDoorX = house.x + 125; // Center of house
            const horizontalDistance = Math.abs(player.x - houseDoorX);

            if (horizontalDistance < 200 && !slideState.active) {
                let hintText = '';
                let hintColor = '';

                hintText = 'SPACJA - Wejd≈∫ do domku!';
                hintColor = '#00FF00';

                // Hint bubble
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.strokeStyle = hintColor;
                ctx.lineWidth = 3;
                const hintWidth = ctx.measureText(hintText).width + 40;
                ctx.fillRect(screenX + (house.width - hintWidth) / 2, screenY - 80, hintWidth, 40);
                ctx.strokeRect(screenX + (house.width - hintWidth) / 2, screenY - 80, hintWidth, 40);

                ctx.fillStyle = hintColor;
                ctx.font = 'bold 18px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText(hintText, screenX + house.width / 2, screenY - 55);
                }

                ctx.restore();
            });
        }

        let houseCooldown = 0; // Prevent instant exit after entering

        function enterHouse() {
            if (houseCooldown > 0) return;

            previousState = gameState;
            gameState = 'interior';
            houseCooldown = 30;

            // Reset interior player and camera
            interiorPlayer.x = 200;
            interiorPlayer.y = canvas.height - 200;
            interiorPlayer.action = 'none';
            interiorPlayer.actionTimer = 0;
            interiorPlayer.actionObject = null;
            interiorLightLevel = 1.0;
            interiorOffset = 0;

            // Generate procedural furniture if first time or empty
            if (interiorObjects.length === 0) {
                interiorObjects = [];

                // Exit door at start (x=100)
                interiorObjects.push({ type: 'door', x: 100 });

                // Generate furniture proceduralnie co ~300-500px
                let furnitureX = 300;
                const furnitureTypes = ['bed', 'toilet', 'sink', 'food', 'toy_ball', 'toy_mouse', 'toy_yarn'];

                for (let i = 0; i < 50; i++) { // Generate 50 furniture items
                    const randType = furnitureTypes[Math.floor(Math.random() * furnitureTypes.length)];
                    interiorObjects.push({
                        type: randType,
                        x: furnitureX,
                        variant: Math.floor(Math.random() * 3) // For variety in toys
                    });
                    furnitureX += 250 + Math.random() * 300;
                }
            }

            // Add current following friends to interior (they stay there!)
            followingFriends.forEach(f => {
                // Don't duplicate if already in interior
                const alreadyInside = interiorFriends.some(
                    inf => inf.type.emoji === f.type.emoji
                );
                if (!alreadyInside) {
                    interiorFriends.push({
                        type: f.type,
                        x: 100 + Math.random() * (canvas.width - 200),
                        y: canvas.height - 200,
                        velX: (Math.random() - 0.5) * 3,
                        velY: 0,
                        activity: 'walking',
                        activityTimer: 100 + Math.floor(Math.random() * 100),
                        jumpPower: 0,
                        animFrame: 0,
                        furnitureTarget: null,
                        targetActivity: null,
                        walkTargetX: 0
                    });
                }
            });

            // Friends stay in the house - remove from parade
            followingFriends = [];
            updateFriendsList();

            interiorAnimationFrame = 0;
        }

        function exitHouse() {
            if (houseCooldown > 0) return;
            gameState = 'world';
            houseCooldown = 30;
            // Reset bathtub water
            interiorPlayer.bathtubWaterLevel = 0;
            // interiorFriends stay! They live here now.
        }

        function drawInterior() {
            interiorAnimationFrame++;
            const floorY = canvas.height - 180;

            // ===== WALLS =====
            // Warm cream wall with subtle texture
            const wallGrad = ctx.createLinearGradient(0, 0, 0, floorY);
            wallGrad.addColorStop(0, '#FFF5E6');
            wallGrad.addColorStop(1, '#FFECD2');
            ctx.fillStyle = wallGrad;
            ctx.fillRect(0, 0, canvas.width, floorY);

            // Subtle wallpaper stripes
            ctx.globalAlpha = 0.06;
            ctx.fillStyle = '#D4A574';
            for (let x = 0; x < canvas.width; x += 40) {
                ctx.fillRect(x, 0, 18, floorY);
            }
            ctx.globalAlpha = 1;

            // Baseboard / skirting board
            ctx.fillStyle = '#F5F5F5';
            ctx.fillRect(0, floorY - 15, canvas.width, 15);
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, floorY - 15, canvas.width, 15);

            // ===== FLOOR =====
            // Warm wooden floor
            const floorGrad = ctx.createLinearGradient(0, floorY, 0, canvas.height);
            floorGrad.addColorStop(0, '#C4935A');
            floorGrad.addColorStop(0.5, '#B8864E');
            floorGrad.addColorStop(1, '#A67842');
            ctx.fillStyle = floorGrad;
            ctx.fillRect(0, floorY, canvas.width, canvas.height - floorY);

            // Floor plank lines
            ctx.strokeStyle = 'rgba(101, 67, 33, 0.3)';
            ctx.lineWidth = 1;
            for (let y = floorY; y < canvas.height; y += 25) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            // Vertical plank separators
            for (let x = 0; x < canvas.width; x += 80) {
                const offset = ((x / 80) % 2) * 12;
                for (let y = floorY + offset; y < canvas.height; y += 50) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, y + 25);
                    ctx.stroke();
                }
            }

            // Wood grain details (scrolling with camera)
            ctx.strokeStyle = 'rgba(101, 67, 33, 0.08)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 40; i++) {
                const gx = ((i * 73 + 20 - interiorOffset * 0.5) % (canvas.width + 100)) - 50;
                const gy = floorY + (i * 31 + 5) % (canvas.height - floorY);
                ctx.beginPath();
                ctx.ellipse(gx, gy, 15 + (i % 3) * 5, 2, 0, 0, Math.PI * 2);
                ctx.stroke();
            }

            // ===== COZY RUG (center) =====
            const rugCX = canvas.width / 2;
            const rugCY = floorY + (canvas.height - floorY) / 2;
            // Oval rug with fringe
            ctx.save();
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath();
            ctx.ellipse(rugCX + 3, rugCY + 3, 160, 80, 0, 0, Math.PI * 2);
            ctx.fill();
            // Main rug
            const rugGrad = ctx.createRadialGradient(rugCX, rugCY, 0, rugCX, rugCY, 160);
            rugGrad.addColorStop(0, '#FF85A2');
            rugGrad.addColorStop(0.6, '#FF6B8A');
            rugGrad.addColorStop(1, '#E8527A');
            ctx.fillStyle = rugGrad;
            ctx.beginPath();
            ctx.ellipse(rugCX, rugCY, 155, 75, 0, 0, Math.PI * 2);
            ctx.fill();
            // Inner pattern
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(rugCX, rugCY, 120, 55, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(rugCX, rugCY, 80, 35, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Fringe around edges
            ctx.strokeStyle = '#E8527A';
            ctx.lineWidth = 1;
            for (let a = 0; a < Math.PI * 2; a += 0.12) {
                const fx = rugCX + Math.cos(a) * 155;
                const fy = rugCY + Math.sin(a) * 75;
                const fdx = Math.cos(a) * 8;
                const fdy = Math.sin(a) * 4;
                ctx.beginPath();
                ctx.moveTo(fx, fy);
                ctx.lineTo(fx + fdx, fy + fdy);
                ctx.stroke();
            }
            ctx.restore();

            // ===== TV ON STAND (left wall) =====
            const tvX = 80;
            const tvY = floorY - 250;
            const tvW = 220;
            const tvH = 140;

            // TV stand / cabinet
            ctx.fillStyle = '#5C3D2E';
            ctx.fillRect(tvX - 10, floorY - 80, tvW + 20, 80);
            // Drawers on stand
            ctx.strokeStyle = '#4A2F22';
            ctx.lineWidth = 1;
            ctx.strokeRect(tvX - 10, floorY - 80, tvW + 20, 80);
            ctx.beginPath();
            ctx.moveTo(tvX + tvW / 2, floorY - 80);
            ctx.lineTo(tvX + tvW / 2, floorY);
            ctx.stroke();
            // Drawer knobs
            ctx.fillStyle = '#C0A080';
            ctx.beginPath();
            ctx.arc(tvX + tvW / 4, floorY - 40, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(tvX + tvW * 3 / 4, floorY - 40, 4, 0, Math.PI * 2);
            ctx.fill();

            // TV body (dark frame)
            ctx.fillStyle = '#1A1A2E';
            ctx.fillRect(tvX - 5, tvY - 5, tvW + 10, tvH + 10);
            // Rounded corners effect
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.strokeRect(tvX - 5, tvY - 5, tvW + 10, tvH + 10);

            // TV screen with channels
            ctx.save();
            ctx.beginPath();
            ctx.rect(tvX, tvY, tvW, tvH);
            ctx.clip();

            if (tvChannel === 0) {
                // ===== CHANNEL 1: BAJKA (cartoon) =====
                const skyGrad = ctx.createLinearGradient(tvX, tvY, tvX, tvY + tvH);
                skyGrad.addColorStop(0, '#87CEEB');
                skyGrad.addColorStop(0.7, '#B0E0FF');
                skyGrad.addColorStop(1, '#90EE90');
                ctx.fillStyle = skyGrad;
                ctx.fillRect(tvX, tvY, tvW, tvH);

                // Animated sun
                const sunX = tvX + 40;
                const sunY = tvY + 30;
                const sunPulse = 18 + Math.sin(interiorAnimationFrame * 0.05) * 3;
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                for (let r = 0; r < 8; r++) {
                    const angle = (r / 8) * Math.PI * 2 + interiorAnimationFrame * 0.02;
                    ctx.beginPath();
                    ctx.moveTo(sunX + Math.cos(angle) * (sunPulse + 3), sunY + Math.sin(angle) * (sunPulse + 3));
                    ctx.lineTo(sunX + Math.cos(angle) * (sunPulse + 10), sunY + Math.sin(angle) * (sunPulse + 10));
                    ctx.stroke();
                }
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(sunX, sunY, sunPulse, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FF8C00';
                ctx.beginPath();
                ctx.arc(sunX - 5, sunY - 3, 2, 0, Math.PI * 2);
                ctx.arc(sunX + 5, sunY - 3, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(sunX, sunY + 3, 5, 0, Math.PI);
                ctx.stroke();

                // Clouds
                const cloudOff = (interiorAnimationFrame * 0.3) % (tvW + 60);
                ctx.fillStyle = '#FFF';
                [cloudOff, cloudOff + 100, cloudOff + 200].forEach(cx => {
                    const wrappedX = tvX + (cx % (tvW + 60)) - 30;
                    ctx.beginPath();
                    ctx.arc(wrappedX, tvY + 25, 12, 0, Math.PI * 2);
                    ctx.arc(wrappedX + 12, tvY + 20, 14, 0, Math.PI * 2);
                    ctx.arc(wrappedX + 24, tvY + 25, 11, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Green hills
                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.moveTo(tvX, tvY + tvH);
                ctx.quadraticCurveTo(tvX + tvW * 0.25, tvY + tvH - 40, tvX + tvW * 0.5, tvY + tvH - 10);
                ctx.quadraticCurveTo(tvX + tvW * 0.75, tvY + tvH - 50, tvX + tvW, tvY + tvH - 15);
                ctx.lineTo(tvX + tvW, tvY + tvH);
                ctx.closePath();
                ctx.fill();

                // Cartoon cat walking
                const catCartoonX = tvX + ((interiorAnimationFrame * 0.8) % (tvW + 40)) - 20;
                const catBob = Math.sin(interiorAnimationFrame * 0.15) * 3;
                ctx.fillStyle = '#FF69B4';
                ctx.beginPath();
                ctx.ellipse(catCartoonX, tvY + tvH - 35 + catBob, 12, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(catCartoonX + 8, tvY + tvH - 45 + catBob, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(catCartoonX + 3, tvY + tvH - 53 + catBob);
                ctx.lineTo(catCartoonX + 6, tvY + tvH - 60 + catBob);
                ctx.lineTo(catCartoonX + 9, tvY + tvH - 53 + catBob);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(catCartoonX + 9, tvY + tvH - 53 + catBob);
                ctx.lineTo(catCartoonX + 12, tvY + tvH - 60 + catBob);
                ctx.lineTo(catCartoonX + 15, tvY + tvH - 53 + catBob);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(catCartoonX + 6, tvY + tvH - 46 + catBob, 1.5, 0, Math.PI * 2);
                ctx.arc(catCartoonX + 11, tvY + tvH - 46 + catBob, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#FF69B4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(catCartoonX - 10, tvY + tvH - 35 + catBob);
                ctx.quadraticCurveTo(catCartoonX - 18, tvY + tvH - 55 + catBob + Math.sin(interiorAnimationFrame * 0.1) * 5, catCartoonX - 14, tvY + tvH - 50 + catBob);
                ctx.stroke();
                const legAnim = Math.sin(interiorAnimationFrame * 0.2);
                ctx.beginPath();
                ctx.moveTo(catCartoonX - 5, tvY + tvH - 27 + catBob);
                ctx.lineTo(catCartoonX - 5 + legAnim * 3, tvY + tvH - 20 + catBob);
                ctx.moveTo(catCartoonX + 5, tvY + tvH - 27 + catBob);
                ctx.lineTo(catCartoonX + 5 - legAnim * 3, tvY + tvH - 20 + catBob);
                ctx.stroke();

                // Flowers
                ['#FF4444', '#FFFF00', '#FF69B4', '#9370DB'].forEach((col, i) => {
                    const fx = tvX + 30 + i * 50;
                    ctx.fillStyle = col;
                    ctx.beginPath();
                    ctx.arc(fx, tvY + tvH - 18, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#228B22';
                    ctx.fillRect(fx - 1, tvY + tvH - 15, 2, 8);
                });

                // Channel label
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW - 55, tvY + 5, 50, 18, 4);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('BAJKA', tvX + tvW - 30, tvY + 17);

            } else if (tvChannel === 1) {
                // ===== CHANNEL 2: WIADOMO≈öCI (news) =====
                // Studio background
                const newsGrad = ctx.createLinearGradient(tvX, tvY, tvX, tvY + tvH);
                newsGrad.addColorStop(0, '#1a237e');
                newsGrad.addColorStop(1, '#283593');
                ctx.fillStyle = newsGrad;
                ctx.fillRect(tvX, tvY, tvW, tvH);

                // World map silhouette in background
                ctx.fillStyle = 'rgba(255,255,255,0.08)';
                ctx.beginPath();
                ctx.arc(tvX + tvW / 2, tvY + 50, 40, 0, Math.PI * 2);
                ctx.fill();
                // Continents (simplified blobs)
                ctx.fillStyle = 'rgba(100,180,255,0.15)';
                ctx.beginPath();
                ctx.ellipse(tvX + tvW / 2 - 15, tvY + 42, 12, 18, -0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(tvX + tvW / 2 + 15, tvY + 40, 10, 15, 0.3, 0, Math.PI * 2);
                ctx.fill();

                // News desk
                ctx.fillStyle = '#4A148C';
                ctx.fillRect(tvX, tvY + tvH - 40, tvW, 40);
                ctx.fillStyle = '#6A1B9A';
                ctx.fillRect(tvX, tvY + tvH - 40, tvW, 5);

                // Presenter (simple animal - bunny)
                const presX = tvX + tvW / 2;
                const presY = tvY + tvH - 55;
                // Body (suit)
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.ellipse(presX, presY + 15, 14, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                // Tie
                ctx.fillStyle = '#E53935';
                ctx.beginPath();
                ctx.moveTo(presX, presY + 5);
                ctx.lineTo(presX - 3, presY + 15);
                ctx.lineTo(presX + 3, presY + 15);
                ctx.closePath();
                ctx.fill();
                // Head
                ctx.fillStyle = '#F5DEB3';
                ctx.beginPath();
                ctx.arc(presX, presY, 10, 0, Math.PI * 2);
                ctx.fill();
                // Ears (bunny)
                ctx.fillStyle = '#F5DEB3';
                ctx.beginPath();
                ctx.ellipse(presX - 5, presY - 18, 3, 10, -0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(presX + 5, presY - 18, 3, 10, 0.2, 0, Math.PI * 2);
                ctx.fill();
                // Inner ears
                ctx.fillStyle = '#FFB6C1';
                ctx.beginPath();
                ctx.ellipse(presX - 5, presY - 18, 1.5, 6, -0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(presX + 5, presY - 18, 1.5, 6, 0.2, 0, Math.PI * 2);
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(presX - 4, presY - 2, 1.5, 0, Math.PI * 2);
                ctx.arc(presX + 4, presY - 2, 1.5, 0, Math.PI * 2);
                ctx.fill();
                // Mouth (talking animation)
                const mouthOpen = Math.sin(interiorAnimationFrame * 0.3) > 0 ? 2 : 0.5;
                ctx.fillStyle = '#C62828';
                ctx.beginPath();
                ctx.ellipse(presX, presY + 4, 2.5, mouthOpen, 0, 0, Math.PI * 2);
                ctx.fill();

                // Papers on desk
                ctx.fillStyle = '#FFF';
                ctx.save();
                ctx.translate(presX - 20, tvY + tvH - 35);
                ctx.rotate(-0.1);
                ctx.fillRect(0, 0, 15, 10);
                ctx.restore();
                ctx.save();
                ctx.translate(presX + 8, tvY + tvH - 34);
                ctx.rotate(0.05);
                ctx.fillRect(0, 0, 15, 10);
                ctx.restore();

                // Breaking news ticker
                ctx.fillStyle = '#C62828';
                ctx.fillRect(tvX, tvY + tvH - 18, tvW, 18);
                ctx.fillStyle = '#FFD600';
                ctx.fillRect(tvX, tvY + tvH - 18, 65, 18);
                ctx.fillStyle = '#000';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('PILNE', tvX + 32, tvY + tvH - 5);

                // Scrolling news text
                const newsTexts = 'Kicioro≈ºek znalaz≈Ç nowych przyjaci√≥≈Ç! *** Pogoda: s≈Çonecznie z tƒôczami *** Cukierki znalezione na polanie *** Hycele pokonane dzielnie! *** ';
                const newsScroll = (interiorAnimationFrame * 0.8) % (newsTexts.length * 7);
                ctx.fillStyle = '#FFF';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(newsTexts + newsTexts, tvX + 70 - newsScroll, tvY + tvH - 5);

                // Channel label
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW - 75, tvY + 5, 70, 18, 4);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('WIADOMO\u015ACI', tvX + tvW - 40, tvY + 17);

            } else if (tvChannel === 2) {
                // ===== CHANNEL 3: PI≈ÅKA NO≈ªNA (football) =====
                // Green pitch
                ctx.fillStyle = '#2E7D32';
                ctx.fillRect(tvX, tvY, tvW, tvH);

                // Pitch lines
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 1;
                // Center line
                ctx.beginPath();
                ctx.moveTo(tvX + tvW / 2, tvY);
                ctx.lineTo(tvX + tvW / 2, tvY + tvH);
                ctx.stroke();
                // Center circle
                ctx.beginPath();
                ctx.arc(tvX + tvW / 2, tvY + tvH / 2, 25, 0, Math.PI * 2);
                ctx.stroke();
                // Center dot
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.beginPath();
                ctx.arc(tvX + tvW / 2, tvY + tvH / 2, 2, 0, Math.PI * 2);
                ctx.fill();
                // Pitch stripes (mowing pattern)
                ctx.fillStyle = 'rgba(255,255,255,0.03)';
                for (let s = 0; s < tvW; s += 20) {
                    if ((s / 20) % 2 === 0) ctx.fillRect(tvX + s, tvY, 20, tvH);
                }
                // Left goal area
                ctx.strokeRect(tvX, tvY + tvH / 2 - 30, 25, 60);
                ctx.strokeRect(tvX, tvY + tvH / 2 - 15, 10, 30);
                // Right goal area
                ctx.strokeRect(tvX + tvW - 25, tvY + tvH / 2 - 30, 25, 60);
                ctx.strokeRect(tvX + tvW - 10, tvY + tvH / 2 - 15, 10, 30);

                // Ball (bouncing around)
                const ballTime = interiorAnimationFrame * 0.03;
                const ballX = tvX + tvW / 2 + Math.sin(ballTime * 1.7) * 70;
                const ballY = tvY + tvH / 2 + Math.cos(ballTime * 2.3) * 40;
                // Ball shadow
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.beginPath();
                ctx.ellipse(ballX, ballY + 5, 5, 2, 0, 0, Math.PI * 2);
                ctx.fill();
                // Ball
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(ballX, ballY, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.arc(ballX, ballY, 5, 0, Math.PI * 2);
                ctx.stroke();
                // Pentagon pattern
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(ballX, ballY, 2, 0, Math.PI * 2);
                ctx.fill();

                // Players - Team A (red)
                const teamAPositions = [
                    [tvX + 30, tvY + tvH / 2],
                    [tvX + 70, tvY + tvH / 2 - 30],
                    [tvX + 70, tvY + tvH / 2 + 30],
                    [tvX + tvW / 2 - 20, tvY + tvH / 2 + Math.sin(interiorAnimationFrame * 0.05) * 15],
                ];
                teamAPositions.forEach(([px, py]) => {
                    // Shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.beginPath();
                    ctx.ellipse(px, py + 7, 4, 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Body
                    ctx.fillStyle = '#E53935';
                    ctx.beginPath();
                    ctx.ellipse(px, py, 4, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Head
                    ctx.fillStyle = '#FFCC80';
                    ctx.beginPath();
                    ctx.arc(px, py - 7, 3, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Players - Team B (blue)
                const teamBPositions = [
                    [tvX + tvW - 30, tvY + tvH / 2],
                    [tvX + tvW - 70, tvY + tvH / 2 - 25],
                    [tvX + tvW - 70, tvY + tvH / 2 + 25],
                    [tvX + tvW / 2 + 20, tvY + tvH / 2 + Math.cos(interiorAnimationFrame * 0.06) * 15],
                ];
                teamBPositions.forEach(([px, py]) => {
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.beginPath();
                    ctx.ellipse(px, py + 7, 4, 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#1565C0';
                    ctx.beginPath();
                    ctx.ellipse(px, py, 4, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FFCC80';
                    ctx.beginPath();
                    ctx.arc(px, py - 7, 3, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Score board
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW / 2 - 40, tvY + 5, 80, 20, 4);
                ctx.fill();
                ctx.fillStyle = '#E53935';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('KOT', tvX + tvW / 2 - 22, tvY + 19);
                ctx.fillStyle = '#FFF';
                ctx.fillText('2:1', tvX + tvW / 2, tvY + 19);
                ctx.fillStyle = '#1565C0';
                ctx.fillText('HYC', tvX + tvW / 2 + 22, tvY + 19);

                // Time
                const matchTime = Math.floor((interiorAnimationFrame * 0.1) % 90) + 1;
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW / 2 - 18, tvY + 26, 36, 14, 3);
                ctx.fill();
                ctx.fillStyle = '#0F0';
                ctx.font = '10px Arial';
                ctx.fillText(matchTime + "'", tvX + tvW / 2, tvY + 37);

                // Channel label
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW - 60, tvY + tvH - 22, 55, 18, 4);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('SPORT', tvX + tvW - 33, tvY + tvH - 10);

            } else if (tvChannel === 3) {
                // ===== CHANNEL 4: POKAZ MODY (fashion show) =====
                // Runway background
                const runwayGrad = ctx.createLinearGradient(tvX, tvY, tvX, tvY + tvH);
                runwayGrad.addColorStop(0, '#1a1a2e');
                runwayGrad.addColorStop(1, '#16213e');
                ctx.fillStyle = runwayGrad;
                ctx.fillRect(tvX, tvY, tvW, tvH);

                // Runway (perspective)
                ctx.fillStyle = '#F5F5F5';
                ctx.beginPath();
                ctx.moveTo(tvX + tvW / 2 - 15, tvY);
                ctx.lineTo(tvX + tvW / 2 + 15, tvY);
                ctx.lineTo(tvX + tvW / 2 + 60, tvY + tvH);
                ctx.lineTo(tvX + tvW / 2 - 60, tvY + tvH);
                ctx.closePath();
                ctx.fill();
                // Runway center line
                ctx.strokeStyle = 'rgba(200,200,200,0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(tvX + tvW / 2, tvY);
                ctx.lineTo(tvX + tvW / 2, tvY + tvH);
                ctx.stroke();
                ctx.setLineDash([]);

                // Spotlights
                for (let i = 0; i < 3; i++) {
                    const slX = tvX + tvW / 2 - 30 + i * 30;
                    const spotGrad = ctx.createRadialGradient(slX, tvY, 0, slX, tvY + 40, 50);
                    spotGrad.addColorStop(0, `rgba(255, 220, 255, ${0.15 + Math.sin(interiorAnimationFrame * 0.08 + i) * 0.05})`);
                    spotGrad.addColorStop(1, 'rgba(255, 220, 255, 0)');
                    ctx.fillStyle = spotGrad;
                    ctx.beginPath();
                    ctx.moveTo(slX - 5, tvY);
                    ctx.lineTo(slX - 40, tvY + tvH);
                    ctx.lineTo(slX + 40, tvY + tvH);
                    ctx.lineTo(slX + 5, tvY);
                    ctx.closePath();
                    ctx.fill();
                }

                // Model walking down runway
                const modelProgress = (interiorAnimationFrame * 0.5) % 180;
                const modelPhase = modelProgress < 90 ? modelProgress / 90 : (180 - modelProgress) / 90; // 0..1..0
                const modelY = tvY + 10 + modelPhase * (tvH - 30);
                const modelScale = 0.5 + modelPhase * 0.5;
                const modelX = tvX + tvW / 2;

                ctx.save();
                ctx.translate(modelX, modelY);
                ctx.scale(modelScale, modelScale);

                // Dress (changes color based on cycle)
                const dressColors = ['#FF1493', '#8A2BE2', '#FF6347', '#00CED1', '#FFD700'];
                const dressIdx = Math.floor((interiorAnimationFrame * 0.01) % dressColors.length);
                const dressColor = dressColors[dressIdx];

                // Body
                ctx.fillStyle = '#FFCC80';
                ctx.beginPath();
                ctx.arc(0, -15, 6, 0, Math.PI * 2);
                ctx.fill();
                // Hair
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.arc(0, -18, 7, Math.PI, Math.PI * 2);
                ctx.fill();
                ctx.fillRect(-7, -18, 14, 5);
                // Long hair flowing
                ctx.beginPath();
                ctx.moveTo(-7, -16);
                ctx.quadraticCurveTo(-10, -5, -8 + Math.sin(interiorAnimationFrame * 0.1) * 2, 5);
                ctx.lineTo(-5, 5);
                ctx.lineTo(-5, -16);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(7, -16);
                ctx.quadraticCurveTo(10, -5, 8 + Math.sin(interiorAnimationFrame * 0.1 + 1) * 2, 5);
                ctx.lineTo(5, 5);
                ctx.lineTo(5, -16);
                ctx.closePath();
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-2, -16, 1, 0, Math.PI * 2);
                ctx.arc(2, -16, 1, 0, Math.PI * 2);
                ctx.fill();
                // Smile
                ctx.strokeStyle = '#C62828';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(0, -13, 2, 0, Math.PI);
                ctx.stroke();
                // Dress
                ctx.fillStyle = dressColor;
                ctx.beginPath();
                ctx.moveTo(-5, -8);
                ctx.lineTo(5, -8);
                ctx.lineTo(12, 20);
                ctx.quadraticCurveTo(0, 18 + Math.sin(interiorAnimationFrame * 0.15) * 2, -12, 20);
                ctx.closePath();
                ctx.fill();
                // Belt/waist
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(-5, -3, 10, 2);
                // Legs
                const legWalk = Math.sin(interiorAnimationFrame * 0.2) * 3;
                ctx.strokeStyle = '#FFCC80';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-3, 20);
                ctx.lineTo(-3 + legWalk, 28);
                ctx.moveTo(3, 20);
                ctx.lineTo(3 - legWalk, 28);
                ctx.stroke();
                // High heels
                ctx.fillStyle = dressColor;
                ctx.fillRect(-5 + legWalk, 27, 4, 3);
                ctx.fillRect(1 - legWalk, 27, 4, 3);

                ctx.restore();

                // Audience silhouettes at sides
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                for (let i = 0; i < 8; i++) {
                    const side = i < 4 ? -1 : 1;
                    const idx = i % 4;
                    const ax = tvX + tvW / 2 + side * (70 + idx * 10);
                    const ay = tvY + tvH - 20 - idx * 8;
                    ctx.beginPath();
                    ctx.arc(ax, ay - 5, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(ax - 3, ay - 1, 6, 8);
                }

                // Camera flashes
                if (Math.random() < 0.03) {
                    const flashX = tvX + 20 + Math.random() * (tvW - 40);
                    const flashY = tvY + tvH - 30 - Math.random() * 30;
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.beginPath();
                    ctx.arc(flashX, flashY, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Channel label
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW - 60, tvY + 5, 55, 18, 4);
                ctx.fill();
                ctx.fillStyle = '#FF69B4';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('MODA', tvX + tvW - 33, tvY + 17);

            } else if (tvChannel === 4) {
                // ===== CHANNEL 5: WY≈öCIGI SAMOCHOD√ìW (car racing) =====
                // Asphalt track background
                ctx.fillStyle = '#555';
                ctx.fillRect(tvX, tvY, tvW, tvH);

                // Road with perspective
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(tvX + tvW / 2 - 10, tvY);
                ctx.lineTo(tvX + tvW / 2 + 10, tvY);
                ctx.lineTo(tvX + tvW + 20, tvY + tvH);
                ctx.lineTo(tvX - 20, tvY + tvH);
                ctx.closePath();
                ctx.fill();

                // Road lines (dashed center, perspective)
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 12]);
                const lineScroll = (interiorAnimationFrame * 3) % 20;
                ctx.lineDashOffset = -lineScroll;
                ctx.beginPath();
                ctx.moveTo(tvX + tvW / 2, tvY);
                ctx.lineTo(tvX + tvW / 2, tvY + tvH);
                ctx.stroke();
                ctx.setLineDash([]);

                // Red-white curbs on sides
                for (let cy = tvY; cy < tvY + tvH; cy += 8) {
                    const progress = (cy - tvY) / tvH;
                    const leftEdge = tvX + tvW / 2 - 10 - progress * (tvW / 2 + 10);
                    const rightEdge = tvX + tvW / 2 + 10 + progress * (tvW / 2 + 10);
                    ctx.fillStyle = ((cy / 8) % 2 === 0) ? '#E53935' : '#FFF';
                    ctx.fillRect(leftEdge - 4, cy, 4, 8);
                    ctx.fillRect(rightEdge, cy, 4, 8);
                }

                // Grass on the side
                ctx.fillStyle = '#2E7D32';
                // Left grass
                ctx.beginPath();
                ctx.moveTo(tvX, tvY);
                ctx.lineTo(tvX + tvW / 2 - 10, tvY);
                ctx.lineTo(tvX - 24, tvY + tvH);
                ctx.lineTo(tvX, tvY + tvH);
                ctx.closePath();
                ctx.fill();
                // Right grass
                ctx.beginPath();
                ctx.moveTo(tvX + tvW, tvY);
                ctx.lineTo(tvX + tvW / 2 + 10, tvY);
                ctx.lineTo(tvX + tvW + 24, tvY + tvH);
                ctx.lineTo(tvX + tvW, tvY + tvH);
                ctx.closePath();
                ctx.fill();

                // Cars racing
                const carColors = ['#E53935', '#1565C0', '#FFD600', '#4CAF50', '#FF6F00'];
                for (let c = 0; c < 4; c++) {
                    const carPhase = ((interiorAnimationFrame * (1.5 + c * 0.3)) + c * 60) % (tvH + 40);
                    const carProgress = carPhase / (tvH + 40);
                    const carY = tvY - 10 + carPhase;
                    const carScale = 0.3 + carProgress * 0.7;
                    const laneOffset = (c % 2 === 0 ? -1 : 1) * (15 + carProgress * 30) + Math.sin(interiorAnimationFrame * 0.05 + c) * 5;
                    const carX = tvX + tvW / 2 + laneOffset;

                    if (carY > tvY - 10 && carY < tvY + tvH + 10) {
                        ctx.save();
                        ctx.translate(carX, carY);
                        ctx.scale(carScale, carScale);

                        // Car shadow
                        ctx.fillStyle = 'rgba(0,0,0,0.3)';
                        ctx.beginPath();
                        ctx.ellipse(2, 5, 14, 4, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Car body
                        ctx.fillStyle = carColors[c];
                        ctx.beginPath();
                        ctx.roundRect(-12, -8, 24, 16, 4);
                        ctx.fill();

                        // Windshield
                        ctx.fillStyle = 'rgba(100,200,255,0.6)';
                        ctx.beginPath();
                        ctx.roundRect(-6, -6, 12, 5, 2);
                        ctx.fill();

                        // Wheels
                        ctx.fillStyle = '#111';
                        ctx.fillRect(-14, -5, 4, 5);
                        ctx.fillRect(10, -5, 4, 5);
                        ctx.fillRect(-14, 2, 4, 5);
                        ctx.fillRect(10, 2, 4, 5);

                        // Number on hood
                        ctx.fillStyle = '#FFF';
                        ctx.font = 'bold 7px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(String(c + 1), 0, 5);

                        // Speed lines behind car
                        ctx.strokeStyle = `rgba(255,255,255,${0.3 * carScale})`;
                        ctx.lineWidth = 1;
                        for (let sl = 0; sl < 3; sl++) {
                            ctx.beginPath();
                            ctx.moveTo(-8 + sl * 8, -10);
                            ctx.lineTo(-8 + sl * 8, -15 - Math.random() * 5);
                            ctx.stroke();
                        }

                        ctx.restore();
                    }
                }

                // Lap counter
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.beginPath();
                ctx.roundRect(tvX + 5, tvY + 5, 55, 20, 4);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'left';
                const lap = Math.floor((interiorAnimationFrame * 0.02) % 20) + 1;
                ctx.fillText('Okr. ' + lap + '/20', tvX + 10, tvY + 19);

                // Speed indicator
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW - 65, tvY + tvH - 25, 60, 20, 4);
                ctx.fill();
                const speed = 180 + Math.floor(Math.sin(interiorAnimationFrame * 0.04) * 40);
                ctx.fillStyle = speed > 200 ? '#FF4444' : '#FFF';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(speed + ' km/h', tvX + tvW - 35, tvY + tvH - 11);

                // Channel label
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW - 75, tvY + 5, 70, 18, 4);
                ctx.fill();
                ctx.fillStyle = '#FF6F00';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('WY\u015ACIGI', tvX + tvW - 40, tvY + 17);

            } else if (tvChannel === 5) {
                // ===== CHANNEL 6: KLAUN (clown show) =====
                // Circus tent background
                const tentGrad = ctx.createLinearGradient(tvX, tvY, tvX + tvW, tvY);
                for (let i = 0; i <= 8; i++) {
                    tentGrad.addColorStop(i / 8, i % 2 === 0 ? '#E53935' : '#FFF');
                }
                ctx.fillStyle = tentGrad;
                ctx.fillRect(tvX, tvY, tvW, tvH);

                // Stage floor
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(tvX, tvY + tvH * 0.65, tvW, tvH * 0.35);
                ctx.fillStyle = '#A0522D';
                for (let sx = tvX; sx < tvX + tvW; sx += 20) {
                    ctx.fillRect(sx, tvY + tvH * 0.65, 10, tvH * 0.35);
                }

                // Spotlight beams
                ctx.fillStyle = 'rgba(255, 255, 100, 0.15)';
                ctx.beginPath();
                ctx.moveTo(tvX + 30, tvY);
                ctx.lineTo(tvX + tvW / 2 - 30, tvY + tvH * 0.65);
                ctx.lineTo(tvX + tvW / 2 + 30, tvY + tvH * 0.65);
                ctx.lineTo(tvX + tvW - 30, tvY);
                ctx.closePath();
                ctx.fill();

                // Clown body
                const clownX = tvX + tvW / 2;
                const clownY = tvY + tvH * 0.45;
                const clownBob = Math.sin(interiorAnimationFrame * 0.08) * 4;

                // Big shoes
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.ellipse(clownX - 15, clownY + 35 + clownBob, 18, 6, -0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(clownX + 15, clownY + 35 + clownBob, 18, 6, 0.2, 0, Math.PI * 2);
                ctx.fill();

                // Legs (baggy pants)
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(clownX - 12, clownY + 15 + clownBob, 10, 20);
                ctx.fillRect(clownX + 2, clownY + 15 + clownBob, 10, 20);

                // Body (polka dot shirt)
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.ellipse(clownX, clownY + clownBob, 18, 20, 0, 0, Math.PI * 2);
                ctx.fill();
                // Polka dots
                ctx.fillStyle = '#FFF';
                [[-6,-5],[5,-8],[0,5],[-8,3],[7,2]].forEach(([dx,dy]) => {
                    ctx.beginPath();
                    ctx.arc(clownX + dx, clownY + dy + clownBob, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Big bow tie
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.moveTo(clownX, clownY - 15 + clownBob);
                ctx.lineTo(clownX - 12, clownY - 22 + clownBob);
                ctx.lineTo(clownX - 12, clownY - 8 + clownBob);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(clownX, clownY - 15 + clownBob);
                ctx.lineTo(clownX + 12, clownY - 22 + clownBob);
                ctx.lineTo(clownX + 12, clownY - 8 + clownBob);
                ctx.closePath();
                ctx.fill();

                // Arms (juggling)
                const armAngle1 = interiorAnimationFrame * 0.1;
                const armAngle2 = interiorAnimationFrame * 0.1 + Math.PI;
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(clownX - 15, clownY - 5 + clownBob);
                ctx.lineTo(clownX - 28 + Math.cos(armAngle1) * 8, clownY - 20 + Math.sin(armAngle1) * 5 + clownBob);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(clownX + 15, clownY - 5 + clownBob);
                ctx.lineTo(clownX + 28 + Math.cos(armAngle2) * 8, clownY - 20 + Math.sin(armAngle2) * 5 + clownBob);
                ctx.stroke();

                // Head
                ctx.fillStyle = '#FFDAB9';
                ctx.beginPath();
                ctx.arc(clownX, clownY - 25 + clownBob, 14, 0, Math.PI * 2);
                ctx.fill();

                // Red nose
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.arc(clownX, clownY - 23 + clownBob, 5, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(clownX - 6, clownY - 28 + clownBob, 2.5, 0, Math.PI * 2);
                ctx.arc(clownX + 6, clownY - 28 + clownBob, 2.5, 0, Math.PI * 2);
                ctx.fill();

                // Big smile
                ctx.strokeStyle = '#E53935';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(clownX, clownY - 22 + clownBob, 8, 0.1 * Math.PI, 0.9 * Math.PI);
                ctx.stroke();

                // Colorful hair/wig
                ctx.fillStyle = '#FF6F00';
                const hairPts = [[-14,-30],[-16,-36],[-10,-40],[-4,-42],[4,-42],[10,-40],[16,-36],[14,-30]];
                hairPts.forEach(([hx,hy]) => {
                    ctx.beginPath();
                    ctx.arc(clownX + hx, clownY + hy + clownBob + Math.sin(interiorAnimationFrame * 0.05 + hx) * 1.5, 5, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Juggling balls
                const ballColors = ['#FF0000', '#FFFF00', '#0000FF'];
                for (let b = 0; b < 3; b++) {
                    const bAngle = interiorAnimationFrame * 0.08 + b * (Math.PI * 2 / 3);
                    const jbx = clownX + Math.cos(bAngle) * 25;
                    const jby = clownY - 35 + Math.sin(bAngle) * 15 + clownBob;
                    ctx.fillStyle = ballColors[b];
                    ctx.beginPath();
                    ctx.arc(jbx, jby, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(255,255,255,0.4)';
                    ctx.beginPath();
                    ctx.arc(jbx - 1, jby - 1, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Channel label
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW - 65, tvY + 5, 60, 18, 4);
                ctx.fill();
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('KLAUN', tvX + tvW - 35, tvY + 17);

            } else if (tvChannel === 6) {
                // ===== CHANNEL 7: MUZYKA (singing show) =====
                // Dark stage background with lights
                ctx.fillStyle = '#1a1a3e';
                ctx.fillRect(tvX, tvY, tvW, tvH);

                // Disco lights
                const discoColors = ['#FF0000', '#00FF00', '#0000FF', '#FF00FF', '#FFFF00', '#00FFFF'];
                for (let d = 0; d < 5; d++) {
                    const dAngle = interiorAnimationFrame * 0.03 + d * 1.2;
                    const dx = tvX + tvW / 2 + Math.cos(dAngle) * (tvW * 0.4);
                    const dy = tvY + tvH * 0.3 + Math.sin(dAngle * 0.7) * (tvH * 0.2);
                    const grad = ctx.createRadialGradient(dx, dy, 0, dx, dy, 30);
                    grad.addColorStop(0, discoColors[d % discoColors.length].replace(')', ', 0.3)').replace('rgb', 'rgba'));
                    grad.addColorStop(0, `rgba(${parseInt(discoColors[d % discoColors.length].slice(1,3),16)}, ${parseInt(discoColors[d % discoColors.length].slice(3,5),16)}, ${parseInt(discoColors[d % discoColors.length].slice(5,7),16)}, 0.3)`);
                    grad.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = grad;
                    ctx.fillRect(tvX, tvY, tvW, tvH);
                }

                // Stage
                ctx.fillStyle = '#333';
                ctx.fillRect(tvX, tvY + tvH * 0.7, tvW, tvH * 0.3);
                ctx.fillStyle = '#444';
                ctx.fillRect(tvX, tvY + tvH * 0.7, tvW, 3);

                // Singer in center
                const singerX = tvX + tvW / 2;
                const singerY = tvY + tvH * 0.5;
                const singerBob = Math.sin(interiorAnimationFrame * 0.12) * 3;

                // Singer body (dress)
                const dressGrad = ctx.createLinearGradient(singerX, singerY - 10, singerX, singerY + 30);
                dressGrad.addColorStop(0, '#E91E63');
                dressGrad.addColorStop(1, '#AD1457');
                ctx.fillStyle = dressGrad;
                ctx.beginPath();
                ctx.moveTo(singerX - 12, singerY - 10 + singerBob);
                ctx.lineTo(singerX + 12, singerY - 10 + singerBob);
                ctx.lineTo(singerX + 18, singerY + 30 + singerBob);
                ctx.lineTo(singerX - 18, singerY + 30 + singerBob);
                ctx.closePath();
                ctx.fill();

                // Head
                ctx.fillStyle = '#FFDAB9';
                ctx.beginPath();
                ctx.arc(singerX, singerY - 20 + singerBob, 10, 0, Math.PI * 2);
                ctx.fill();

                // Hair
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(singerX, singerY - 23 + singerBob, 10, Math.PI, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(singerX - 10, singerY - 15 + singerBob, 4, 12, 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(singerX + 10, singerY - 15 + singerBob, 4, 12, -0.3, 0, Math.PI * 2);
                ctx.fill();

                // Microphone (held up)
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(singerX + 10, singerY - 8 + singerBob);
                ctx.lineTo(singerX + 16, singerY - 25 + singerBob);
                ctx.stroke();
                ctx.fillStyle = '#888';
                ctx.beginPath();
                ctx.arc(singerX + 16, singerY - 27 + singerBob, 4, 0, Math.PI * 2);
                ctx.fill();

                // Singing mouth (open, pulsing)
                const mouthSize = 3 + Math.abs(Math.sin(interiorAnimationFrame * 0.15)) * 2;
                ctx.fillStyle = '#C62828';
                ctx.beginPath();
                ctx.ellipse(singerX, singerY - 16 + singerBob, 3, mouthSize, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(singerX - 4, singerY - 22 + singerBob, 1.5, 0, Math.PI * 2);
                ctx.arc(singerX + 4, singerY - 22 + singerBob, 1.5, 0, Math.PI * 2);
                ctx.fill();

                // Music notes floating
                const noteSymbols = ['\u266A', '\u266B', '\u2669'];
                const noteColors = ['#FF69B4', '#FFD700', '#87CEEB', '#FF6B6B', '#90EE90'];
                for (let n = 0; n < 6; n++) {
                    const nPhase = (interiorAnimationFrame * 0.02 + n * 0.4) % 2;
                    const nAlpha = Math.max(0, 1 - nPhase / 2);
                    const nx = singerX - 30 + n * 12 + Math.sin(interiorAnimationFrame * 0.05 + n) * 10;
                    const ny = singerY - 30 - nPhase * 30;
                    ctx.fillStyle = noteColors[n % noteColors.length];
                    ctx.globalAlpha = nAlpha;
                    ctx.font = `bold ${10 + n % 3 * 2}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(noteSymbols[n % noteSymbols.length], nx, ny);
                }
                ctx.globalAlpha = 1;

                // Audience silhouettes at bottom
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                for (let a = 0; a < 8; a++) {
                    const ax = tvX + 10 + a * (tvW - 20) / 7;
                    const ay = tvY + tvH - 8;
                    const abob = Math.sin(interiorAnimationFrame * 0.1 + a * 0.8) * 2;
                    ctx.beginPath();
                    ctx.arc(ax, ay - 5 + abob, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(ax - 4, ay + abob, 8, 8);
                }
                // Hands up in audience
                for (let a = 0; a < 5; a++) {
                    const hx = tvX + 20 + a * (tvW - 40) / 4;
                    const hbob = Math.sin(interiorAnimationFrame * 0.15 + a) * 4;
                    ctx.strokeStyle = 'rgba(0,0,0,0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(hx, tvY + tvH - 10);
                    ctx.lineTo(hx + Math.sin(interiorAnimationFrame * 0.1 + a) * 3, tvY + tvH - 20 + hbob);
                    ctx.stroke();
                }

                // Channel label
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.roundRect(tvX + tvW - 70, tvY + 5, 65, 18, 4);
                ctx.fill();
                ctx.fillStyle = '#FF69B4';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('MUZYKA', tvX + tvW - 38, tvY + 17);
            }

            ctx.restore(); // end TV clip

            // TV power LED
            const ledColors = ['#00FF00', '#FF4444', '#4488FF', '#FF69B4', '#FF6F00', '#FFD700', '#FF69B4'];
            ctx.fillStyle = interiorAnimationFrame % 120 < 100 ? ledColors[tvChannel] : '#222';
            ctx.beginPath();
            ctx.arc(tvX + tvW / 2, tvY + tvH + 3, 2, 0, Math.PI * 2);
            ctx.fill();

            // TV screen glow (color depends on channel)
            const glowColors = ['rgba(135, 206, 235, 0.3)', 'rgba(26, 35, 126, 0.3)', 'rgba(46, 125, 50, 0.3)', 'rgba(255, 20, 147, 0.3)', 'rgba(255, 111, 0, 0.3)', 'rgba(255, 215, 0, 0.3)', 'rgba(255, 105, 180, 0.3)'];
            ctx.shadowColor = glowColors[tvChannel];
            ctx.shadowBlur = 15;
            ctx.strokeStyle = glowColors[tvChannel].replace('0.3', '0.2');
            ctx.lineWidth = 1;
            ctx.strokeRect(tvX - 1, tvY - 1, tvW + 2, tvH + 2);
            ctx.shadowBlur = 0;

            // ===== REMOTE CONTROL (on TV stand) =====
            const remoteX = tvX + tvW + 15;
            const remoteY = floorY - 65;
            // Remote body
            ctx.fillStyle = '#2C2C2C';
            ctx.beginPath();
            ctx.roundRect(remoteX, remoteY, 18, 68, 4);
            ctx.fill();
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(remoteX, remoteY, 18, 68, 4);
            ctx.stroke();
            // IR window
            ctx.fillStyle = '#4A0000';
            ctx.fillRect(remoteX + 5, remoteY + 2, 8, 3);
            // Power button (red)
            ctx.fillStyle = '#E53935';
            ctx.beginPath();
            ctx.arc(remoteX + 9, remoteY + 10, 3, 0, Math.PI * 2);
            ctx.fill();
            // Channel buttons (1-7)
            const btnColors = ['#4CAF50', '#2196F3', '#FF9800', '#FF69B4', '#FF6F00', '#FFD700', '#E91E63'];
            for (let i = 0; i < 7; i++) {
                ctx.fillStyle = tvChannel === i ? btnColors[i] : '#555';
                ctx.beginPath();
                ctx.roundRect(remoteX + 3, remoteY + 17 + i * 7, 12, 5, 2);
                ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.font = '5px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(String(i + 1), remoteX + 9, remoteY + 21 + i * 7);
            }

            // ===== COUCH / KANAPA (right of TV) =====
            const couchX = 340;
            const couchY = floorY;
            const couchW = 120;
            const couchH = 55;

            // Couch base
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.roundRect(couchX, couchY - 8, couchW, 15, 3);
            ctx.fill();
            // Couch legs
            ctx.fillStyle = '#5C3D2E';
            ctx.fillRect(couchX + 8, couchY + 2, 6, 12);
            ctx.fillRect(couchX + couchW - 14, couchY + 2, 6, 12);
            // Seat cushion
            const couchGrad = ctx.createLinearGradient(couchX, couchY - couchH, couchX, couchY);
            couchGrad.addColorStop(0, '#C0392B');
            couchGrad.addColorStop(1, '#E74C3C');
            ctx.fillStyle = couchGrad;
            ctx.beginPath();
            ctx.roundRect(couchX + 3, couchY - 25, couchW - 6, 20, 6);
            ctx.fill();
            // Back cushion
            ctx.fillStyle = '#C0392B';
            ctx.beginPath();
            ctx.roundRect(couchX + 3, couchY - couchH, couchW - 6, 32, 8);
            ctx.fill();
            // Cushion divider line
            ctx.strokeStyle = '#A93226';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(couchX + couchW / 2, couchY - couchH + 5);
            ctx.lineTo(couchX + couchW / 2, couchY - 10);
            ctx.stroke();
            // Armrests
            ctx.fillStyle = '#A93226';
            ctx.beginPath();
            ctx.roundRect(couchX - 8, couchY - couchH + 10, 14, couchH - 15, 5);
            ctx.fill();
            ctx.beginPath();
            ctx.roundRect(couchX + couchW - 6, couchY - couchH + 10, 14, couchH - 15, 5);
            ctx.fill();
            // Pillow on couch
            ctx.fillStyle = '#F5B041';
            ctx.beginPath();
            ctx.ellipse(couchX + 30, couchY - 30, 15, 10, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#F7C948';
            ctx.beginPath();
            ctx.ellipse(couchX + 28, couchY - 32, 5, 4, -0.2, 0, Math.PI * 2);
            ctx.fill();

            // ===== FOOD BOWLS (right of couch) =====
            const bowlX = 510;
            const bowlY = floorY;

            // Food mat
            ctx.fillStyle = '#E8D5B7';
            ctx.beginPath();
            ctx.ellipse(bowlX + 30, bowlY + 10, 75, 18, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#C4A882';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.ellipse(bowlX + 30, bowlY + 10, 75, 18, 0, 0, Math.PI * 2);
            ctx.stroke();

            // Water bowl (left)
            // Bowl outer
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.ellipse(bowlX - 10, bowlY, 28, 12, 0, 0, Math.PI);
            ctx.fill();
            // Bowl rim
            ctx.fillStyle = '#5B7FDE';
            ctx.beginPath();
            ctx.ellipse(bowlX - 10, bowlY - 2, 30, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#3355B0';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.ellipse(bowlX - 10, bowlY - 2, 30, 10, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Water inside
            ctx.fillStyle = 'rgba(100, 180, 255, 0.6)';
            ctx.beginPath();
            ctx.ellipse(bowlX - 10, bowlY - 3, 24, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            // Water reflection
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.ellipse(bowlX - 15, bowlY - 5, 8, 3, -0.3, 0, Math.PI * 2);
            ctx.fill();
            // Paw print on bowl
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.arc(bowlX - 10, bowlY + 3, 3, 0, Math.PI * 2);
            ctx.fill();
            [[-4,-2],[-2,-5],[2,-5],[4,-2]].forEach(([dx,dy]) => {
                ctx.beginPath();
                ctx.arc(bowlX - 10 + dx, bowlY + 3 + dy, 1.5, 0, Math.PI * 2);
                ctx.fill();
            });

            // Food bowl (right)
            ctx.fillStyle = '#FF6B6B';
            ctx.beginPath();
            ctx.ellipse(bowlX + 60, bowlY, 28, 12, 0, 0, Math.PI);
            ctx.fill();
            ctx.fillStyle = '#FF8585';
            ctx.beginPath();
            ctx.ellipse(bowlX + 60, bowlY - 2, 30, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#CC4444';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.ellipse(bowlX + 60, bowlY - 2, 30, 10, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Kibble pieces
            ctx.fillStyle = '#8B6914';
            const kibblePositions = [
                [0, 0], [-8, -2], [6, -1], [-4, 2], [3, 3],
                [-10, 1], [8, 2], [-2, -4], [5, -3], [-6, 3]
            ];
            kibblePositions.forEach(([kx, ky]) => {
                ctx.beginPath();
                ctx.ellipse(bowlX + 60 + kx, bowlY - 5 + ky, 4, 3, kx * 0.1, 0, Math.PI * 2);
                ctx.fill();
            });
            // Kibble highlight
            ctx.fillStyle = '#A08030';
            kibblePositions.slice(0, 5).forEach(([kx, ky]) => {
                ctx.beginPath();
                ctx.ellipse(bowlX + 60 + kx - 1, bowlY - 6 + ky, 2, 1.5, kx * 0.1, 0, Math.PI * 2);
                ctx.fill();
            });
            // Heart on food bowl
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('‚ô•', bowlX + 60, bowlY + 6);

            // ===== CAMERA ON SHELF =====
            const cameraX = 620;
            const cameraShelfY = floorY - 50;
            // Small shelf
            ctx.fillStyle = '#8B6238';
            ctx.fillRect(cameraX - 20, cameraShelfY, 40, 5);
            ctx.fillStyle = '#A0764B';
            ctx.fillRect(cameraX - 18, cameraShelfY + 1, 36, 3);
            // Camera body
            ctx.fillStyle = '#333';
            ctx.fillRect(cameraX - 12, cameraShelfY - 18, 24, 16);
            ctx.fillStyle = '#444';
            ctx.fillRect(cameraX - 10, cameraShelfY - 16, 20, 12);
            // Lens
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.arc(cameraX, cameraShelfY - 10, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#4488FF';
            ctx.beginPath();
            ctx.arc(cameraX, cameraShelfY - 10, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.beginPath();
            ctx.arc(cameraX - 1, cameraShelfY - 11, 1.5, 0, Math.PI * 2);
            ctx.fill();
            // Flash
            ctx.fillStyle = '#DDD';
            ctx.fillRect(cameraX + 6, cameraShelfY - 20, 6, 4);
            // Viewfinder
            ctx.fillStyle = '#555';
            ctx.fillRect(cameraX - 4, cameraShelfY - 22, 8, 4);

            // ===== WALL PHOTO (if taken) =====
            if (wallPhoto) {
                const photoW = 180;
                const photoH = 110;
                const photoX = cameraX - photoW / 2;
                const photoY = floorY - 230;

                // Ornate frame
                ctx.fillStyle = '#8B6238';
                ctx.fillRect(photoX - 8, photoY - 8, photoW + 16, photoH + 16);
                ctx.fillStyle = '#A0764B';
                ctx.fillRect(photoX - 5, photoY - 5, photoW + 10, photoH + 10);
                ctx.fillStyle = '#C4935A';
                ctx.fillRect(photoX - 3, photoY - 3, photoW + 6, photoH + 6);

                // Photo image
                if (wallPhoto.loaded && wallPhoto._img) {
                    ctx.drawImage(wallPhoto._img, photoX, photoY, photoW, photoH);
                } else {
                    // Placeholder while loading
                    ctx.fillStyle = '#EEE';
                    ctx.fillRect(photoX, photoY, photoW, photoH);
                    ctx.fillStyle = '#999';
                    ctx.font = '12px Comic Sans MS';
                    ctx.textAlign = 'center';
                    ctx.fillText('≈Åadowanie...', photoX + photoW / 2, photoY + photoH / 2);
                }

                // Frame corner decorations
                ctx.fillStyle = '#8B6238';
                [[-8,-8],[photoW,-8],[-8,photoH],[photoW,photoH]].forEach(([cx,cy]) => {
                    ctx.beginPath();
                    ctx.arc(photoX + cx + 4, photoY + cy + 4, 5, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Hanging wire
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(photoX + 30, photoY - 8);
                ctx.quadraticCurveTo(photoX + photoW / 2, photoY - 25, photoX + photoW - 30, photoY - 8);
                ctx.stroke();
                // Nail
                ctx.fillStyle = '#888';
                ctx.beginPath();
                ctx.arc(photoX + photoW / 2, photoY - 22, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // ===== CAMERA FLASH EFFECT =====
            if (photoFlashTimer > 0) {
                photoFlashTimer--;
                const flashAlpha = photoFlashTimer / 20;
                ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha * 0.8})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // ===== LITTER BOX (far right corner) =====
            const litterX = canvas.width - 160;
            const litterY = floorY;

            // Litter box - 3D perspective
            // Back wall
            ctx.fillStyle = '#A8C8A8';
            ctx.beginPath();
            ctx.moveTo(litterX, litterY - 50);
            ctx.lineTo(litterX + 110, litterY - 50);
            ctx.lineTo(litterX + 100, litterY - 35);
            ctx.lineTo(litterX + 10, litterY - 35);
            ctx.closePath();
            ctx.fill();
            // Left side
            ctx.fillStyle = '#8FB88F';
            ctx.beginPath();
            ctx.moveTo(litterX, litterY - 50);
            ctx.lineTo(litterX + 10, litterY - 35);
            ctx.lineTo(litterX + 10, litterY + 10);
            ctx.lineTo(litterX, litterY + 5);
            ctx.closePath();
            ctx.fill();
            // Right side
            ctx.fillStyle = '#8FB88F';
            ctx.beginPath();
            ctx.moveTo(litterX + 110, litterY - 50);
            ctx.lineTo(litterX + 100, litterY - 35);
            ctx.lineTo(litterX + 100, litterY + 10);
            ctx.lineTo(litterX + 110, litterY + 5);
            ctx.closePath();
            ctx.fill();
            // Front
            ctx.fillStyle = '#A8C8A8';
            ctx.fillRect(litterX + 10, litterY - 15, 90, 25);
            // Rim
            ctx.fillStyle = '#7DA87D';
            ctx.fillRect(litterX + 5, litterY - 18, 100, 6);

            // Litter (sandy texture)
            ctx.fillStyle = '#E8D8B8';
            ctx.beginPath();
            ctx.ellipse(litterX + 55, litterY - 22, 42, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            // Litter texture dots
            ctx.fillStyle = '#D4C4A4';
            for (let i = 0; i < 30; i++) {
                const lx = litterX + 20 + (i * 17 + i * i * 3) % 70;
                const ly = litterY - 30 + (i * 13 + i * 7) % 16;
                ctx.beginPath();
                ctx.arc(lx, ly, 1 + (i % 2), 0, Math.PI * 2);
                ctx.fill();
            }
            // Small scoop next to litter box
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.moveTo(litterX + 115, litterY - 5);
            ctx.lineTo(litterX + 118, litterY - 45);
            ctx.lineTo(litterX + 121, litterY - 45);
            ctx.lineTo(litterX + 125, litterY - 5);
            ctx.closePath();
            ctx.fill();
            // Scoop head
            ctx.fillStyle = '#5B7FDE';
            ctx.beginPath();
            ctx.ellipse(litterX + 119, litterY - 47, 8, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            // Holes in scoop
            ctx.fillStyle = '#4169E1';
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(litterX + 116 + i * 4, litterY - 47, 1, 0, Math.PI * 2);
                ctx.fill();
            }

            // ===== TOYS (scattered on floor) =====

            // Ball (bouncy ball with stripes) - between bathtub and door
            const ballX = 1020;
            const ballY = floorY + 30;
            const ballBounce = Math.abs(Math.sin(interiorAnimationFrame * 0.03)) * 10;
            ctx.save();
            ctx.fillStyle = '#FF4444';
            ctx.beginPath();
            ctx.arc(ballX, ballY - ballBounce, 14, 0, Math.PI * 2);
            ctx.fill();
            // Ball stripe
            ctx.fillStyle = '#FFFF44';
            ctx.beginPath();
            ctx.arc(ballX, ballY - ballBounce, 14, -0.3, 0.3);
            ctx.arc(ballX, ballY - ballBounce, 14, Math.PI - 0.3, Math.PI + 0.3);
            ctx.fill();
            ctx.fillStyle = '#FFFF44';
            ctx.fillRect(ballX - 14, ballY - ballBounce - 3, 28, 6);
            // Ball highlight
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.arc(ballX - 4, ballY - ballBounce - 5, 4, 0, Math.PI * 2);
            ctx.fill();
            // Ball shadow
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath();
            ctx.ellipse(ballX, ballY + 14, 10, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Mouse toy (grey mouse on string)
            const mouseX = canvas.width / 2 - 120;
            const mouseY = floorY + 40;
            // String
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(mouseX + 25, mouseY - 5);
            ctx.quadraticCurveTo(mouseX + 40, mouseY - 20, mouseX + 50, mouseY - 5 + Math.sin(interiorAnimationFrame * 0.04) * 5);
            ctx.stroke();
            // Mouse body
            ctx.fillStyle = '#999';
            ctx.beginPath();
            ctx.ellipse(mouseX, mouseY, 15, 10, 0.1, 0, Math.PI * 2);
            ctx.fill();
            // Belly
            ctx.fillStyle = '#BBB';
            ctx.beginPath();
            ctx.ellipse(mouseX + 2, mouseY + 2, 10, 6, 0.1, 0, Math.PI * 2);
            ctx.fill();
            // Ears
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.arc(mouseX - 8, mouseY - 10, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#999';
            ctx.beginPath();
            ctx.arc(mouseX - 8, mouseY - 10, 6, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.arc(mouseX - 1, mouseY - 10, 5, 0, Math.PI * 2);
            ctx.fill();
            // Eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(mouseX - 8, mouseY - 3, 1.5, 0, Math.PI * 2);
            ctx.fill();
            // Nose
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.arc(mouseX - 14, mouseY - 1, 2, 0, Math.PI * 2);
            ctx.fill();
            // Whiskers
            ctx.strokeStyle = '#777';
            ctx.lineWidth = 0.5;
            [[-1, -3], [0, 0], [1, 3]].forEach(([_, dy]) => {
                ctx.beginPath();
                ctx.moveTo(mouseX - 14, mouseY - 1 + dy);
                ctx.lineTo(mouseX - 25, mouseY - 3 + dy);
                ctx.stroke();
            });
            // Tail
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(mouseX + 14, mouseY);
            ctx.quadraticCurveTo(mouseX + 25, mouseY - 10 + Math.sin(interiorAnimationFrame * 0.06) * 3, mouseX + 28, mouseY - 5);
            ctx.stroke();

            // Yarn ball
            const yarnX = 500;
            const yarnY = floorY + 35;
            ctx.fillStyle = '#9370DB';
            ctx.beginPath();
            ctx.arc(yarnX, yarnY, 12, 0, Math.PI * 2);
            ctx.fill();
            // Yarn threads
            ctx.strokeStyle = '#7B57C4';
            ctx.lineWidth = 1;
            for (let i = 0; i < 6; i++) {
                const a1 = i * 0.9;
                const a2 = a1 + 2;
                ctx.beginPath();
                ctx.arc(yarnX, yarnY, 10, a1, a2);
                ctx.stroke();
            }
            // Yarn highlight
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.arc(yarnX - 3, yarnY - 4, 4, 0, Math.PI * 2);
            ctx.fill();
            // Trailing thread
            ctx.strokeStyle = '#9370DB';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(yarnX + 12, yarnY);
            ctx.quadraticCurveTo(yarnX + 30, yarnY + 15, yarnX + 50, yarnY + 5);
            ctx.quadraticCurveTo(yarnX + 65, yarnY - 5, yarnX + 70, yarnY + 10);
            ctx.stroke();

            // Feather wand toy (leaning against wall)
            const wandX = canvas.width - 50;
            const wandBaseY = floorY;
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(wandX, wandBaseY);
            ctx.lineTo(wandX - 15, floorY - 120);
            ctx.stroke();
            // Feathers
            const featherColors = ['#FF69B4', '#FF4500', '#FFD700', '#9370DB', '#00CED1'];
            featherColors.forEach((col, i) => {
                ctx.fillStyle = col;
                ctx.save();
                ctx.translate(wandX - 15, floorY - 120);
                ctx.rotate(-0.5 + i * 0.25 + Math.sin(interiorAnimationFrame * 0.04 + i) * 0.1);
                ctx.beginPath();
                ctx.ellipse(0, -15, 3, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                // Feather spine
                ctx.strokeStyle = col;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(0, -3);
                ctx.lineTo(0, -25);
                ctx.stroke();
                ctx.restore();
            });

            // ===== EXIT DOOR (right wall, moved left to avoid wardrobe panel) =====
            const doorX = canvas.width - 350;
            const doorY = floorY - 160;
            // Door frame
            ctx.fillStyle = '#DDD';
            ctx.fillRect(doorX - 5, doorY - 5, 75, 165);
            // Door
            const doorGrad = ctx.createLinearGradient(doorX, doorY, doorX + 65, doorY);
            doorGrad.addColorStop(0, '#8B6238');
            doorGrad.addColorStop(0.5, '#A0764B');
            doorGrad.addColorStop(1, '#8B6238');
            ctx.fillStyle = doorGrad;
            ctx.fillRect(doorX, doorY, 65, 155);
            // Door panels
            ctx.strokeStyle = '#704E2E';
            ctx.lineWidth = 2;
            ctx.strokeRect(doorX + 8, doorY + 10, 49, 55);
            ctx.strokeRect(doorX + 8, doorY + 80, 49, 55);
            // Door knob
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(doorX + 55, doorY + 80, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#DAA520';
            ctx.beginPath();
            ctx.arc(doorX + 55, doorY + 80, 3, 0, Math.PI * 2);
            ctx.fill();

            // Exit sign
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            const signW = 140;
            const signH = 28;
            const signX = canvas.width - signW - 15;
            const signY = 12;
            // Rounded sign
            ctx.beginPath();
            ctx.roundRect(signX, signY, signW, signH, 8);
            ctx.fill();
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(signX, signY, signW, signH, 8);
            ctx.stroke();
            ctx.fillStyle = '#FF1493';
            ctx.font = 'bold 15px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('SPACJA - Wyjd≈∫', signX + signW / 2, signY + 19);

            // ===== WINDOW on wall (between couch and food) =====
            const winX = 440;
            const winY = 60;
            const winW = 100;
            const winH = 80;
            // Window frame
            ctx.fillStyle = '#FFF';
            ctx.fillRect(winX - 5, winY - 5, winW + 10, winH + 10);
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 2;
            ctx.strokeRect(winX - 5, winY - 5, winW + 10, winH + 10);
            // Sky through window (reflects outside weather)
            const wElapsed = (Date.now() - gameTimeStart) / 1000;
            const wDayCycle = (wElapsed % 60) / 60;
            const wRainCycle = wElapsed % 180;
            const wIsRaining = wRainCycle > 150;
            let winSkyColor;
            if (wDayCycle < 0.2) {
                winSkyColor = lerpColor('#1a1a3e', '#87CEEB', wDayCycle / 0.2);
            } else if (wDayCycle < 0.5) {
                winSkyColor = '#87CEEB';
            } else if (wDayCycle < 0.7) {
                winSkyColor = lerpColor('#87CEEB', '#FF6B35', (wDayCycle - 0.5) / 0.2);
            } else {
                winSkyColor = lerpColor('#FF6B35', '#0a0a2e', Math.min(1, (wDayCycle - 0.7) / 0.15));
            }
            if (wIsRaining) winSkyColor = lerpColor(winSkyColor, '#555566', 0.5);
            ctx.fillStyle = winSkyColor;
            ctx.fillRect(winX, winY, winW, winH);
            // Stars in window at night
            if (wDayCycle > 0.75) {
                const sAlpha = Math.min(1, (wDayCycle - 0.75) * 6);
                ctx.fillStyle = `rgba(255,255,220,${sAlpha})`;
                for (let si = 0; si < 5; si++) {
                    const sx = winX + 10 + si * 18;
                    const sy = winY + 10 + (si * 13) % 50;
                    ctx.beginPath();
                    ctx.arc(sx, sy, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Moon
                ctx.fillStyle = `rgba(255,253,231,${sAlpha * 0.9})`;
                ctx.beginPath();
                ctx.arc(winX + winW - 15, winY + 20, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = winSkyColor;
                ctx.beginPath();
                ctx.arc(winX + winW - 11, winY + 17, 7, 0, Math.PI * 2);
                ctx.fill();
            }
            // Sun in window during day
            if (wDayCycle > 0.15 && wDayCycle < 0.6) {
                const sunAlpha = wDayCycle < 0.25 ? (wDayCycle - 0.15) * 10 : wDayCycle > 0.5 ? (0.6 - wDayCycle) * 10 : 1;
                ctx.fillStyle = `rgba(255,255,0,${sunAlpha * 0.7})`;
                ctx.beginPath();
                ctx.arc(winX + 20, winY + 20, 10, 0, Math.PI * 2);
                ctx.fill();
            }
            // Rain drops on window
            if (wIsRaining) {
                ctx.strokeStyle = 'rgba(150,180,255,0.5)';
                ctx.lineWidth = 1;
                for (let ri = 0; ri < 8; ri++) {
                    const rx = winX + 5 + (ri * 13 + interiorAnimationFrame * 0.5) % (winW - 10);
                    const ry = winY + (ri * 17 + interiorAnimationFrame * 2) % winH;
                    ctx.beginPath();
                    ctx.moveTo(rx, ry);
                    ctx.lineTo(rx - 1, ry + 6);
                    ctx.stroke();
                }
            }
            // Window cross
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(winX + winW / 2, winY);
            ctx.lineTo(winX + winW / 2, winY + winH);
            ctx.moveTo(winX, winY + winH / 2);
            ctx.lineTo(winX + winW, winY + winH / 2);
            ctx.stroke();
            // Curtains
            ctx.fillStyle = '#FFB6C1';
            ctx.globalAlpha = 0.7;
            // Left curtain
            ctx.beginPath();
            ctx.moveTo(winX - 10, winY - 10);
            ctx.quadraticCurveTo(winX + 15, winY + winH / 2, winX - 5, winY + winH + 15);
            ctx.lineTo(winX - 15, winY + winH + 15);
            ctx.lineTo(winX - 15, winY - 10);
            ctx.closePath();
            ctx.fill();
            // Right curtain
            ctx.beginPath();
            ctx.moveTo(winX + winW + 10, winY - 10);
            ctx.quadraticCurveTo(winX + winW - 15, winY + winH / 2, winX + winW + 5, winY + winH + 15);
            ctx.lineTo(winX + winW + 15, winY + winH + 15);
            ctx.lineTo(winX + winW + 15, winY - 10);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1;
            // Curtain rod
            ctx.strokeStyle = '#DAA520';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(winX - 20, winY - 10);
            ctx.lineTo(winX + winW + 20, winY - 10);
            ctx.stroke();
            // Rod ends
            ctx.fillStyle = '#DAA520';
            ctx.beginPath();
            ctx.arc(winX - 20, winY - 10, 4, 0, Math.PI * 2);
            ctx.arc(winX + winW + 20, winY - 10, 4, 0, Math.PI * 2);
            ctx.fill();

            // ===== WALL PICTURE (small framed picture) =====
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(625, 70, 60, 50);
            ctx.fillStyle = '#FFF';
            ctx.fillRect(630, 75, 50, 40);
            // Little heart drawing inside
            ctx.fillStyle = '#FF69B4';
            ctx.font = '25px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('‚ô•', 655, 102);

            // ===== CHANDELIER (ceiling center, glows softly) =====
            const chandX = canvas.width / 2;
            const chandY = 20;

            // Ceiling mount plate
            ctx.fillStyle = '#DAA520';
            ctx.beginPath();
            ctx.ellipse(chandX, chandY, 15, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#C49B18';
            ctx.beginPath();
            ctx.ellipse(chandX, chandY, 12, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Chain links
            ctx.strokeStyle = '#DAA520';
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                const cy = chandY + 8 + i * 10;
                ctx.beginPath();
                ctx.ellipse(chandX, cy, 3, 5, 0, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Chandelier body - main ring
            const chandBodyY = chandY + 55;
            ctx.fillStyle = '#DAA520';
            ctx.beginPath();
            ctx.ellipse(chandX, chandBodyY, 40, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#C49B18';
            ctx.beginPath();
            ctx.ellipse(chandX, chandBodyY - 2, 35, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Chandelier arms and lights (5 lights)
            const numLights = 5;
            for (let i = 0; i < numLights; i++) {
                const angle = (i / numLights) * Math.PI * 2 - Math.PI / 2;
                const armEndX = chandX + Math.cos(angle) * 35;
                const armEndY = chandBodyY + Math.sin(angle) * 6;

                // Arm
                ctx.strokeStyle = '#DAA520';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(chandX + Math.cos(angle) * 10, chandBodyY + Math.sin(angle) * 2);
                ctx.quadraticCurveTo(armEndX, armEndY + 8, armEndX, armEndY + 12);
                ctx.stroke();

                // Candle holder cup
                ctx.fillStyle = '#DAA520';
                ctx.beginPath();
                ctx.moveTo(armEndX - 5, armEndY + 10);
                ctx.lineTo(armEndX + 5, armEndY + 10);
                ctx.lineTo(armEndX + 4, armEndY + 15);
                ctx.lineTo(armEndX - 4, armEndY + 15);
                ctx.closePath();
                ctx.fill();

                // Candle
                ctx.fillStyle = '#FFFFF0';
                ctx.fillRect(armEndX - 2, armEndY + 2, 4, 9);

                // Flame glow (based on light level)
                const flameFlicker = Math.sin(interiorAnimationFrame * 0.15 + i * 1.3) * 0.1;
                const flameBrightness = interiorLightLevel * (0.9 + flameFlicker);

                if (flameBrightness > 0.05) {
                    // Outer glow
                    const glowR = 12 + Math.sin(interiorAnimationFrame * 0.1 + i) * 2;
                    const flameGlow = ctx.createRadialGradient(armEndX, armEndY, 0, armEndX, armEndY, glowR);
                    flameGlow.addColorStop(0, `rgba(255, 200, 50, ${0.3 * flameBrightness})`);
                    flameGlow.addColorStop(1, `rgba(255, 200, 50, 0)`);
                    ctx.fillStyle = flameGlow;
                    ctx.beginPath();
                    ctx.arc(armEndX, armEndY, glowR, 0, Math.PI * 2);
                    ctx.fill();

                    // Flame
                    ctx.fillStyle = `rgba(255, 180, 30, ${flameBrightness})`;
                    ctx.beginPath();
                    ctx.moveTo(armEndX, armEndY - 4 - Math.sin(interiorAnimationFrame * 0.2 + i) * 2);
                    ctx.quadraticCurveTo(armEndX + 3, armEndY, armEndX, armEndY + 3);
                    ctx.quadraticCurveTo(armEndX - 3, armEndY, armEndX, armEndY - 4 - Math.sin(interiorAnimationFrame * 0.2 + i) * 2);
                    ctx.fill();

                    // Inner flame
                    ctx.fillStyle = `rgba(255, 240, 150, ${flameBrightness * 0.8})`;
                    ctx.beginPath();
                    ctx.ellipse(armEndX, armEndY, 1.5, 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Central chandelier glow (ambient light on room)
            const ambientGlowR = 100 + Math.sin(interiorAnimationFrame * 0.05) * 5;
            const ambientGlow = ctx.createRadialGradient(chandX, chandBodyY, 0, chandX, chandBodyY, ambientGlowR);
            ambientGlow.addColorStop(0, `rgba(255, 230, 150, ${0.12 * interiorLightLevel})`);
            ambientGlow.addColorStop(0.5, `rgba(255, 220, 120, ${0.05 * interiorLightLevel})`);
            ambientGlow.addColorStop(1, `rgba(255, 200, 80, 0)`);
            ctx.fillStyle = ambientGlow;
            ctx.beginPath();
            ctx.arc(chandX, chandBodyY, ambientGlowR, 0, Math.PI * 2);
            ctx.fill();

            // Bottom crystal/pendant
            ctx.fillStyle = '#E8D880';
            ctx.beginPath();
            ctx.moveTo(chandX, chandBodyY + 5);
            ctx.lineTo(chandX - 4, chandBodyY + 12);
            ctx.lineTo(chandX, chandBodyY + 20);
            ctx.lineTo(chandX + 4, chandBodyY + 12);
            ctx.closePath();
            ctx.fill();
            // Crystal sparkle
            ctx.fillStyle = `rgba(255, 255, 255, ${0.5 * interiorLightLevel + Math.sin(interiorAnimationFrame * 0.08) * 0.2 * interiorLightLevel})`;
            ctx.beginPath();
            ctx.arc(chandX - 1, chandBodyY + 10, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // ===== BED (upper-left, against back wall) =====
            const bedX = 30;
            const bedY = floorY - 10;
            const bedW = 120;
            const bedH = 50;

            // Bed legs
            ctx.fillStyle = '#5C3D2E';
            ctx.fillRect(bedX + 5, bedY + bedH - 5, 8, 15);
            ctx.fillRect(bedX + bedW - 13, bedY + bedH - 5, 8, 15);
            // Bed frame
            ctx.fillStyle = '#7B5B3A';
            ctx.fillRect(bedX, bedY, bedW, bedH);
            // Headboard
            const hbGrad = ctx.createLinearGradient(bedX, bedY - 40, bedX, bedY);
            hbGrad.addColorStop(0, '#5C3D2E');
            hbGrad.addColorStop(1, '#7B5B3A');
            ctx.fillStyle = hbGrad;
            ctx.beginPath();
            ctx.moveTo(bedX - 5, bedY);
            ctx.lineTo(bedX - 5, bedY - 35);
            ctx.quadraticCurveTo(bedX + 15, bedY - 45, bedX + 35, bedY - 35);
            ctx.lineTo(bedX + 35, bedY);
            ctx.closePath();
            ctx.fill();
            // Mattress
            ctx.fillStyle = '#FFF5EE';
            ctx.fillRect(bedX + 3, bedY + 3, bedW - 6, bedH - 10);
            // Blanket
            const blanketGrad = ctx.createLinearGradient(bedX, bedY, bedX + bedW, bedY);
            blanketGrad.addColorStop(0, '#FF85A2');
            blanketGrad.addColorStop(0.5, '#FFB6C1');
            blanketGrad.addColorStop(1, '#FF85A2');
            ctx.fillStyle = blanketGrad;
            ctx.fillRect(bedX + 35, bedY + 5, bedW - 40, bedH - 12);
            // Blanket fold line
            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(bedX + 35, bedY + 15);
            ctx.lineTo(bedX + bedW - 5, bedY + 15);
            ctx.stroke();
            // Pillow
            ctx.fillStyle = '#FFFAF0';
            ctx.beginPath();
            ctx.ellipse(bedX + 18, bedY + 18, 14, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#EEE';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.ellipse(bedX + 18, bedY + 18, 14, 10, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Footboard
            ctx.fillStyle = '#5C3D2E';
            ctx.fillRect(bedX + bedW - 5, bedY + 5, 5, bedH - 5);

            // ===== TOILET (middle area, visible - not covered by wardrobe) =====
            const toiletX = 700;
            const toiletY = floorY;

            // (bathroom area - no wall, open space)

            // Toilet base
            ctx.fillStyle = '#F5F5F5';
            ctx.beginPath();
            ctx.ellipse(toiletX, toiletY + 10, 22, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            // Toilet bowl
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.moveTo(toiletX - 18, toiletY - 25);
            ctx.lineTo(toiletX + 18, toiletY - 25);
            ctx.quadraticCurveTo(toiletX + 25, toiletY, toiletX + 20, toiletY + 8);
            ctx.lineTo(toiletX - 20, toiletY + 8);
            ctx.quadraticCurveTo(toiletX - 25, toiletY, toiletX - 18, toiletY - 25);
            ctx.fill();
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(toiletX - 18, toiletY - 25);
            ctx.lineTo(toiletX + 18, toiletY - 25);
            ctx.quadraticCurveTo(toiletX + 25, toiletY, toiletX + 20, toiletY + 8);
            ctx.lineTo(toiletX - 20, toiletY + 8);
            ctx.quadraticCurveTo(toiletX - 25, toiletY, toiletX - 18, toiletY - 25);
            ctx.stroke();
            // Seat
            ctx.fillStyle = '#FAFAFA';
            ctx.beginPath();
            ctx.ellipse(toiletX, toiletY - 12, 16, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#E0E0E0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(toiletX, toiletY - 12, 16, 10, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Water inside
            ctx.fillStyle = 'rgba(173, 216, 230, 0.5)';
            ctx.beginPath();
            ctx.ellipse(toiletX, toiletY - 12, 12, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            // Tank
            ctx.fillStyle = '#F0F0F0';
            ctx.fillRect(toiletX - 15, toiletY - 55, 30, 30);
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(toiletX - 15, toiletY - 55, 30, 30);
            // Flush handle
            ctx.strokeStyle = '#CCC';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(toiletX + 10, toiletY - 45);
            ctx.lineTo(toiletX + 20, toiletY - 48);
            ctx.stroke();
            ctx.fillStyle = '#CCC';
            ctx.beginPath();
            ctx.arc(toiletX + 20, toiletY - 48, 3, 0, Math.PI * 2);
            ctx.fill();
            // Toilet paper holder
            ctx.fillStyle = '#CCC';
            ctx.fillRect(toiletX + 30, toiletY - 30, 3, 25);
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(toiletX + 31, toiletY - 30, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#EEE';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(toiletX + 31, toiletY - 30, 10, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(toiletX + 31, toiletY - 30, 4, 0, Math.PI * 2);
            ctx.stroke();

            // ===== SINK (next to toilet) =====
            const sinkX = toiletX + 80;
            const sinkY = floorY - 60;

            // Sink pipe (going to wall)
            ctx.fillStyle = '#CCC';
            ctx.fillRect(sinkX - 3, sinkY + 40, 6, floorY - sinkY - 30);
            // Sink pedestal
            ctx.fillStyle = '#F0F0F0';
            ctx.fillRect(sinkX - 8, sinkY + 30, 16, 35);
            // Sink basin
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.ellipse(sinkX, sinkY + 15, 28, 15, 0, 0, Math.PI);
            ctx.fill();
            ctx.fillStyle = '#FAFAFA';
            ctx.beginPath();
            ctx.ellipse(sinkX, sinkY + 10, 30, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(sinkX, sinkY + 10, 30, 12, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Water in sink
            ctx.fillStyle = 'rgba(173, 216, 230, 0.3)';
            ctx.beginPath();
            ctx.ellipse(sinkX, sinkY + 11, 24, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            // Drain
            ctx.fillStyle = '#AAA';
            ctx.beginPath();
            ctx.arc(sinkX, sinkY + 13, 3, 0, Math.PI * 2);
            ctx.fill();
            // Faucet
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(sinkX - 3, sinkY - 15, 6, 20);
            // Faucet top curve
            ctx.strokeStyle = '#C0C0C0';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(sinkX, sinkY - 15, 10, Math.PI, 0);
            ctx.stroke();
            // Faucet spout
            ctx.fillStyle = '#B0B0B0';
            ctx.fillRect(sinkX + 7, sinkY - 15, 5, 10);
            // Faucet handles
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.arc(sinkX - 15, sinkY - 5, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FF4444';
            ctx.beginPath();
            ctx.arc(sinkX + 15, sinkY - 5, 5, 0, Math.PI * 2);
            ctx.fill();
            // Mirror above sink
            ctx.fillStyle = '#E8E8FF';
            ctx.beginPath();
            ctx.ellipse(sinkX, sinkY - 50, 25, 30, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#DAA520';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(sinkX, sinkY - 50, 25, 30, 0, 0, Math.PI * 2);
            ctx.stroke();
            // Mirror reflection
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.ellipse(sinkX - 8, sinkY - 55, 8, 12, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // ===== BATHTUB (next to sink, bigger) =====
            const bathtubX = sinkX + 140;
            const bathtubY = floorY;
            const bathtubW = 140;
            const bathtubH = 70;

            // Bathtub body (back half - drawn before player)
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.moveTo(bathtubX - bathtubW / 2 + 10, bathtubY - bathtubH);
            ctx.lineTo(bathtubX + bathtubW / 2 - 10, bathtubY - bathtubH);
            ctx.quadraticCurveTo(bathtubX + bathtubW / 2, bathtubY - bathtubH / 2, bathtubX + bathtubW / 2 - 5, bathtubY - 10);
            ctx.lineTo(bathtubX - bathtubW / 2 + 5, bathtubY - 10);
            ctx.quadraticCurveTo(bathtubX - bathtubW / 2, bathtubY - bathtubH / 2, bathtubX - bathtubW / 2 + 10, bathtubY - bathtubH);
            ctx.fill();
            ctx.strokeStyle = '#DDD';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Bathtub rim (top edge, thicker)
            ctx.strokeStyle = '#EEE';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(bathtubX - bathtubW / 2 + 10, bathtubY - bathtubH);
            ctx.lineTo(bathtubX + bathtubW / 2 - 10, bathtubY - bathtubH);
            ctx.stroke();

            // Bathtub legs (clawfoot style)
            ctx.fillStyle = '#C0C0C0';
            // Left leg
            ctx.beginPath();
            ctx.ellipse(bathtubX - bathtubW / 2 + 15, bathtubY - 5, 6, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            // Right leg
            ctx.beginPath();
            ctx.ellipse(bathtubX + bathtubW / 2 - 15, bathtubY - 5, 6, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Faucet/tap
            ctx.strokeStyle = '#C0C0C0';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(bathtubX - 30, bathtubY - bathtubH - 5);
            ctx.lineTo(bathtubX - 30, bathtubY - bathtubH - 20);
            ctx.lineTo(bathtubX - 10, bathtubY - bathtubH - 20);
            ctx.stroke();
            // Tap drip
            ctx.strokeStyle = '#B0B0B0';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(bathtubX - 10, bathtubY - bathtubH - 20);
            ctx.lineTo(bathtubX - 10, bathtubY - bathtubH - 16);
            ctx.stroke();

            // Tap handles (hot/cold)
            ctx.fillStyle = '#E74C3C';
            ctx.beginPath();
            ctx.arc(bathtubX - 38, bathtubY - bathtubH - 18, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#3498DB';
            ctx.beginPath();
            ctx.arc(bathtubX - 22, bathtubY - bathtubH - 18, 5, 0, Math.PI * 2);
            ctx.fill();

            // Water level indicator (stored in interiorPlayer for persistence)
            if (!interiorPlayer.bathtubWaterLevel) interiorPlayer.bathtubWaterLevel = 0;
            if (interiorPlayer.bathtubWaterLevel > 0 && interiorPlayer.action !== 'bathing') {
                const waterH = bathtubH * 0.7 * interiorPlayer.bathtubWaterLevel;
                const waterAlpha = 0.3 + interiorPlayer.bathtubWaterLevel * 0.3;
                ctx.fillStyle = `rgba(100, 180, 255, ${waterAlpha})`;
                ctx.beginPath();
                ctx.ellipse(bathtubX, bathtubY - 15 - waterH / 2, bathtubW / 2 - 10, waterH / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                // Water surface reflection
                ctx.fillStyle = `rgba(255, 255, 255, ${0.3 * interiorPlayer.bathtubWaterLevel})`;
                ctx.beginPath();
                ctx.ellipse(bathtubX - 15, bathtubY - 15 - waterH, 15, 4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Drain swirl effect (visible while draining)
                if (interiorPlayer.bathtubWaterLevel < 0.95) {
                    const swirlX = bathtubX;
                    const swirlY = bathtubY - 15 - waterH * 0.3;
                    const swirlSize = 8 * interiorPlayer.bathtubWaterLevel;
                    const swirlAngle = interiorAnimationFrame * 0.15;
                    ctx.save();
                    ctx.translate(swirlX, swirlY);
                    ctx.rotate(swirlAngle);
                    ctx.strokeStyle = `rgba(70, 150, 220, ${0.4 * interiorPlayer.bathtubWaterLevel})`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    for (let a = 0; a < Math.PI * 4; a += 0.2) {
                        const r = (a / (Math.PI * 4)) * swirlSize;
                        const sx = Math.cos(a) * r;
                        const sy = Math.sin(a) * r * 0.5;
                        if (a === 0) ctx.moveTo(sx, sy);
                        else ctx.lineTo(sx, sy);
                    }
                    ctx.stroke();
                    ctx.restore();

                    // Small bubbles rising from drain
                    for (let b = 0; b < 3; b++) {
                        const bubblePhase = (interiorAnimationFrame * 0.05 + b * 2.1) % 1;
                        const bx = swirlX + Math.sin(interiorAnimationFrame * 0.08 + b * 1.7) * 6;
                        const by = swirlY - bubblePhase * waterH * 0.6;
                        const br = 2 + Math.sin(b * 1.3) * 1;
                        const bAlpha = (1 - bubblePhase) * 0.4 * interiorPlayer.bathtubWaterLevel;
                        ctx.fillStyle = `rgba(200, 230, 255, ${bAlpha})`;
                        ctx.beginPath();
                        ctx.arc(bx, by, br, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // ===== TITLE & INFO =====
            ctx.fillStyle = '#8B4513';
            ctx.font = 'bold 28px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('üè† Dom Kicioro≈ºka üè†', canvas.width / 2, 35);

            ctx.font = 'bold 18px Comic Sans MS';
            ctx.fillStyle = '#A0764B';
            ctx.fillText(`Przyjaciele w domu: ${interiorFriends.length}`, canvas.width / 2, 60);

            // ===== CAT NEEDS ICONS (top bar) =====
            const needThreshold = 70;
            const activeNeeds = [];
            if (catNeeds.hunger >= needThreshold) activeNeeds.push({ type: 'hunger', val: catNeeds.hunger });
            if (catNeeds.sleep >= needThreshold) activeNeeds.push({ type: 'sleep', val: catNeeds.sleep });
            if (catNeeds.toilet >= needThreshold) activeNeeds.push({ type: 'toilet', val: catNeeds.toilet });
            if (catNeeds.hygiene >= needThreshold) activeNeeds.push({ type: 'hygiene', val: catNeeds.hygiene });

            if (activeNeeds.length > 0) {
                const needBarW = activeNeeds.length * 60 + 20;
                const needBarX = canvas.width / 2 - needBarW / 2;
                const needBarY = 72;

                // Background bubble
                ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                ctx.beginPath();
                ctx.roundRect(needBarX, needBarY, needBarW, 50, 12);
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 150, 180, 0.6)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(needBarX, needBarY, needBarW, 50, 12);
                ctx.stroke();

                // Thought bubble tail
                ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                ctx.beginPath();
                ctx.arc(canvas.width / 2, needBarY + 55, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(canvas.width / 2 + 5, needBarY + 62, 3, 0, Math.PI * 2);
                ctx.fill();

                activeNeeds.forEach((need, idx) => {
                    const nx = needBarX + 10 + idx * 60 + 25;
                    const ny = needBarY + 25;
                    const urgency = (need.val - needThreshold) / (100 - needThreshold); // 0-1
                    const pulse = 1 + Math.sin(interiorAnimationFrame * 0.1 + idx) * 0.08 * urgency;

                    ctx.save();
                    ctx.translate(nx, ny);
                    ctx.scale(pulse, pulse);

                    if (need.type === 'hunger') {
                        // Fish icon (cat food)
                        ctx.fillStyle = urgency > 0.7 ? '#FF4444' : '#FF8C42';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 14, 8, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Fish tail
                        ctx.beginPath();
                        ctx.moveTo(-14, 0);
                        ctx.lineTo(-22, -7);
                        ctx.lineTo(-22, 7);
                        ctx.closePath();
                        ctx.fill();
                        // Eye
                        ctx.fillStyle = '#FFF';
                        ctx.beginPath();
                        ctx.arc(6, -2, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(7, -2, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (need.type === 'sleep') {
                        // Moon + Zzz icon
                        ctx.fillStyle = urgency > 0.7 ? '#FF4444' : '#6B7EC4';
                        ctx.beginPath();
                        ctx.arc(0, 0, 12, 0, Math.PI * 2);
                        ctx.fill();
                        // Moon shadow (crescent)
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                        ctx.beginPath();
                        ctx.arc(5, -3, 10, 0, Math.PI * 2);
                        ctx.fill();
                        // Redraw crescent
                        ctx.fillStyle = urgency > 0.7 ? '#FF4444' : '#6B7EC4';
                        ctx.beginPath();
                        ctx.arc(-1, -1, 11, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                        ctx.beginPath();
                        ctx.arc(3, -4, 9, 0, Math.PI * 2);
                        ctx.fill();
                        // Small Z
                        ctx.fillStyle = urgency > 0.7 ? '#FF4444' : '#8B9DD4';
                        ctx.font = 'bold 10px Comic Sans MS';
                        ctx.textAlign = 'center';
                        ctx.fillText('z', 12, -5);
                    } else if (need.type === 'toilet') {
                        // Poop icon
                        const poopColor = urgency > 0.7 ? '#FF4444' : '#8B6914';
                        ctx.fillStyle = poopColor;
                        // Bottom swirl
                        ctx.beginPath();
                        ctx.ellipse(0, 6, 10, 6, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Middle swirl
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 8, 5, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Top swirl
                        ctx.beginPath();
                        ctx.ellipse(1, -6, 6, 4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Top tip
                        ctx.beginPath();
                        ctx.arc(3, -10, 3, 0, Math.PI * 2);
                        ctx.fill();
                        // Eyes
                        ctx.fillStyle = '#FFF';
                        ctx.beginPath();
                        ctx.arc(-3, -1, 2.5, 0, Math.PI * 2);
                        ctx.arc(4, -1, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(-3, -1, 1, 0, Math.PI * 2);
                        ctx.arc(4, -1, 1, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (need.type === 'hygiene') {
                        // Shower icon
                        const showerColor = urgency > 0.7 ? '#FF4444' : '#5DADE2';
                        // Shower head
                        ctx.fillStyle = '#999';
                        ctx.beginPath();
                        ctx.roundRect(-8, -14, 16, 6, 2);
                        ctx.fill();
                        // Shower pipe
                        ctx.fillStyle = '#AAA';
                        ctx.fillRect(6, -14, 3, -6);
                        ctx.fillRect(6, -20, 10, 3);
                        // Water drops
                        ctx.fillStyle = showerColor;
                        for (let wd = 0; wd < 5; wd++) {
                            const wdx = -6 + wd * 3;
                            const wdy = -5 + (wd % 2) * 3;
                            ctx.beginPath();
                            ctx.moveTo(wdx, wdy);
                            ctx.quadraticCurveTo(wdx + 2, wdy + 4, wdx, wdy + 7);
                            ctx.quadraticCurveTo(wdx - 2, wdy + 4, wdx, wdy);
                            ctx.fill();
                        }
                    }

                    ctx.restore();
                });
            }

            // ===== UPDATE & DRAW FRIENDS =====
            updateInteriorFriends();
            interiorFriends.forEach(friend => {
                drawInteriorFriend(friend);
            });

            // ===== INTERIOR PLAYER MOVEMENT & INTERACTIONS =====
            updateInteriorPlayer(floorY, bedX, bedW, toiletX, sinkX, bathtubX);

            // ===== DRAW PLAYER IN INTERIOR =====
            drawInteriorPlayer(floorY, bedX, bedY, bedW, bedH);

            // ===== INTERACTION HINTS =====
            drawInteriorHints(bedX, bedW, toiletX, sinkX, bathtubX, floorY);

            // ===== CONVERSATIONS =====
            updateConversation();
            drawConversation();

            // ===== NIGHT DIMMING OVERLAY (when sleeping) =====
            if (interiorLightLevel < 1.0) {
                const darkness = 1.0 - interiorLightLevel;
                // Dark blue overlay for nighttime feel
                ctx.fillStyle = `rgba(10, 10, 40, ${darkness * 0.7})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Window weather is already reflected in the window drawing above
            }
        }

        // Furniture targets for friends - X positions and IDs
        const furnitureSpots = {
            using_toilet: { x: 700, id: 'toilet' },
            watching_tv: { x: 200, id: 'tv' },
            couch_sleeping: { x: 400, id: 'couch' },
            playing_ball: { x: 0, id: 'ball' }, // x set dynamically
            friend_eating: { x: 510, id: 'bowls' }
        };

        function isFurnitureOccupied(spotId, excludeFriend) {
            // Check if player is using it
            if (spotId === 'toilet' && interiorPlayer.action === 'toilet') return true;
            if (spotId === 'tv' && interiorPlayer.action === 'playing') return true;
            if (spotId === 'couch' && (interiorPlayer.action === 'couch_rest' || interiorPlayer.action === 'sleeping')) return true;
            if (spotId === 'ball' && interiorPlayer.action === 'playing') return true;
            if (spotId === 'bowls' && interiorPlayer.action === 'eating') return true;
            // Check if another friend is using or walking to it
            for (const f of interiorFriends) {
                if (f === excludeFriend) continue;
                if (f.furnitureTarget === spotId) return true;
            }
            return false;
        }

        function countFriendsUsingFurniture() {
            let count = 0;
            for (const f of interiorFriends) {
                if (f.furnitureTarget) count++;
            }
            return count;
        }

        function updateInteriorFriends() {
            const floorY = canvas.height - 180;
            const walkSpeed = 1.5;
            furnitureSpots.playing_ball.x = 1020;

            interiorFriends.forEach(friend => {
                friend.activityTimer--;
                friend.animFrame++;

                // Change activity when timer runs out
                if (friend.activityTimer <= 0) {
                    friend.furnitureTarget = null; // Clear any furniture claim

                    // Decide next activity - mostly walking, sometimes furniture
                    const roll = Math.random();
                    let nextActivity = 'walking';

                    if (roll > 0.6 && countFriendsUsingFurniture() < 2) {
                        // Try a furniture activity
                        const furnitureOptions = ['using_toilet', 'watching_tv', 'couch_sleeping', 'playing_ball', 'friend_eating'];
                        // Shuffle and pick first available
                        const shuffled = furnitureOptions.sort(() => Math.random() - 0.5);
                        for (const opt of shuffled) {
                            if (!isFurnitureOccupied(furnitureSpots[opt].id, friend)) {
                                nextActivity = 'walking_to';
                                friend.targetActivity = opt;
                                friend.walkTargetX = furnitureSpots[opt].x;
                                friend.furnitureTarget = furnitureSpots[opt].id;
                                break;
                            }
                        }
                        if (nextActivity !== 'walking_to') {
                            nextActivity = 'walking'; // All furniture busy
                        }
                    } else if (roll > 0.5) {
                        nextActivity = 'jumping';
                    }

                    friend.activity = nextActivity;

                    if (friend.activity === 'walking') {
                        friend.activityTimer = 100 + Math.floor(Math.random() * 100);
                        friend.velX = (Math.random() > 0.5 ? 1 : -1) * (1 + Math.random());
                    } else if (friend.activity === 'jumping') {
                        friend.activityTimer = 80 + Math.floor(Math.random() * 60);
                        friend.jumpPower = -10;
                    } else if (friend.activity === 'walking_to') {
                        friend.activityTimer = 500; // Max time to reach target
                    }
                }

                // Activity behaviors
                if (friend.activity === 'walking') {
                    friend.x += friend.velX;
                    friend.y = floorY - 20;
                    if (friend.x < 50 || friend.x > canvas.width - 50) {
                        friend.velX *= -1;
                        friend.x = Math.max(50, Math.min(canvas.width - 50, friend.x));
                    }
                } else if (friend.activity === 'walking_to') {
                    // Walk toward target
                    friend.y = floorY - 20;
                    const dx = friend.walkTargetX - friend.x;
                    if (Math.abs(dx) < walkSpeed + 1) {
                        // Arrived! Switch to actual activity
                        friend.x = friend.walkTargetX;
                        friend.activity = friend.targetActivity;
                        if (friend.activity === 'using_toilet') {
                            friend.activityTimer = 120 + Math.floor(Math.random() * 60);
                        } else if (friend.activity === 'watching_tv') {
                            friend.activityTimer = 150 + Math.floor(Math.random() * 100);
                        } else if (friend.activity === 'couch_sleeping') {
                            friend.activityTimer = 200 + Math.floor(Math.random() * 100);
                        } else if (friend.activity === 'playing_ball') {
                            friend.activityTimer = 100 + Math.floor(Math.random() * 80);
                        } else if (friend.activity === 'friend_eating') {
                            friend.activityTimer = 90 + Math.floor(Math.random() * 60);
                        }
                    } else {
                        friend.velX = dx > 0 ? walkSpeed : -walkSpeed;
                        friend.x += friend.velX;
                    }
                } else if (friend.activity === 'jumping') {
                    friend.velY += 0.6;
                    friend.y += friend.velY;
                    if (friend.y >= floorY - 20) {
                        friend.y = floorY - 20;
                        friend.velY = 0;
                        if (friend.jumpPower < 0) {
                            friend.velY = friend.jumpPower;
                            friend.jumpPower = 0;
                        }
                    }
                } else if (friend.activity === 'playing_ball') {
                    friend.y = floorY - 20 + Math.sin(friend.animFrame * 0.15) * 6;
                }
                // using_toilet, watching_tv, couch_sleeping: stay in place
            });
        }

        function drawInteriorFriend(friend) {
            ctx.save();

            const drawFunctions = {
                'üê∂': drawDog,
                'üê∞': drawRabbit,
                'üêª': drawBear,
                'üêë': drawSheep,
                'üê¨': drawDolphin,
                'ü¶ä': drawFox,
                'üêº': drawPanda,
                'ü¶Ñ': drawUnicorn,
                'üê∏': drawFrog,
                'ü¶ã': drawButterfly
            };

            const drawFunction = drawFunctions[friend.type.emoji] || drawDog;

            if (friend.activity === 'walking' || friend.activity === 'walking_to') {
                // Walking animation - bob up/down and tilt
                const walkBob = Math.sin(friend.animFrame * 0.3) * 2;
                const walkTilt = Math.sin(friend.animFrame * 0.15) * 0.05;
                ctx.translate(friend.x, friend.y + walkBob);
                ctx.rotate(walkTilt);
                if (friend.velX < 0) ctx.scale(-1, 1);
                drawFunction(0, 0, 1);
            } else if (friend.activity === 'using_toilet') {
                // Sitting on toilet - draw smaller, sitting
                ctx.save();
                ctx.translate(friend.x, friend.y + 5);
                ctx.scale(0.7, 0.7);
                drawFunction(0, 0, 1);
                ctx.restore();
                // Newspaper
                ctx.fillStyle = '#F5F5DC';
                ctx.fillRect(friend.x + 12, friend.y + 5, 12, 16);
                ctx.strokeStyle = '#CCC';
                ctx.lineWidth = 0.5;
                for (let l = 0; l < 3; l++) {
                    ctx.beginPath();
                    ctx.moveTo(friend.x + 14, friend.y + 9 + l * 4);
                    ctx.lineTo(friend.x + 22, friend.y + 9 + l * 4);
                    ctx.stroke();
                }
            } else if (friend.activity === 'watching_tv') {
                // Sitting in front of TV
                drawFunction(friend.x, friend.y, 1);
                // Eyes glowing from TV light
                const tvGlow = Math.sin(friend.animFrame * 0.05) * 0.3 + 0.5;
                ctx.fillStyle = `rgba(100, 200, 255, ${tvGlow})`;
                ctx.beginPath();
                ctx.arc(friend.x - 3, friend.y + 8, 3, 0, Math.PI * 2);
                ctx.arc(friend.x + 5, friend.y + 8, 3, 0, Math.PI * 2);
                ctx.fill();
            } else if (friend.activity === 'couch_sleeping') {
                // Lying on couch - rotated
                ctx.save();
                ctx.translate(friend.x, friend.y - 15);
                ctx.rotate(-Math.PI / 2);
                ctx.scale(0.55, 0.55);
                drawFunction(0, 0, 1);
                ctx.restore();
                // Zzz
                const zt = friend.animFrame * 0.02;
                for (let z = 0; z < 2; z++) {
                    const zOff = ((zt + z * 0.8) % 1.5);
                    const zAlpha = Math.max(0, 1 - zOff / 1.5);
                    ctx.fillStyle = `rgba(100, 100, 200, ${zAlpha * 0.5})`;
                    ctx.font = `bold ${8 + z * 3 + zOff * 5}px Comic Sans MS`;
                    ctx.textAlign = 'center';
                    ctx.fillText('z', friend.x + 10 + zOff * 10 + z * 5, friend.y - 25 - zOff * 15);
                }
            } else if (friend.activity === 'friend_eating') {
                // Eating at bowls - food to mouth animation
                drawFunction(friend.x, friend.y, 1);
                const eatCycle = (friend.animFrame % 35) / 35;
                const bowlLevel = friend.y + 8;
                const mouthLevel = friend.y - 12;
                const foodPX = friend.x + 8 - eatCycle * 4;
                const foodPY = bowlLevel + (mouthLevel - bowlLevel) * eatCycle - Math.sin(eatCycle * Math.PI) * 10;
                const fAlpha = eatCycle < 0.85 ? 1 : (1 - (eatCycle - 0.85) / 0.15);
                ctx.globalAlpha = fAlpha;
                const fColors = ['#8B4513', '#FF6347', '#FFD700', '#32CD32'];
                ctx.fillStyle = fColors[Math.floor(friend.animFrame / 35) % fColors.length];
                ctx.beginPath();
                ctx.arc(foodPX, foodPY, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                // Chewing cheeks
                if (eatCycle > 0.85 || eatCycle < 0.1) {
                    const chew = Math.sin(friend.animFrame * 0.5) * 1.5;
                    ctx.fillStyle = 'rgba(255, 180, 180, 0.4)';
                    ctx.beginPath();
                    ctx.arc(friend.x - 5, mouthLevel + 2, 3 + chew, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(friend.x + 5, mouthLevel + 2, 3 - chew, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Crumbs
                for (let cr = 0; cr < 2; cr++) {
                    const crP = ((friend.animFrame * 0.06 + cr * 0.5) % 1);
                    if (crP < 0.5) {
                        ctx.fillStyle = `rgba(139, 69, 19, ${0.5 * (1 - crP / 0.5)})`;
                        ctx.beginPath();
                        ctx.arc(friend.x - 2 + cr * 4, mouthLevel + 3 + crP * 18, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            } else if (friend.activity === 'playing_ball') {
                // Bouncing with ball
                drawFunction(friend.x, friend.y, 1);
                // Small ball bouncing
                const ballY = friend.y - 25 - Math.abs(Math.sin(friend.animFrame * 0.12)) * 20;
                ctx.fillStyle = '#FF4444';
                ctx.beginPath();
                ctx.arc(friend.x + 5, ballY, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFFF44';
                ctx.fillRect(friend.x + 5 - 6, ballY - 1, 12, 2);
            } else if (friend.activity === 'talking') {
                // Talking - face the player, slight head bob
                const facingLeft = interiorPlayer.x < friend.x;
                ctx.save();
                ctx.translate(friend.x, friend.y);
                if (facingLeft) ctx.scale(-1, 1);
                const bob = Math.sin(friend.animFrame * 0.1) * 2;
                ctx.translate(0, bob);
                drawFunction(0, 0, 1);
                ctx.restore();
            } else {
                drawFunction(friend.x, friend.y, 1);
            }

            ctx.restore();
        }

        // ========== CONVERSATION SYSTEM ==========

        const animalDialogs = {
            'üê∂': {
                name: 'Piesek',
                lines: [
                    ['Hau hau! Cze≈õƒá!', 'Cze≈õƒá Piesku!'],
                    ['Chcesz siƒô pobawiƒá?', 'Jasne!'],
                    ['Lubiƒô biegaƒá po ≈ÇƒÖce!', 'Ja te≈º!'],
                    ['Masz co≈õ do jedzenia?', 'Sprawd≈∫ miskƒô!'],
                    ['Jeste≈õ moim najlepszym przyjacielem!', 'Ty te≈º!']
                ]
            },
            'üê∞': {
                name: 'Kr√≥liczek',
                lines: [
                    ['*rusza noskiem* Cze≈õƒá!', 'Hej Kr√≥liczku!'],
                    ['Masz marchewkƒô?', 'Niestety nie...'],
                    ['Lubiƒô skakaƒá!', 'Widzƒô!'],
                    ['Moje uszka s≈ÇyszƒÖ wszystko!', 'Super moc!'],
                    ['Chcƒô siƒô przytuliƒá!', 'Chod≈∫ tutaj!']
                ]
            },
            'üêª': {
                name: 'Mi≈õ',
                lines: [
                    ['Mrrrr, cze≈õƒá!', 'Hej Misiu!'],
                    ['Lubiƒô mi√≥d!', 'Ja te≈º!'],
                    ['Czy jest pora na drzemkƒô?', 'Kanapa czeka!'],
                    ['Jestem silny!', 'Najsilniejszy!'],
                    ['Przytulisz mnie?', 'Oczywi≈õcie!']
                ]
            },
            'üêë': {
                name: 'Owieczka',
                lines: [
                    ['Beee! Dzie≈Ñ dobry!', 'Cze≈õƒá Owieczko!'],
                    ['Moja we≈Çna jest miƒôkka!', 'Mogƒô dotknƒÖƒá?'],
                    ['Lubiƒô trawkƒô!', 'Smaczna?'],
                    ['Policzysz mnie do snu?', 'Raz, dwa, trzy...'],
                    ['Beee beee!', 'Beee!']
                ]
            },
            'üê¨': {
                name: 'Delfinek',
                lines: [
                    ['*klik klik* Cze≈õƒá!', 'Hej Delfinku!'],
                    ['Tƒôskniƒô za morzem...', 'Wanna jest blisko!'],
                    ['Umiem robiƒá salta!', 'Poka≈º!'],
                    ['Klik klik klik!', 'Co m√≥wisz?'],
                    ['Lubiƒô p≈Çywaƒá!', 'Ja te≈º!']
                ]
            },
            'ü¶ä': {
                name: 'Lisek',
                lines: [
                    ['Hej hej!', 'Cze≈õƒá Lisku!'],
                    ['Jestem bardzo sprytny!', 'Wiem!'],
                    ['M√≥j ogon jest puszysty!', 'Piƒôkny!'],
                    ['Lubiƒô siƒô chowaƒá!', 'Znajdƒô ciƒô!'],
                    ['Znalaz≈Çem co≈õ ciekawego!', 'Co?!']
                ]
            },
            'üêº': {
                name: 'Panda',
                lines: [
                    ['*je bambusa* Cze≈õƒá!', 'Hej Pando!'],
                    ['Lubiƒô bambusa!', 'Smacznego!'],
                    ['Jestem czarno-bia≈Ça!', 'I piƒôkna!'],
                    ['*przewraca siƒô* Ups!', 'Haha!'],
                    ['Chcƒô siƒô przytuliƒá!', 'Chod≈∫!']
                ]
            },
            'ü¶Ñ': {
                name: 'Jednoro≈ºec',
                lines: [
                    ['‚ú® Witaj!', 'Hej!'],
                    ['M√≥j r√≥g ≈õwieci!', 'Piƒôknie!'],
                    ['Lubiƒô tƒôcze!', 'Ja te≈º!'],
                    ['Jestem magiczny!', 'Wierzƒô!'],
                    ['*posypuje brokatem*', 'B≈Çyszczy!']
                ]
            },
            'üê∏': {
                name: '≈ªabka',
                lines: [
                    ['Kum kum!', 'Cze≈õƒá ≈ªabko!'],
                    ['Lubiƒô deszcz!', 'Ja nie za bardzo...'],
                    ['Z≈Çapiƒô muchƒô!', 'Szybka jeste≈õ!'],
                    ['Kum kum kum!', 'Kum!'],
                    ['Chcesz skoczyƒá ze mnƒÖ?', 'Jasne!']
                ]
            },
            'ü¶ã': {
                name: 'Motyl',
                lines: [
                    ['*trzepocze skrzyd≈Çami*', 'Piƒôkne!'],
                    ['Lubiƒô kwiaty!', 'Ja te≈º!'],
                    ['Moje skrzyd≈Ça majƒÖ wzory!', 'Cudowne!'],
                    ['Frrr frrr!', 'Lataj dalej!'],
                    ['UsiƒÖdƒô ci na nosie!', 'Haha ≈Çaskocze!']
                ]
            }
        };

        function startAnimalConversation(friend) {
            const emoji = friend.type.emoji || friend.type;
            const dialogSet = animalDialogs[emoji] || animalDialogs['üê∂'];
            const randomLine = dialogSet.lines[Math.floor(Math.random() * dialogSet.lines.length)];

            activeConversation = {
                friend: friend,
                friendName: dialogSet.name,
                friendLine: randomLine[0],
                playerLine: randomLine[1],
                phase: 'friend_talking', // friend_talking -> player_talking -> done
                timer: 150, // ~2.5 seconds for friend to speak
                friendX: friend.x,
                friendY: friend.y
            };

            // Stop friend from moving during conversation
            friend.activity = 'talking';
            friend.activityTimer = 500; // Long enough for full conversation
        }

        function updateConversation() {
            if (!activeConversation) return;

            activeConversation.timer--;

            if (activeConversation.timer <= 0) {
                if (activeConversation.phase === 'friend_talking') {
                    activeConversation.phase = 'player_talking';
                    activeConversation.timer = 150; // ~2.5 seconds for player response
                } else if (activeConversation.phase === 'player_talking') {
                    activeConversation.phase = 'done';
                    activeConversation.timer = 60; // hearts floating
                } else {
                    // Conversation over
                    if (activeConversation.friend) {
                        activeConversation.friend.activity = 'walking';
                        activeConversation.friend.activityTimer = 100 + Math.floor(Math.random() * 100);
                        activeConversation.friend.velX = (Math.random() > 0.5 ? 1 : -1) * (1 + Math.random());
                    }
                    activeConversation = null;
                }
            }
        }

        function drawConversation() {
            if (!activeConversation) return;

            const conv = activeConversation;
            // Use LIVE positions from friend and player, not stored ones
            const friend = conv.friend;
            const fx = friend ? friend.x : conv.friendX;
            const fy = friend ? friend.y : conv.friendY;
            const px = interiorPlayer.x;
            const py = interiorPlayer.y;

            ctx.save();

            if (conv.phase === 'friend_talking' || conv.phase === 'player_talking') {
                // Always show the friend's bubble in both phases
                const friendText = conv.friendLine;
                ctx.font = 'bold 13px Comic Sans MS';
                const ftw = ctx.measureText(friendText).width + 24;
                const fbx = fx - ftw / 2;
                // Offset friend bubble higher if player bubble also showing
                const friendBubbleY = conv.phase === 'player_talking' ? fy - 75 : fy - 65;

                // Friend bubble
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.beginPath();
                ctx.roundRect(fbx, friendBubbleY, ftw, 30, 8);
                ctx.fill();
                ctx.strokeStyle = '#FF85A2';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(fbx, friendBubbleY, ftw, 30, 8);
                ctx.stroke();

                // Tail pointing to friend
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.beginPath();
                ctx.moveTo(fx - 5, friendBubbleY + 30);
                ctx.lineTo(fx, friendBubbleY + 40);
                ctx.lineTo(fx + 5, friendBubbleY + 30);
                ctx.fill();
                ctx.strokeStyle = '#FF85A2';
                ctx.beginPath();
                ctx.moveTo(fx - 5, friendBubbleY + 30);
                ctx.lineTo(fx, friendBubbleY + 40);
                ctx.lineTo(fx + 5, friendBubbleY + 30);
                ctx.stroke();

                // Friend text
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.fillText(friendText, fx, friendBubbleY + 20);

                // Friend name label
                ctx.font = 'bold 10px Comic Sans MS';
                ctx.fillStyle = '#FF85A2';
                ctx.fillText(conv.friendName, fx, friendBubbleY - 3);

                // Player speech bubble (only in player_talking phase)
                if (conv.phase === 'player_talking') {
                    const playerText = conv.playerLine;
                    ctx.font = 'bold 13px Comic Sans MS';
                    const ptw = ctx.measureText(playerText).width + 24;
                    const pbx = px - ptw / 2;
                    const playerBubbleY = py - 65;

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    ctx.beginPath();
                    ctx.roundRect(pbx, playerBubbleY, ptw, 30, 8);
                    ctx.fill();
                    ctx.strokeStyle = '#85A2FF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.roundRect(pbx, playerBubbleY, ptw, 30, 8);
                    ctx.stroke();

                    // Tail pointing to player
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    ctx.beginPath();
                    ctx.moveTo(px - 5, playerBubbleY + 30);
                    ctx.lineTo(px, playerBubbleY + 40);
                    ctx.lineTo(px + 5, playerBubbleY + 30);
                    ctx.fill();
                    ctx.strokeStyle = '#85A2FF';
                    ctx.beginPath();
                    ctx.moveTo(px - 5, playerBubbleY + 30);
                    ctx.lineTo(px, playerBubbleY + 40);
                    ctx.lineTo(px + 5, playerBubbleY + 30);
                    ctx.stroke();

                    ctx.fillStyle = '#333';
                    ctx.textAlign = 'center';
                    ctx.fillText(playerText, px, playerBubbleY + 20);

                    ctx.font = 'bold 10px Comic Sans MS';
                    ctx.fillStyle = '#85A2FF';
                    ctx.fillText('Kicioro≈ºek', px, playerBubbleY - 3);
                }
            } else if (conv.phase === 'done') {
                // Hearts floating up between both characters
                const midX = (fx + px) / 2;
                const midY = Math.min(fy, py);
                const t = (60 - conv.timer) / 60;
                for (let h = 0; h < 3; h++) {
                    const hx = midX + Math.sin(t * 5 + h * 2) * 20;
                    const hy = midY - 40 - t * 40 - h * 15;
                    ctx.globalAlpha = Math.max(0, 1 - t);
                    ctx.font = `${14 + h * 2}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText('‚ù§Ô∏è', hx, hy);
                }
                ctx.globalAlpha = 1;
            }

            ctx.restore();
        }

        // ========== INTERIOR PLAYER SYSTEM ==========

        function updateInteriorPlayer(floorY, bedX, bedW, toiletX, sinkX, bathtubX) {
            // Smoothly transition light level based on sleeping state
            if (interiorPlayer.action === 'sleeping') {
                interiorLightLevel = Math.max(0.15, interiorLightLevel - 0.015);
            } else {
                interiorLightLevel = Math.min(1.0, interiorLightLevel + 0.02);
            }

            // Needs are updated based on steps walked (see world update + interior movement)

            // Drain bathtub water when draining action is active
            if (interiorPlayer.action === 'draining_water' && interiorPlayer.bathtubWaterLevel > 0) {
                interiorPlayer.bathtubWaterLevel = Math.max(0, interiorPlayer.bathtubWaterLevel - 0.012);
                if (interiorPlayer.bathtubWaterLevel <= 0) {
                    interiorPlayer.action = 'none';
                }
            }

            // If performing an action, count down the timer
            if (interiorPlayer.action !== 'none') {
                // Bathing: exit with arrow keys
                if (interiorPlayer.action === 'bathing') {
                    if (keys['ArrowLeft'] || keys['a'] || keys['A'] || keys['ArrowRight'] || keys['d'] || keys['D']) {
                        catNeeds.hygiene = 0;
                        interiorPlayer.bathFoam = false;
                        interiorPlayer.action = 'none';
                    }
                    return;
                }

                // Draining: don't move while draining
                if (interiorPlayer.action === 'draining_water') return;

                interiorPlayer.actionTimer--;
                if (interiorPlayer.actionTimer <= 0) {
                    if (interiorPlayer.action === 'filling_water') {
                        // Finished filling - increase water level
                        if (!interiorPlayer.bathtubWaterLevel) interiorPlayer.bathtubWaterLevel = 0;
                        interiorPlayer.bathtubWaterLevel = Math.min(1, interiorPlayer.bathtubWaterLevel + 0.34);
                        interiorPlayer.action = 'none';
                    } else if (interiorPlayer.action !== 'sleeping' && interiorPlayer.action !== 'couch_rest') {
                        // Satisfy the corresponding need when action finishes
                        if (interiorPlayer.action === 'eating') catNeeds.hunger = 0;
                        if (interiorPlayer.action === 'toilet') catNeeds.toilet = 0;
                        if (interiorPlayer.action === 'washing') catNeeds.hygiene = Math.max(0, catNeeds.hygiene - 50);
                        interiorPlayer.action = 'none';
                    }
                }
                return; // Don't move while doing an action
            }

            // Movement with arrow keys / A,D
            const speed = 4;
            let interiorMoving = false;
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                interiorPlayer.x -= speed;
                player.facingRight = false;
                interiorMoving = true;
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                interiorPlayer.x += speed;
                player.facingRight = true;
                interiorMoving = true;
            }

            // Animate walk cycle when moving + count steps
            if (interiorMoving) {
                player.walkCycle += 0.2;
                catStepCounter++;
                if (catStepCounter % 50 === 0) {
                    catNeeds.hunger = Math.min(100, catNeeds.hunger + 8);
                    catNeeds.sleep = Math.min(100, catNeeds.sleep + 5);
                    catNeeds.toilet = Math.min(100, catNeeds.toilet + 10);
                    catNeeds.hygiene = Math.min(100, catNeeds.hygiene + 6);
                }
            }

            // Clamp to room bounds
            interiorPlayer.x = Math.max(30, Math.min(canvas.width - 30, interiorPlayer.x));
            interiorPlayer.y = floorY - 20;
        }

        function drawInteriorPlayer(floorY, bedX, bedY, bedW, bedH) {
            ctx.save();

            if (interiorPlayer.action === 'sleeping') {
                // Draw player lying in bed
                const sleepX = bedX + 50;
                const sleepY = bedY + 10;

                // Draw player horizontally (rotated to left side)
                ctx.save();
                ctx.translate(sleepX, sleepY);
                ctx.rotate(-Math.PI / 2); // Lying on left side (facing down)
                ctx.scale(0.7, 0.7);
                drawPlayer(0, 0);
                ctx.restore();

                // Blanket covering player
                ctx.fillStyle = 'rgba(255, 133, 162, 0.6)';
                ctx.fillRect(bedX + 40, bedY + 15, bedW - 48, bedH - 22);

                // Zzz animation
                const zzzTime = interiorAnimationFrame * 0.03;
                for (let i = 0; i < 3; i++) {
                    const zOffset = ((zzzTime + i * 0.8) % 2.4);
                    const zAlpha = Math.max(0, 1 - zOffset / 2.4);
                    const zSize = 14 + i * 4 + zOffset * 8;
                    const zx = sleepX + 10 + zOffset * 15 + i * 8;
                    const zy = sleepY - 15 - zOffset * 25;

                    ctx.fillStyle = `rgba(100, 100, 200, ${zAlpha * 0.8})`;
                    ctx.font = `bold ${zSize}px Comic Sans MS`;
                    ctx.textAlign = 'center';
                    ctx.fillText('Z', zx, zy);
                }

            } else if (interiorPlayer.action === 'toilet') {
                // Draw player sitting on toilet
                const tx = interiorPlayer.x;
                const ty = interiorPlayer.y - 15;
                ctx.save();
                ctx.scale(0.8, 0.8);
                ctx.translate(tx * 0.25, ty * 0.25 + 5);
                drawPlayer(tx, ty);
                ctx.restore();

                // Reading newspaper
                ctx.fillStyle = '#F5F5DC';
                ctx.fillRect(tx + 15, ty + 5, 20, 25);
                ctx.strokeStyle = '#AAA';
                ctx.lineWidth = 1;
                ctx.strokeRect(tx + 15, ty + 5, 20, 25);
                // Newspaper lines
                ctx.strokeStyle = '#CCC';
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.moveTo(tx + 17, ty + 12 + i * 5);
                    ctx.lineTo(tx + 33, ty + 12 + i * 5);
                    ctx.stroke();
                }

                // Timer indicator
                if (interiorPlayer.actionTimer > 0) {
                    const prog = 1 - interiorPlayer.actionTimer / 120;
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.beginPath();
                    ctx.roundRect(tx - 25, ty - 35, 50, 18, 5);
                    ctx.fill();
                    // Progress bar
                    ctx.fillStyle = '#90EE90';
                    ctx.beginPath();
                    ctx.roundRect(tx - 22, ty - 32, 44 * prog, 12, 3);
                    ctx.fill();
                }

            } else if (interiorPlayer.action === 'washing') {
                // Draw player at sink
                const wx = interiorPlayer.x;
                const wy = interiorPlayer.y;
                drawPlayer(wx, wy);

                // Water splash particles
                for (let i = 0; i < 5; i++) {
                    const splashX = wx + 10 + Math.sin(interiorAnimationFrame * 0.2 + i * 1.5) * 10;
                    const splashY = wy - 10 - Math.abs(Math.sin(interiorAnimationFrame * 0.15 + i)) * 15;
                    ctx.fillStyle = `rgba(100, 180, 255, ${0.5 + Math.sin(interiorAnimationFrame * 0.1 + i) * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(splashX, splashY, 2 + Math.sin(interiorAnimationFrame * 0.1 + i) * 1, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Soap bubbles
                for (let i = 0; i < 4; i++) {
                    const bx = wx + Math.sin(interiorAnimationFrame * 0.04 + i * 2) * 20;
                    const by = wy - 20 - ((interiorAnimationFrame * 0.5 + i * 15) % 40);
                    const br = 3 + Math.sin(i) * 1.5;
                    ctx.strokeStyle = 'rgba(200, 220, 255, 0.6)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(bx, by, br, 0, Math.PI * 2);
                    ctx.stroke();
                    // Bubble highlight
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(bx - 1, by - 1, br * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Timer
                if (interiorPlayer.actionTimer > 0) {
                    const prog = 1 - interiorPlayer.actionTimer / 90;
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.beginPath();
                    ctx.roundRect(wx - 25, wy - 55, 50, 18, 5);
                    ctx.fill();
                    ctx.fillStyle = '#87CEEB';
                    ctx.beginPath();
                    ctx.roundRect(wx - 22, wy - 52, 44 * prog, 12, 3);
                    ctx.fill();
                }

            } else if (interiorPlayer.action === 'filling_water') {
                // Draw player at bathtub filling water
                const fx = interiorPlayer.x;
                const fy = interiorPlayer.y;
                drawPlayer(fx, fy);

                // Water stream from tap
                for (let i = 0; i < 8; i++) {
                    const streamX = fx - 20 + Math.sin(interiorAnimationFrame * 0.3 + i * 0.5) * 2;
                    const streamY = fy - 50 + i * 5;
                    ctx.fillStyle = `rgba(100, 180, 255, ${0.6 - i * 0.05})`;
                    ctx.beginPath();
                    ctx.arc(streamX, streamY, 3 - i * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Splash particles at water surface
                for (let i = 0; i < 5; i++) {
                    const splashX = fx + Math.sin(interiorAnimationFrame * 0.2 + i * 1.3) * 20;
                    const splashY = fy - 10 - Math.abs(Math.sin(interiorAnimationFrame * 0.25 + i)) * 8;
                    ctx.fillStyle = `rgba(100, 180, 255, ${0.5 + Math.sin(interiorAnimationFrame * 0.1 + i) * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(splashX, splashY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Progress indicator
                const waterProgress = 1 - interiorPlayer.actionTimer / 30;
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.beginPath();
                ctx.roundRect(fx - 30, fy - 70, 60, 18, 5);
                ctx.fill();
                ctx.fillStyle = '#87CEEB';
                ctx.beginPath();
                ctx.roundRect(fx - 27, fy - 67, 54 * waterProgress, 12, 3);
                ctx.fill();
                // Water drop icon
                ctx.font = '14px Arial';
                ctx.fillText('üíß', fx - 10, fy - 58);

            } else if (interiorPlayer.action === 'draining_water') {
                // Draw player near bathtub draining water
                const dx = interiorPlayer.x;
                const dy = interiorPlayer.y;
                drawPlayer(dx, dy);

                // Drain progress bar
                const drainProgress = 1 - (interiorPlayer.bathtubWaterLevel || 0);
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.beginPath();
                ctx.roundRect(dx - 30, dy - 70, 60, 18, 5);
                ctx.fill();
                ctx.fillStyle = '#87CEEB';
                ctx.beginPath();
                ctx.roundRect(dx - 27, dy - 67, 54 * drainProgress, 12, 3);
                ctx.fill();

                // Drain icon
                ctx.font = '12px Comic Sans MS';
                ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
                ctx.textAlign = 'center';
                ctx.fillText('Spuszczanie wody...', dx, dy - 78);

            } else if (interiorPlayer.action === 'bathing') {
                // Draw player in bathtub - upper half visible above water
                const floorY = canvas.height - 180;
                const bathtubH = 70;
                const bathtubW = 140;
                // Bathtub center: sinkX(780) + 140 = 920
                const tubCenterX = 920;
                const tubTopY = floorY - bathtubH; // Top rim of tub
                const waterSurfaceY = tubTopY + 18; // Water just below rim

                // Draw upper half of player clipped at water line
                // Player is placed inside the tub, centered
                const playerDrawX = tubCenterX - 30; // drawPlayer x (left edge of 60px wide player)
                const playerDrawY = waterSurfaceY - 45; // Position so head+torso show above water

                ctx.save();
                // Clip: show only above water line, no visible border
                ctx.beginPath();
                ctx.rect(tubCenterX - bathtubW / 2 + 5, tubTopY - 100, bathtubW - 10, waterSurfaceY - tubTopY + 100);
                ctx.clip();
                // Clear any stroke/fill that could outline the clip
                ctx.strokeStyle = 'transparent';
                ctx.lineWidth = 0;
                ctx.save();
                ctx.scale(0.7, 0.7);
                drawPlayer(playerDrawX / 0.7, playerDrawY / 0.7);
                ctx.restore();
                ctx.restore();

                // Water in tub (drawn over player's lower body)
                const waterAlpha = 0.45 + Math.sin(interiorAnimationFrame * 0.04) * 0.05;
                ctx.fillStyle = `rgba(100, 180, 255, ${waterAlpha})`;
                ctx.beginPath();
                // Wavy water surface
                ctx.moveTo(tubCenterX - bathtubW / 2 + 12, waterSurfaceY);
                for (let wx = 0; wx <= bathtubW - 24; wx += 8) {
                    const waveY = waterSurfaceY + Math.sin(interiorAnimationFrame * 0.08 + wx * 0.1) * 2;
                    ctx.lineTo(tubCenterX - bathtubW / 2 + 12 + wx, waveY);
                }
                ctx.lineTo(tubCenterX + bathtubW / 2 - 12, floorY - 15);
                ctx.lineTo(tubCenterX - bathtubW / 2 + 12, floorY - 15);
                ctx.closePath();
                ctx.fill();

                // Water surface highlights
                ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
                for (let i = 0; i < 3; i++) {
                    const hlX = tubCenterX - 25 + i * 25 + Math.sin(interiorAnimationFrame * 0.06 + i) * 5;
                    ctx.beginPath();
                    ctx.ellipse(hlX, waterSurfaceY + 2, 12, 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Foam on head (toggled with SPACE)
                if (interiorPlayer.bathFoam) {
                    const foamColors = ['#FFFFFF', '#F0F8FF', '#FFFAFA', '#F5F5F5'];
                    const headX = tubCenterX + 5;
                    const headY = waterSurfaceY - 40;

                    // Large foam bubbles cluster
                    for (let i = 0; i < 7; i++) {
                        const angle = (i / 7) * Math.PI * 2;
                        const dist = 8 + (i % 3) * 4;
                        const fx = headX + Math.cos(angle + interiorAnimationFrame * 0.02) * dist;
                        const fy = headY - 10 + Math.sin(angle) * dist * 0.6;
                        const fr = 6 + Math.sin(i * 1.5) * 3;
                        ctx.fillStyle = foamColors[i % foamColors.length];
                        ctx.beginPath();
                        ctx.arc(fx, fy, fr, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.beginPath();
                        ctx.arc(fx - 2, fy - 2, fr * 0.35, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(headX, headY - 12, 9, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(200, 230, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(headX - 3, headY - 15, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Floating foam bubbles
                    for (let i = 0; i < 4; i++) {
                        const fbx = headX + Math.sin(interiorAnimationFrame * 0.04 + i * 1.5) * 20;
                        const fby = headY - 25 - ((interiorAnimationFrame * 0.4 + i * 15) % 35);
                        const fbr = 2.5 + Math.sin(i) * 1;
                        ctx.strokeStyle = 'rgba(200, 220, 255, 0.5)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(fbx, fby, fbr, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                // Happy emoji
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(interiorPlayer.bathFoam ? 'üßº' : 'üòä', tubCenterX + 35, waterSurfaceY - 35 + Math.sin(interiorAnimationFrame * 0.1) * 3);

                // Hint to press SPACE
                ctx.font = '12px Comic Sans MS';
                ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
                ctx.fillText('SPACJA - piana / strza≈Çki - wyjd≈∫', tubCenterX, floorY + 15);

            } else if (interiorPlayer.action === 'eating') {
                // Draw player eating at food bowls with food-to-mouth animation
                const px = interiorPlayer.x;
                const py = interiorPlayer.y;
                drawPlayer(px, py);

                // Animated food piece going from bowl to mouth
                const eatCycle = (interiorAnimationFrame % 40) / 40; // 0-1 cycle
                const bowlY = py + 10; // bowl level
                const mouthY = py - 15; // mouth level
                const mouthX = px + 5;

                // Food piece arc from bowl to mouth
                const foodX = px + 10 - eatCycle * 5;
                const foodY = bowlY + (mouthY - bowlY) * eatCycle - Math.sin(eatCycle * Math.PI) * 15;
                const foodAlpha = eatCycle < 0.9 ? 1 : (1 - (eatCycle - 0.9) / 0.1);

                // Draw the food morsel
                ctx.globalAlpha = foodAlpha;
                const foodColors = ['#8B4513', '#FF6347', '#FFD700', '#32CD32'];
                const foodColor = foodColors[Math.floor(interiorAnimationFrame / 40) % foodColors.length];
                ctx.fillStyle = foodColor;
                ctx.beginPath();
                ctx.arc(foodX, foodY, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                // Open mouth when food arrives
                if (eatCycle > 0.7 && eatCycle < 0.95) {
                    ctx.fillStyle = '#FF6B6B';
                    ctx.beginPath();
                    ctx.arc(mouthX, mouthY, 4, 0, Math.PI);
                    ctx.fill();
                }

                // Chewing cheeks puff
                if (eatCycle > 0.9 || eatCycle < 0.15) {
                    const chewPuff = Math.sin(interiorAnimationFrame * 0.5) * 2;
                    ctx.fillStyle = 'rgba(255, 180, 180, 0.4)';
                    ctx.beginPath();
                    ctx.arc(mouthX - 8, mouthY + 2, 4 + chewPuff, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(mouthX + 8, mouthY + 2, 4 - chewPuff, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Small crumbs falling
                for (let i = 0; i < 2; i++) {
                    const crumbPhase = ((interiorAnimationFrame * 0.06 + i * 0.5) % 1);
                    if (crumbPhase < 0.6) {
                        const cx = mouthX - 3 + i * 6 + Math.sin(interiorAnimationFrame * 0.1 + i) * 3;
                        const cy = mouthY + 3 + crumbPhase * 25;
                        ctx.fillStyle = `rgba(139, 69, 19, ${0.6 * (1 - crumbPhase / 0.6)})`;
                        ctx.beginPath();
                        ctx.arc(cx, cy, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

            } else if (interiorPlayer.action === 'playing') {
                // Draw player playing with ball
                const px = interiorPlayer.x;
                const py = interiorPlayer.y;

                // Player jumping
                const jumpY = py + Math.sin(interiorAnimationFrame * 0.2) * 8;
                drawPlayer(px, jumpY);

                // Ball being tossed up and down
                const ballThrowY = py - 40 - Math.abs(Math.sin(interiorAnimationFrame * 0.15)) * 30;
                const ballThrowX = px + Math.sin(interiorAnimationFrame * 0.15) * 15;

                ctx.fillStyle = '#FF4444';
                ctx.beginPath();
                ctx.arc(ballThrowX, ballThrowY, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFFF44';
                ctx.fillRect(ballThrowX - 12, ballThrowY - 2, 24, 4);

                // Happy emoji
                ctx.font = '18px Arial';
                ctx.fillText('üòÑ', px - 25, py - 25);

            } else if (interiorPlayer.action === 'couch_rest') {
                // Draw player lying on couch
                const couchX = 340;
                const couchY = floorY;
                const couchW = 120;

                ctx.save();
                ctx.translate(couchX + couchW / 2, couchY - 30);
                ctx.rotate(-Math.PI / 2);
                ctx.scale(0.65, 0.65);
                drawPlayer(0, 0);
                ctx.restore();

                // Blanket
                ctx.fillStyle = 'rgba(245, 176, 65, 0.4)';
                ctx.fillRect(couchX + 20, couchY - 35, couchW - 40, 20);

                // Zzz animation (slower, lighter - resting not sleeping)
                const restTime = interiorAnimationFrame * 0.02;
                for (let i = 0; i < 2; i++) {
                    const zOff = ((restTime + i * 1.0) % 2.0);
                    const zAlpha = Math.max(0, 1 - zOff / 2.0);
                    const zSize = 12 + i * 3 + zOff * 6;
                    const zx = couchX + couchW / 2 + 15 + zOff * 12 + i * 6;
                    const zy = couchY - 45 - zOff * 20;
                    ctx.fillStyle = `rgba(100, 150, 200, ${zAlpha * 0.6})`;
                    ctx.font = `bold ${zSize}px Comic Sans MS`;
                    ctx.textAlign = 'center';
                    ctx.fillText('z', zx, zy);
                }

                // Hint
                ctx.font = '12px Comic Sans MS';
                ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
                ctx.textAlign = 'center';
                ctx.fillText('SPACJA - wsta≈Ñ', couchX + couchW / 2, floorY + 15);

            } else {
                // Normal standing - draw player at current position
                drawPlayer(interiorPlayer.x, interiorPlayer.y);
            }

            ctx.restore();
        }

        function drawInteriorHints(bedX, bedW, toiletX, sinkX, bathtubX, floorY) {
            if (interiorPlayer.action !== 'none') return;

            const px = interiorPlayer.x;
            ctx.textAlign = 'center';

            // Near bed?
            if (px > bedX - 20 && px < bedX + bedW + 20) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(bedX + bedW / 2 - 55, floorY - 85, 110, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#9370DB';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(bedX + bedW / 2 - 55, floorY - 85, 110, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#6A5ACD';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - ≈öpij üí§', bedX + bedW / 2, floorY - 67);
            }

            // Near TV (right of bed area)?
            const tvZoneX = 190; // Center of TV interaction zone
            if (px > bedX + bedW + 20 && px < 340) {
                const channelNames = ['Bajka', 'Wiadomo≈õci', 'Sport', 'Moda', 'Wy≈õcigi', 'Klaun', 'Muzyka'];
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(tvZoneX - 75, floorY - 85, 150, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(tvZoneX - 75, floorY - 85, 150, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#E53935';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - ' + channelNames[tvChannel] + ' üì∫', tvZoneX, floorY - 67);
            }

            // Near couch?
            const couchX = 340;
            const couchW = 120;
            if (px > couchX - 20 && px < couchX + couchW + 20) {
                const couchCenterX = couchX + couchW / 2;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(couchCenterX - 70, floorY - 85, 140, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#C0392B';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(couchCenterX - 70, floorY - 85, 140, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#C0392B';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - Po≈Ç√≥≈º siƒô üõãÔ∏è', couchCenterX, floorY - 67);
            }

            // Near toilet?
            if (Math.abs(px - toiletX) < 40) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(toiletX - 60, floorY - 85, 120, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#4169E1';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(toiletX - 60, floorY - 85, 120, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#4169E1';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - Toaleta üöΩ', toiletX, floorY - 67);
            }

            // Near sink?
            if (Math.abs(px - sinkX) < 40) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(sinkX - 65, floorY - 85, 130, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#4169E1';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(sinkX - 65, floorY - 85, 130, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#4169E1';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - Umyj rƒôce üßº', sinkX, floorY - 67);
            }

            // Near bathtub?
            if (Math.abs(px - bathtubX) < 70) {
                const waterLevel = interiorPlayer.bathtubWaterLevel || 0;
                const hintText = waterLevel >= 1 ? 'SPACJA - KƒÖpiel üõÅ' : waterLevel > 0 ? 'SPACJA - Spu≈õƒá wodƒô üîΩ' : 'SPACJA - Napu≈õƒá wodƒô üíß';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(bathtubX - 75, floorY - 85, 150, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#87CEEB';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(bathtubX - 75, floorY - 85, 150, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#87CEEB';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText(hintText, bathtubX, floorY - 67);
            }

            // Near food bowls?
            const bowlX = 510;
            if (Math.abs(px - bowlX) < 60) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(bowlX - 55, floorY - 85, 110, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(bowlX - 55, floorY - 85, 110, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#FF6B6B';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - Jedz üçΩÔ∏è', bowlX, floorY - 67);
            }

            // Near camera?
            const camHintX = 620;
            if (Math.abs(px - camHintX) < 40) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(camHintX - 75, floorY - 85, 150, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(camHintX - 75, floorY - 85, 150, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#555';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - Zr√≥b zdjƒôcie üì∏', camHintX, floorY - 67);
            }

            // Near ball?
            const ballX = 1020;
            if (Math.abs(px - ballX) < 50) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(ballX - 65, floorY - 85, 130, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#FF4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(ballX - 65, floorY - 85, 130, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#FF4444';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - Podrzuƒá üéæ', ballX, floorY - 67);
            }

            // Near exit door?
            const doorX = canvas.width - 350;
            if (px > doorX - 50) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(doorX - 30, floorY - 85, 110, 26, 8);
                ctx.fill();
                ctx.strokeStyle = '#8B6238';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(doorX - 30, floorY - 85, 110, 26, 8);
                ctx.stroke();
                ctx.fillStyle = '#8B6238';
                ctx.font = 'bold 13px Comic Sans MS';
                ctx.fillText('SPACJA - Wyjd≈∫ üö™', doorX + 25, floorY - 67);
            }

            // Near a walking friend?
            if (!activeConversation) {
                for (const friend of interiorFriends) {
                    if (Math.abs(px - friend.x) < 50 && friend.activity === 'walking') {
                        const emoji = friend.type.emoji || friend.type;
                        const name = (animalDialogs[emoji] || {}).name || 'ZwierzƒÖtko';
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.beginPath();
                        ctx.roundRect(friend.x - 70, friend.y - 55, 140, 26, 8);
                        ctx.fill();
                        ctx.strokeStyle = '#FF85A2';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.roundRect(friend.x - 70, friend.y - 55, 140, 26, 8);
                        ctx.stroke();
                        ctx.fillStyle = '#FF85A2';
                        ctx.font = 'bold 13px Comic Sans MS';
                        ctx.fillText(`SPACJA - Pogadaj z ${name}`, friend.x, friend.y - 37);
                        break; // Only show hint for nearest friend
                    }
                }
            }
        }

        // ========== HYCEL SYSTEM ==========

        // Helper function to draw a single Hycel (zwierzak 2x wiƒôkszy)
        function drawSingleHycel(x, y, hycel, animFrame) {
            ctx.save();

            // Scale 2x
            const scale = 2;

            // Get the friend type emoji
            const friendEmoji = hycel.friendType ? hycel.friendType.emoji : 'üê∂';

            // Map emoji to draw function
            const drawFunctions = {
                'üê∂': drawDog,
                'üê∞': drawRabbit,
                'üêª': drawBear,
                'üêë': drawSheep,
                'üê¨': drawDolphin,
                'ü¶ä': drawFox,
                'üêº': drawPanda,
                'ü¶Ñ': drawUnicorn,
                'üê∏': drawFrog,
                'ü¶ã': drawButterfly
            };

            const drawFunction = drawFunctions[friendEmoji] || drawDog;

            // Draw the animal 2x bigger
            drawFunction(x, y, scale);

            // Draw net in hycel's paw/hand
            if (!hycel.defeated) {
                // Position at the right paw of the animal (body center + paw offset, scaled)
                const netX = x + 12 * scale;
                const netY = y + 45 * scale;
                const netR = 10 * scale;
                const swing = Math.sin((animFrame || 0) * 0.05) * 0.15;

                ctx.save();
                ctx.translate(netX, netY);
                ctx.rotate(swing - 0.3); // Tilted slightly as if held

                // Handle/stick (going up from paw into the net)
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2.5 * scale;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -netR * 2.2);
                ctx.stroke();

                // Net ring at the top of the stick
                const ringY = -netR * 2.2;
                ctx.strokeStyle = '#8B6914';
                ctx.lineWidth = 2 * scale;
                ctx.beginPath();
                ctx.arc(0, ringY, netR, 0, Math.PI * 2);
                ctx.stroke();

                // Radial ropes from center
                ctx.lineWidth = 0.8 * scale;
                ctx.strokeStyle = '#A0822A';
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(0, ringY);
                    ctx.lineTo(Math.cos(angle) * netR, ringY + Math.sin(angle) * netR);
                    ctx.stroke();
                }

                // Concentric mesh rings
                ctx.lineWidth = 0.6 * scale;
                for (let r = 1; r <= 2; r++) {
                    ctx.beginPath();
                    ctx.arc(0, ringY, netR * r * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Semi-transparent net fill
                ctx.fillStyle = 'rgba(139, 105, 20, 0.1)';
                ctx.beginPath();
                ctx.arc(0, ringY, netR, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            ctx.restore();
        }

        function drawHycels() {
            hycels.forEach(hycel => {
                const screenX = hycel.x - worldOffset;
                const screenY = hycel.y;

                if (screenX < -100 || screenX > canvas.width + 100) return;

                // Animacja przewracania siƒô po pokonaniu
                if (hycel.defeated) {
                    if (!hycel.fallAnimation) hycel.fallAnimation = 0;
                    hycel.fallAnimation++;

                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(Math.min(hycel.fallAnimation * 0.05, Math.PI / 2)); // Przewr√≥cenie
                    ctx.translate(-screenX, -screenY);
                    ctx.globalAlpha = Math.max(0, 1 - hycel.fallAnimation * 0.02);
                    drawSingleHycel(screenX, screenY, hycel, animationFrame);
                    ctx.restore();
                    return;
                }

                // Bouncing animation
                hycel.bounceOffset += 0.1;
                const bounce = Math.sin(hycel.bounceOffset) * 5;
                const drawY = screenY + bounce;

                // Draw the Hycel using helper function
                drawSingleHycel(screenX, drawY, hycel, animationFrame);

                // Health indicator (green hearts)
                ctx.save();
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                const hearts = 'üíö'.repeat(hycel.health);
                ctx.fillText(hearts, screenX, drawY - 80);
                ctx.restore();

                // Distance check
                const distance = Math.sqrt(
                    Math.pow(player.x - hycel.x, 2) +
                    Math.pow(player.y - hycel.y, 2)
                );

                if (distance < 150) {
                    // Attack prompt
                    ctx.fillStyle = 'rgba(255, 105, 180, 0.95)';
                    ctx.strokeStyle = '#FF1493';
                    ctx.lineWidth = 3;
                    ctx.fillRect(screenX - 100, drawY + 70, 200, 40);
                    ctx.strokeRect(screenX - 100, drawY + 70, 200, 40);

                    ctx.fillStyle = '#FF1493';
                    ctx.font = 'bold 18px Comic Sans MS';
                    ctx.textAlign = 'center';
                    ctx.fillText('SPACJA - Walcz!', screenX, drawY + 95);
                }
            });
        }

        // ========== BATTLE SYSTEM ==========
        function startBattle(hycel) {
            previousState = gameState;
            gameState = 'battle';
            currentBattle = hycel;

            battleState.playerHealth = 5;
            battleState.enemyHealth = hycel.health;
            battleState.playerAttackCooldown = 0;
            battleState.enemyAttackCooldown = 60;
            battleState.message = 'Walcz z Hycelem!';
            battleState.victory = false;
            battleState.defeat = false;
            battleState.attackAnimation = 0;
            battleState.hitAnimation = 0;
            battleState.victoryAnimationFrame = 0;
            battleState.defeatAnimationFrame = 0;

            // Play battle cry
            playAnimalSound('cat');
        }

        function updateBattle() {
            // Update cooldowns
            if (battleState.playerAttackCooldown > 0) {
                battleState.playerAttackCooldown--;
            }
            if (battleState.enemyAttackCooldown > 0) {
                battleState.enemyAttackCooldown--;
            }

            // Update animations
            if (battleState.attackAnimation > 0) {
                battleState.attackAnimation--;
            }
            if (battleState.hitAnimation > 0) {
                battleState.hitAnimation--;
            }

            // Check for player attack
            if (keys[' '] && battleState.playerAttackCooldown === 0 && !battleState.victory && !battleState.defeat) {
                playerAttack();
            }

            // Enemy auto-attack
            if (battleState.enemyAttackCooldown === 0 && !battleState.victory && !battleState.defeat) {
                enemyAttack();
                battleState.enemyAttackCooldown = 60; // 1 second
            }

            // Check victory
            if (battleState.enemyHealth <= 0 && !battleState.victory) {
                battleState.victory = true;
                battleState.message = 'üéâ ZWYCIƒòSTWO! üéâ';
                battleState.victoryAnimationFrame = 0;
            }

            // Check defeat
            if (battleState.playerHealth <= 0 && !battleState.defeat) {
                battleState.defeat = true;
                battleState.message = 'üíî Ojej! Spr√≥buj jeszcze raz! üíî';
                battleState.defeatAnimationFrame = 0;
            }

            // Victory animation counter - auto end after 150 frames (~2.5 seconds)
            if (battleState.victory) {
                battleState.victoryAnimationFrame++;
                if (battleState.victoryAnimationFrame >= 150) {
                    endBattle();
                }
            }

            // Defeat animation counter - auto retry after 90 frames (~1.5 seconds)
            if (battleState.defeat) {
                battleState.defeatAnimationFrame++;
                if (battleState.defeatAnimationFrame >= 90) {
                    endBattle();
                }
            }
        }

        function playerAttack() {
            battleState.enemyHealth--;
            battleState.playerAttackCooldown = 20; // ~0.33s
            battleState.attackAnimation = 10;

            const messages = [
                '≈öwietne uderzenie! üí™',
                'Tak trzymaj! üåü',
                'Super atak! ‚ö°',
                'Doskonale! üéØ',
                'Brawo! ü¶Ñ'
            ];
            battleState.message = messages[Math.floor(Math.random() * messages.length)];

            playAttackSound();
        }

        function enemyAttack() {
            battleState.playerHealth--;
            battleState.hitAnimation = 10;
            battleState.message = 'Hycel zaatakowa≈Ç! Odpieraj siƒô!';

            playHitSound();
        }

        function endBattle() {
            if (battleState.victory) {
                // Mark hycel as defeated
                currentBattle.defeated = true;
                gameState = 'world';

                dialogBubbles.push({
                    x: player.x,
                    y: player.y,
                    text: 'Pokona≈Çem Hycela! üéâ',
                    fromLeft: true,
                    startTime: Date.now(),
                    duration: 2500
                });
            } else if (battleState.defeat) {
                // Reset for retry
                battleState.playerHealth = 5;
                battleState.enemyHealth = currentBattle.health;
                battleState.playerAttackCooldown = 0;
                battleState.enemyAttackCooldown = 60;
                battleState.message = 'Spr√≥buj ponownie!';
                battleState.victory = false;
                battleState.defeat = false;
            }
        }

        function drawBattle() {
            updateBattle();

            // Rainbow gradient background
            const rainbowGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            rainbowGradient.addColorStop(0, '#FF0000');
            rainbowGradient.addColorStop(0.17, '#FF7F00');
            rainbowGradient.addColorStop(0.33, '#FFFF00');
            rainbowGradient.addColorStop(0.5, '#00FF00');
            rainbowGradient.addColorStop(0.67, '#0000FF');
            rainbowGradient.addColorStop(0.83, '#4B0082');
            rainbowGradient.addColorStop(1, '#9400D3');
            ctx.fillStyle = rainbowGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Sparkling stars effect
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 3;
                const alpha = Math.sin(animationFrame * 0.05 + i) * 0.5 + 0.5;

                ctx.save();
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Draw Kicioro≈ºek (left side) - using real graphics!
            const playerBaseX = canvas.width / 3 - 30;
            const playerBaseY = canvas.height / 2;
            const playerX = playerBaseX + (battleState.attackAnimation > 0 ? 30 : 0);
            const playerY = playerBaseY;

            ctx.save();
            if (battleState.hitAnimation > 0 && battleState.hitAnimation % 4 < 2) {
                ctx.globalAlpha = 0.5; // Flash when hit
            }

            // Make player face right for battle
            player.facingRight = true;

            // Draw player
            drawPlayer(playerX, playerY);

            // Attack animation - realistic rainbow beam from horn!
            if (battleState.attackAnimation > 0) {
                const attackProgress = battleState.attackAnimation / 10;

                // Rainbow beam from horn to enemy
                const hornX = playerX + 35;
                const hornY = playerY + 5;
                const targetX = (canvas.width * 2) / 3;
                const targetY = canvas.height / 2;
                const beamDist = Math.sqrt((targetX - hornX) ** 2 + (targetY - hornY) ** 2);

                ctx.save();
                ctx.globalAlpha = attackProgress;

                // Draw each rainbow color as a separate wavy band
                const rainbowColors = [
                    '#FF0000', '#FF4500', '#FF7F00', '#FFD700',
                    '#FFFF00', '#7FFF00', '#00FF00', '#00CED1',
                    '#0000FF', '#4B0082', '#9400D3'
                ];
                const bandWidth = 4;
                const totalWidth = rainbowColors.length * bandWidth;
                const waveAmplitude = 8 + (1 - attackProgress) * 12; // Wave gets stronger as beam extends
                const waveFreq = 0.04;
                const timeOffset = animationFrame * 0.3;

                // Calculate perpendicular direction for band offsets
                const dx = targetX - hornX;
                const dy = targetY - hornY;
                const len = Math.sqrt(dx * dx + dy * dy);
                const perpX = -dy / len;
                const perpY = dx / len;

                // Outer glow
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 30;

                rainbowColors.forEach((color, bandIdx) => {
                    const bandOffset = (bandIdx - rainbowColors.length / 2) * bandWidth;

                    ctx.strokeStyle = color;
                    ctx.lineWidth = bandWidth;
                    ctx.lineCap = 'round';
                    ctx.beginPath();

                    const steps = 40;
                    for (let i = 0; i <= steps; i++) {
                        const t = i / steps;
                        // Base position along the beam
                        const baseX = hornX + dx * t;
                        const baseY = hornY + dy * t;

                        // Sinusoidal wave perpendicular to beam direction
                        const wave = Math.sin(t * beamDist * waveFreq + timeOffset + bandIdx * 0.3) * waveAmplitude * t;

                        // Beam starts narrow at horn, expands toward target
                        const widthScale = 0.3 + t * 0.7;

                        const px = baseX + perpX * (bandOffset * widthScale + wave);
                        const py = baseY + perpY * (bandOffset * widthScale + wave);

                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                });

                ctx.shadowBlur = 0;

                // Bright core beam (white center)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let i = 0; i <= 40; i++) {
                    const t = i / 40;
                    const baseX = hornX + dx * t;
                    const baseY = hornY + dy * t;
                    const wave = Math.sin(t * beamDist * waveFreq + timeOffset) * waveAmplitude * t * 0.3;
                    const px = baseX + perpX * wave;
                    const py = baseY + perpY * wave;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();

                // Sparkles and stars along the beam
                for (let i = 0; i < 15; i++) {
                    const t = (i + Math.sin(animationFrame * 0.1 + i)) / 15;
                    const sparkX = hornX + dx * t + perpX * (Math.sin(animationFrame * 0.2 + i * 2) * 20);
                    const sparkY = hornY + dy * t + perpY * (Math.sin(animationFrame * 0.2 + i * 2) * 20);
                    const sparkSize = 2 + Math.sin(animationFrame * 0.3 + i) * 2;

                    // Star shape
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    for (let s = 0; s < 5; s++) {
                        const angle = (s / 5) * Math.PI * 2 - Math.PI / 2;
                        const outerR = sparkSize;
                        const innerR = sparkSize * 0.4;
                        ctx.lineTo(sparkX + Math.cos(angle) * outerR, sparkY + Math.sin(angle) * outerR);
                        const innerAngle = angle + Math.PI / 5;
                        ctx.lineTo(sparkX + Math.cos(innerAngle) * innerR, sparkY + Math.sin(innerAngle) * innerR);
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                // Impact burst at target
                if (attackProgress > 0.5) {
                    const burstSize = (1 - attackProgress) * 40;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2 + animationFrame * 0.1;
                        ctx.fillStyle = rainbowColors[i % rainbowColors.length];
                        ctx.globalAlpha = attackProgress * 0.7;
                        ctx.beginPath();
                        ctx.arc(
                            targetX + Math.cos(angle) * burstSize,
                            targetY + Math.sin(angle) * burstSize,
                            4, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }

                ctx.restore();
            }
            ctx.restore();

            // Draw Hycel (right side) - using real graphics!
            const enemyX = (canvas.width * 2) / 3;
            const enemyY = canvas.height / 2;

            // Scale up the Hycel for battle
            ctx.save();

            // Hycel falling animation on victory
            if (battleState.victory) {
                const fallProgress = Math.min(battleState.victoryAnimationFrame / 100, 1);

                ctx.translate(enemyX, enemyY);
                // Powolny obr√≥t (przewracanie siƒô)
                ctx.rotate(fallProgress * Math.PI / 2);
                // Opadanie w d√≥≈Ç
                ctx.translate(0, fallProgress * 100);
                // Zanikanie
                ctx.globalAlpha = Math.max(0, 1 - fallProgress * 0.8);
                ctx.translate(-enemyX, -enemyY);

                drawSingleHycel(enemyX, enemyY, currentBattle, animationFrame);
            } else {
                // Enemy attack animation - throwing realistic net!
                if (battleState.enemyAttackCooldown > 50 && battleState.enemyAttackCooldown <= 60 && !battleState.defeat) {
                    const throwProgress = (60 - battleState.enemyAttackCooldown) / 10;
                    const netX = enemyX - throwProgress * 200;
                    const netY = enemyY;
                    const netRadius = 45;
                    const rotation = throwProgress * Math.PI * 2; // Net spins as it flies

                    ctx.save();
                    ctx.translate(netX, netY);
                    ctx.rotate(rotation);

                    // Outer ring of the net (thick rope)
                    ctx.strokeStyle = '#8B6914';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, netRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Inner ring
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#A0822A';
                    ctx.beginPath();
                    ctx.arc(0, 0, netRadius * 0.6, 0, Math.PI * 2);
                    ctx.stroke();

                    // Radial ropes from center to outer ring (like a spider web)
                    ctx.strokeStyle = '#8B6914';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * netRadius, Math.sin(angle) * netRadius);
                        ctx.stroke();
                    }

                    // Concentric rope rings (mesh pattern)
                    ctx.lineWidth = 1.5;
                    ctx.strokeStyle = '#A0822A';
                    for (let r = 0; r < 3; r++) {
                        const ringRadius = netRadius * (0.25 + r * 0.2);
                        ctx.beginPath();
                        ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // Weighted knots on outer ring
                    ctx.fillStyle = '#654321';
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.arc(Math.cos(angle) * netRadius, Math.sin(angle) * netRadius, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Semi-transparent fill for net area
                    ctx.fillStyle = 'rgba(139, 105, 20, 0.15)';
                    ctx.beginPath();
                    ctx.arc(0, 0, netRadius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }

                drawSingleHycel(enemyX, enemyY, currentBattle, animationFrame);
            }
            ctx.restore();

            // Health bars at top
            drawHealthBar(50, 50, battleState.playerHealth, 5, '#00FF00', 'Kicioro≈ºek');
            drawHealthBar(canvas.width - 350, 50, battleState.enemyHealth, currentBattle.health, '#FF0000', 'Hycel');

            // Message box at bottom
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillRect(canvas.width / 2 - 250, canvas.height - 120, 500, 80);
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 5;
            ctx.strokeRect(canvas.width / 2 - 250, canvas.height - 120, 500, 80);

            ctx.fillStyle = '#FF1493';
            ctx.font = 'bold 20px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText(battleState.message, canvas.width / 2, canvas.height - 70);

            // Controls hint
            if (!battleState.victory && !battleState.defeat) {
                ctx.font = 'bold 18px Comic Sans MS';
                ctx.fillText('SPACJA - Atak! üó°Ô∏è', canvas.width / 2, canvas.height - 40);
            }

            // Victory overlay with friend approaching animation
            if (battleState.victory) {
                const victoryProgress = battleState.victoryAnimationFrame / 150;

                // Fade in green overlay
                ctx.fillStyle = `rgba(0, 255, 0, ${Math.min(0.3, victoryProgress * 0.5)})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Victory text
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 60px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('üéâ ZWYCIƒòSTWO! üéâ', canvas.width / 2, canvas.height / 2 - 50);

                ctx.font = 'bold 30px Comic Sans MS';
                ctx.fillText('Uratowa≈Çe≈õ przyjaciela!', canvas.width / 2, canvas.height / 2 + 20);

                // Friend approaching from right to player
                if (victoryProgress > 0.3) {
                    const friendProgress = Math.min((victoryProgress - 0.3) / 0.7, 1);
                    const friendX = enemyX - (enemyX - playerX - 80) * friendProgress;
                    const friendY = canvas.height / 2;

                    // Draw the rescued friend using real draw function
                    const friendType = currentBattle.friendType;
                    const drawFunctions = {
                        'üê∂': drawDog, 'üê∞': drawRabbit, 'üêª': drawBear, 'üêë': drawSheep,
                        'üê¨': drawDolphin, 'ü¶ä': drawFox, 'üêº': drawPanda, 'ü¶Ñ': drawUnicorn,
                        'üê∏': drawFrog, 'ü¶ã': drawButterfly
                    };
                    const drawFn = drawFunctions[friendType.emoji] || drawDog;
                    ctx.save();
                    drawFn(friendX, friendY, 1);
                    ctx.restore();
                }
            }

            // Defeat overlay
            if (battleState.defeat) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 60px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.fillText('üíî Ojej! üíî', canvas.width / 2, canvas.height / 2 - 50);

                ctx.font = 'bold 30px Comic Sans MS';
                ctx.fillText('Spr√≥buj jeszcze raz!', canvas.width / 2, canvas.height / 2 + 20);
            }
        }

        function drawHealthBar(x, y, current, max, color, label) {
            // Label
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 20px Comic Sans MS';
            ctx.textAlign = 'left';
            ctx.fillText(label, x, y - 10);

            // Bar background
            ctx.fillStyle = '#333';
            ctx.fillRect(x, y, 300, 30);

            // Bar foreground
            ctx.fillStyle = color;
            const width = (current / max) * 300;
            ctx.fillRect(x, y, width, 30);

            // Bar outline
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 3;
            ctx.strokeRect(x, y, 300, 30);

            // Health text
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 18px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText(`${current}/${max}`, x + 150, y + 22);
        }

        // Sound functions
        function playAttackSound() {
            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.connect(gain);
            gain.connect(audioContext.destination);

            osc.frequency.setValueAtTime(800, now);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

            osc.start(now);
            osc.stop(now + 0.1);
        }

        function playHitSound() {
            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.connect(gain);
            gain.connect(audioContext.destination);

            osc.frequency.setValueAtTime(200, now);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

            osc.start(now);
            osc.stop(now + 0.2);
        }

        // Pƒôtla
        function gameLoop() {
            if (!gameRunning) return;

            animationFrame++;
            if (houseCooldown > 0) houseCooldown--;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // State-based rendering
            if (gameState === 'interior') {
                drawInterior();
            } else if (gameState === 'battle') {
                drawBattle();
            } else {
                // Normal world rendering
                drawBackground();
                drawTrees();
                drawFlowers();
                drawGround();
                drawDecorations();
                drawPassingAnimals();
                drawCandies();
                drawItemsToCollect();
                drawHouses(); // Draw houses
                drawHycels(); // Draw hycels
                drawFriendsToFind();
                drawFollowingFriends();
                if (!slideState.active) {
                    drawPlayer(player.x - worldOffset, player.y);
                }

                // Show cat needs above player in world (thought bubble)
                const needThresholdWorld = 70;
                const worldNeeds = [];
                if (catNeeds.hunger >= needThresholdWorld) worldNeeds.push('hunger');
                if (catNeeds.sleep >= needThresholdWorld) worldNeeds.push('sleep');
                if (catNeeds.toilet >= needThresholdWorld) worldNeeds.push('toilet');
                if (catNeeds.hygiene >= needThresholdWorld) worldNeeds.push('hygiene');
                if (worldNeeds.length > 0) {
                    const npx = player.x - worldOffset + 30;
                    const npy = player.y - 30;
                    const nbW = worldNeeds.length * 28 + 12;

                    // Thought bubble dots
                    ctx.fillStyle = 'rgba(255,255,255,0.8)';
                    ctx.beginPath();
                    ctx.arc(npx + 5, npy + 5, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(npx + 2, npy - 3, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Bubble
                    ctx.fillStyle = 'rgba(255,255,255,0.85)';
                    ctx.beginPath();
                    ctx.roundRect(npx - nbW / 2, npy - 35, nbW, 28, 10);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 150, 180, 0.6)';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.roundRect(npx - nbW / 2, npy - 35, nbW, 28, 10);
                    ctx.stroke();

                    // Mini icons
                    worldNeeds.forEach((need, i) => {
                        const ix = npx - nbW / 2 + 18 + i * 28;
                        const iy = npy - 21;
                        ctx.save();
                        ctx.translate(ix, iy);

                        if (need === 'hunger') {
                            // Fish
                            ctx.fillStyle = '#FF8C42';
                            ctx.beginPath();
                            ctx.ellipse(0, 0, 8, 5, 0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.moveTo(-8, 0);
                            ctx.lineTo(-13, -4);
                            ctx.lineTo(-13, 4);
                            ctx.closePath();
                            ctx.fill();
                        } else if (need === 'sleep') {
                            // Moon
                            ctx.fillStyle = '#6B7EC4';
                            ctx.beginPath();
                            ctx.arc(0, 0, 7, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = 'rgba(255,255,255,0.85)';
                            ctx.beginPath();
                            ctx.arc(3, -2, 6, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (need === 'toilet') {
                            // Roll
                            ctx.fillStyle = '#A0764B';
                            ctx.beginPath();
                            ctx.roundRect(-6, -6, 12, 12, 2);
                            ctx.fill();
                            ctx.fillStyle = '#FFF';
                            ctx.beginPath();
                            ctx.arc(0, 0, 4, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (need === 'hygiene') {
                            // Drop
                            ctx.fillStyle = '#5DADE2';
                            ctx.beginPath();
                            ctx.moveTo(0, -8);
                            ctx.quadraticCurveTo(7, 0, 0, 7);
                            ctx.quadraticCurveTo(-7, 0, 0, -8);
                            ctx.fill();
                        }
                        ctx.restore();
                    });
                }

                // Rain (drawn over everything)
                drawRain();

                updateAndDrawDialogBubbles();

                updatePlayer();
                updatePassingAnimals();
                checkCollectibles();
            }

            requestAnimationFrame(gameLoop);
        }

        // Extracted SPACE handler callable from both keyboard and touch
        function handleSpacePress() {
            // Start game from start screen
            if (!gameRunning && document.getElementById('start-screen').classList.contains('active')) {
                startGame();
                return;
            }

            // Slide interaction (world)
            if (gameState === 'world' && slideState.active && !slideState.sliding) {
                slideState.climbStep++;
                if (slideState.climbStep >= 3) {
                    slideState.climbStep = 3;
                    slideState.sliding = true;
                    slideState.slideProgress = 0;
                }
                return;
            }

            // Interior interactions
            if (gameState === 'interior') {
                const px = interiorPlayer.x;
                const floorY = canvas.height - 180;

                if (interiorPlayer.action === 'sleeping') {
                    interiorPlayer.action = 'none';
                    catNeeds.sleep = 0;
                    return;
                }
                if (interiorPlayer.action === 'couch_rest') {
                    interiorPlayer.action = 'none';
                    catNeeds.sleep = Math.max(0, catNeeds.sleep - 30);
                    return;
                }
                if (interiorPlayer.action === 'bathing') {
                    interiorPlayer.bathFoam = !interiorPlayer.bathFoam;
                    return;
                }
                if (interiorPlayer.action !== 'none') return;

                for (const friend of interiorFriends) {
                    if (Math.abs(px - friend.x) < 50 && friend.activity === 'walking') {
                        startAnimalConversation(friend);
                        return;
                    }
                }

                const bedX = 30;
                const bedW = 120;
                if (px > bedX - 20 && px < bedX + bedW + 20) {
                    interiorPlayer.action = 'sleeping';
                    interiorPlayer.actionTimer = -1;
                    return;
                }
                const tvX = 80;
                const tvW = 220;
                if (px > bedX + bedW + 20 && px < tvX + tvW + 30) {
                    tvChannel = (tvChannel + 1) % 7;
                    return;
                }
                const couchX = 340;
                const couchW = 120;
                if (px > couchX - 20 && px < couchX + couchW + 20) {
                    interiorPlayer.action = 'couch_rest';
                    interiorPlayer.actionTimer = -1;
                    return;
                }
                const toiletX = 700;
                if (Math.abs(px - toiletX) < 40) {
                    interiorPlayer.action = 'toilet';
                    interiorPlayer.actionTimer = 120;
                    return;
                }
                const sinkX = toiletX + 80;
                if (Math.abs(px - sinkX) < 40) {
                    interiorPlayer.action = 'washing';
                    interiorPlayer.actionTimer = 90;
                    return;
                }
                const bathtubX = toiletX + 220;
                if (Math.abs(px - bathtubX) < 70) {
                    if (!interiorPlayer.bathtubWaterLevel) interiorPlayer.bathtubWaterLevel = 0;
                    if (interiorPlayer.bathtubWaterLevel >= 1) {
                        interiorPlayer.action = 'bathing';
                        interiorPlayer.actionTimer = -1;
                        interiorPlayer.bathFoam = false;
                        return;
                    } else if (interiorPlayer.bathtubWaterLevel > 0) {
                        interiorPlayer.action = 'draining_water';
                        return;
                    } else {
                        interiorPlayer.action = 'filling_water';
                        interiorPlayer.actionTimer = 30;
                        return;
                    }
                }
                const bowlX = 510;
                if (Math.abs(px - bowlX) < 60) {
                    interiorPlayer.action = 'eating';
                    interiorPlayer.actionTimer = 120;
                    return;
                }
                const ballX = 1020;
                if (Math.abs(px - ballX) < 50) {
                    interiorPlayer.action = 'playing';
                    interiorPlayer.actionTimer = 90;
                    return;
                }
                const cameraX = 620;
                if (Math.abs(px - cameraX) < 40) {
                    photoFlashTimer = 20;
                    const photoCanvas = document.createElement('canvas');
                    photoCanvas.width = 360;
                    photoCanvas.height = 220;
                    const pctx = photoCanvas.getContext('2d');
                    const bgGrad = pctx.createLinearGradient(0, 0, 0, 160);
                    bgGrad.addColorStop(0, '#FFF5E6');
                    bgGrad.addColorStop(1, '#FFECD2');
                    pctx.fillStyle = bgGrad;
                    pctx.fillRect(0, 0, 360, 160);
                    pctx.fillStyle = '#C4935A';
                    pctx.fillRect(0, 160, 360, 60);
                    pctx.strokeStyle = 'rgba(101,67,33,0.3)';
                    pctx.lineWidth = 1;
                    for (let fy = 160; fy < 220; fy += 12) {
                        pctx.beginPath(); pctx.moveTo(0, fy); pctx.lineTo(360, fy); pctx.stroke();
                    }
                    const friends = interiorFriends.slice();
                    const totalChars = friends.length + 1;
                    const spacing = Math.min(50, 300 / (totalChars + 1));
                    const startX = 180 - (totalChars - 1) * spacing / 2;
                    const groundLevel = 155;
                    const charPositions = [];
                    const playerIndex = Math.floor(totalChars / 2);
                    let friendIdx = 0;
                    for (let i = 0; i < totalChars; i++) {
                        const cx = startX + i * spacing;
                        if (i === playerIndex) {
                            charPositions.push({ type: 'player', x: cx });
                        } else if (friendIdx < friends.length) {
                            charPositions.push({ type: 'friend', x: cx, friend: friends[friendIdx] });
                            friendIdx++;
                        }
                    }
                    pctx.save();
                    const scale = 0.6;
                    charPositions.forEach(cp => {
                        pctx.save();
                        pctx.translate(cp.x, groundLevel);
                        pctx.scale(scale, scale);
                        if (cp.type === 'player') {
                            pctx.fillStyle = '#FFB6C1';
                            pctx.beginPath(); pctx.ellipse(0, -15, 12, 18, 0, 0, Math.PI * 2); pctx.fill();
                            pctx.beginPath(); pctx.arc(0, -40, 12, 0, Math.PI * 2); pctx.fill();
                            pctx.fillStyle = '#000';
                            pctx.beginPath(); pctx.arc(-4, -42, 2, 0, Math.PI * 2); pctx.arc(4, -42, 2, 0, Math.PI * 2); pctx.fill();
                            pctx.strokeStyle = '#000'; pctx.lineWidth = 1.5;
                            pctx.beginPath(); pctx.arc(0, -38, 5, 0.2, Math.PI - 0.2); pctx.stroke();
                            pctx.fillStyle = '#FFD700';
                            pctx.beginPath(); pctx.moveTo(-2, -52); pctx.lineTo(0, -65); pctx.lineTo(2, -52); pctx.fill();
                            pctx.fillStyle = '#FFB6C1';
                            [-6, 6].forEach(lx => { pctx.fillRect(lx - 3, 0, 6, 12); });
                        } else {
                            const emoji = cp.friend.type.emoji || cp.friend.type;
                            const colors = {'üê∂':'#C4A265','üê∞':'#DDD','üêª':'#8B6914','üêë':'#F5F5F5','üê¨':'#5DADE2','ü¶ä':'#FF8C00','üêº':'#333','ü¶Ñ':'#DDA0DD','üê∏':'#32CD32','ü¶ã':'#FF69B4'};
                            const col = colors[emoji] || '#AAA';
                            pctx.fillStyle = col;
                            pctx.beginPath(); pctx.ellipse(0, -12, 10, 14, 0, 0, Math.PI * 2); pctx.fill();
                            pctx.beginPath(); pctx.arc(0, -32, 9, 0, Math.PI * 2); pctx.fill();
                            pctx.fillStyle = '#000';
                            pctx.beginPath(); pctx.arc(-3, -33, 1.5, 0, Math.PI * 2); pctx.arc(3, -33, 1.5, 0, Math.PI * 2); pctx.fill();
                            pctx.strokeStyle = '#000'; pctx.lineWidth = 1;
                            pctx.beginPath(); pctx.arc(0, -30, 4, 0.2, Math.PI - 0.2); pctx.stroke();
                            pctx.fillStyle = col;
                            [-5, 5].forEach(lx => { pctx.fillRect(lx - 2, 0, 4, 10); });
                        }
                        pctx.restore();
                    });
                    pctx.restore();
                    pctx.fillStyle = 'rgba(255,255,255,0.7)';
                    pctx.font = 'bold 14px Comic Sans MS';
                    pctx.textAlign = 'center';
                    pctx.fillText('üì∏ Rodzinna fotka! üì∏', 180, 18);
                    pctx.font = '10px Arial';
                    charPositions.forEach((cp, i) => {
                        pctx.fillText('‚ù§Ô∏è', cp.x, groundLevel - 55 * scale - 10 + Math.sin(i * 1.5) * 3);
                    });
                    const img = new Image();
                    img.src = photoCanvas.toDataURL('image/png');
                    wallPhoto = { _img: img, loaded: false };
                    img.onload = () => { wallPhoto.loaded = true; };
                    return;
                }
                const doorX = canvas.width - 350;
                if (px > doorX - 50) {
                    exitHouse();
                    return;
                }
            }
        }

        // Kontrolki
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ' || e.key === 'ArrowUp') e.preventDefault();

            if (e.key === ' ') {
                handleSpacePress();
            }

            // Uruchom muzykƒô w tle przy pierwszym klawiszu
            startBackgroundMusic();
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Uruchomienie muzyki tak≈ºe przy klikniƒôciu
        document.addEventListener('click', () => {
            startBackgroundMusic();
        });

        // ========== TOUCH CONTROLS FOR MOBILE/TABLET ==========

        // Detect touch device
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        if (isTouchDevice) {
            document.getElementById('touch-controls').style.display = 'block';
        }

        // Prevent page scrolling/zooming on touch
        document.addEventListener('touchmove', (e) => {
            if (e.target.closest('#touch-controls') || e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });

        document.addEventListener('touchstart', (e) => {
            if (e.target === canvas) {
                e.preventDefault();
                startBackgroundMusic();
            }
        }, { passive: false });

        // Touch button handlers - simulate key presses
        function setupTouchButton(element) {
            if (!element) return;
            const key = element.dataset.key;
            if (!key) return;

            let touchId = null;

            element.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                touchId = e.changedTouches[0].identifier;
                element.classList.add('pressed');
                keys[key] = true;

                // For SPACE, call the handler directly
                if (key === ' ') {
                    handleSpacePress();
                }

                startBackgroundMusic();
            }, { passive: false });

            element.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                for (const t of e.changedTouches) {
                    if (t.identifier === touchId) {
                        element.classList.remove('pressed');
                        keys[key] = false;
                        touchId = null;
                        break;
                    }
                }
            }, { passive: false });

            element.addEventListener('touchcancel', (e) => {
                element.classList.remove('pressed');
                keys[key] = false;
                touchId = null;
            }, { passive: false });
        }

        // Setup all touch buttons
        document.querySelectorAll('.touch-btn, .touch-btn-action, .touch-btn-jump').forEach(btn => {
            setupTouchButton(btn);
        });

        // Handle touch on canvas for start screen tap
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameRunning && document.getElementById('start-screen').classList.contains('active')) {
                startGame();
            }
            startBackgroundMusic();
        }, { passive: false });

        // Multi-touch support for d-pad: track active touches
        const touchDpad = document.querySelector('.touch-dpad');
        if (touchDpad) {
            let activeDpadTouches = {};

            touchDpad.addEventListener('touchstart', (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    const target = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (target && target.dataset.key) {
                        activeDpadTouches[touch.identifier] = target.dataset.key;
                        keys[target.dataset.key] = true;
                        target.classList.add('pressed');
                    }
                }
            }, { passive: false });

            touchDpad.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    const oldKey = activeDpadTouches[touch.identifier];
                    const target = document.elementFromPoint(touch.clientX, touch.clientY);
                    const newKey = target && target.dataset ? target.dataset.key : null;

                    if (oldKey && oldKey !== newKey) {
                        keys[oldKey] = false;
                        const oldEl = touchDpad.querySelector(`[data-key="${oldKey}"]`);
                        if (oldEl) oldEl.classList.remove('pressed');
                    }
                    if (newKey && newKey !== oldKey) {
                        keys[newKey] = true;
                        target.classList.add('pressed');
                        activeDpadTouches[touch.identifier] = newKey;
                    }
                    if (!newKey) {
                        delete activeDpadTouches[touch.identifier];
                    }
                }
            }, { passive: false });

            const endDpadTouch = (e) => {
                for (const touch of e.changedTouches) {
                    const key = activeDpadTouches[touch.identifier];
                    if (key) {
                        keys[key] = false;
                        const el = touchDpad.querySelector(`[data-key="${key}"]`);
                        if (el) el.classList.remove('pressed');
                        delete activeDpadTouches[touch.identifier];
                    }
                }
            };

            touchDpad.addEventListener('touchend', endDpadTouch, { passive: false });
            touchDpad.addEventListener('touchcancel', endDpadTouch, { passive: false });
        }
    </script>
</body>
</html>
